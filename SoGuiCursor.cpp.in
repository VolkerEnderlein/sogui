/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 1998-2001 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

/*!
  \class So@Gui@Cursor
  \brief The So@Gui@Cursor class is used to set cursors for GUI components.
  \ingroup common
*/

#include <Inventor/@Gui@/So@Gui@Cursor.h>
#include <assert.h>

/*!
  \enum So@Gui@Component::Shape
  For enumerating built-in shape types.
*/


/*!
  \var So@Gui@Cursor::Shape So@Cui@Cursor::DEFAULT
  The Window system's default cursor.
*/

/*!
  \var So@Gui@Cursor::Shape So@Cui@Cursor::WAIT
  A busy cursor.
*/

/*!
  \var So@Gui@Cursor::Shape So@Cui@Cursor::CUSTOM_BITMAP
  A custom cursor.
*/

/*** Graphic data for the mouse pointer bitmaps. ***********************/

static unsigned char zoom_bitmap[] =
{
 0xff,0xff,0xfd,0xbc,0x7f,0xf8,0x3f,0xf0,0x9f,0xe4,0xcf,0xcc,0xff,0xfc,0xff,
 0xfc,0xff,0xfc,0xff,0xfc,0xcf,0xcc,0x9f,0xe4,0x3f,0xf0,0x7f,0xf8,0xff,0xfc,
 0xff,0xff
};

static unsigned char zoom_mask_bitmap[] =
{
 0x00,0x0f,0x80,0x1f,0xc0,0x3f,0xe0,0x7f,0xf0,0xff,0xf0,0xff,0xf0,0xff,0x00,
 0x0f,0x00,0x0f,0xf0,0xff,0xf0,0xff,0xf0,0xff,0xe0,0x7f,0xc0,0x3f,0x80,0x1f,
 0x00,0x0f
};

static unsigned char pan_bitmap[] =
{
 0xff,0xff,0x7f,0xfe,0x3f,0xfc,0x1f,0xf8,0x7f,0xfe,0x77,0xee,0x73,0xce,0x01,
 0x80,0x01,0x80,0x73,0xce,0x77,0xee,0x7f,0xfe,0x1f,0xf8,0x3f,0xfc,0x7f,0xfe,
 0xff,0xff
};

static unsigned char pan_mask_bitmap[] =
{
 0xc0,0x03,0xe0,0x03,0xe0,0x07,0xf0,0x0f,0xe8,0x17,0xdc,0x3b,0xff,0xff,0xff,
 0xff,0xff,0xff,0xff,0xff,0xdc,0x3b,0xe8,0x17,0xf0,0x0f,0xe0,0x07,0xc0,0x03,
 0xc0,0x03
};

static unsigned char rotate_bitmap[] = {
 0xff,0xff,0x1f,0xb8,0x0f,0x90,0xe7,0x83,0xf7,0x87,0xff,0x83,0xff,0x81,0xff,
 0xff,0xff,0xff,0x81,0xff,0xc1,0xff,0xe1,0xef,0xc1,0xe7,0x09,0xf0,0x1d,0xf8,
 0xff,0xff
};

static unsigned char rotate_mask_bitmap[] = {
 0xf0,0xef,0xf8,0xff,0xfc,0xff,0xfc,0xff,0x3c,0xfe,0x1c,0xff,0x00,0xff,0x00,
 0xff,0xff,0x00,0xff,0x00,0xff,0x38,0x7f,0x3c,0xff,0x3f,0xff,0x3f,0xff,0x1f,
 0xf7,0x0f
};

/***********************************************************************/


static So@Gui@Cursor::CustomCursor zoom;
static So@Gui@Cursor::CustomCursor pan;
static So@Gui@Cursor::CustomCursor rotate;
static SbBool first = TRUE;


/*!
  Default constructor. Creates a default cursor.
*/
So@Gui@Cursor::So@Gui@Cursor(void)
{
  this->commonConstructor(So@Gui@Cursor::DEFAULT, NULL);
}

/*!
  Constructor with Shape argument.
*/
So@Gui@Cursor::So@Gui@Cursor(const Shape shape)
{ 
  assert(shape != CUSTOM_BITMAP && "don't use this constructor for making CUSTOM_BITMAP cursors");
  this->commonConstructor(shape, NULL);
}

/*!
  Constructs a new custom bitmap cursor from \a cc.

  Note that only a \e shallow copy will be made of the CustomCursor
  bitmap and mask references, so don't deallocate the memory they use
  until the So@Gui@Cursor has been destructed.
*/
So@Gui@Cursor::So@Gui@Cursor(const CustomCursor * cc)
{ 
  this->commonConstructor(CUSTOM_BITMAP, cc);
}

// Private common constructor.
void
So@Gui@Cursor::commonConstructor(const Shape shape, const CustomCursor * cc)
{ 
  this->shape = shape;

  if (cc) {
    assert(shape == CUSTOM_BITMAP);
    this->cc = new CustomCursor;
    *(this->cc) = *cc;
  }

  if (first) {
    zoom.dim = SbVec2s(16, 16);
    zoom.hotspot = SbVec2s(5, 7);
    zoom.bitmap = zoom_bitmap;
    zoom.mask = zoom_mask_bitmap;

    pan.dim = SbVec2s(16, 16);
    pan.hotspot = SbVec2s(7, 7);
    pan.bitmap = pan_bitmap;
    pan.mask = pan_mask_bitmap;

    rotate.dim = SbVec2s(16, 16);
    rotate.hotspot = SbVec2s(6, 8);
    rotate.bitmap = rotate_bitmap;
    rotate.mask = rotate_mask_bitmap;

    first = FALSE;
  }
}


/*!
  Destructor
*/
So@Gui@Cursor::~So@Gui@Cursor()
{
  delete this->cc;
}

/*!
  Returns the shape type.

  If the cursor has been set by the application programmer to a bitmap
  cursor, So@Gui@Cursor::CUSTOM_BITMAP is returned.
*/
So@Gui@Cursor::Shape 
So@Gui@Cursor::getShape(void) const
{
  return this->shape;
}

/*!
  Sets the cursor to a predefined shape.
*/
void 
So@Gui@Cursor::setShape(const Shape shape)
{
  this->shape = shape;
}

/*!
  Returns a reference to the current custom bitmap cursor.

  Do not call this method unless So@Gui@Cursor::getShape() returns
  So@Gui@Cursor::CUSTOM_BITMAP.
*/
const So@Gui@Cursor::CustomCursor &
So@Gui@Cursor::getCustomCursor(void) const
{
  assert(cc!=NULL && "not a custom bitmap cursor");
  return *(this->cc);
}

const So@Gui@Cursor &
So@Gui@Cursor::getZoomCursor(void)
{
  static So@Gui@Cursor * zoomcursor = NULL;
  // FIXME: memory leak. 20011120 mortene.
  if (!zoomcursor) { zoomcursor = new So@Gui@Cursor(&zoom); }
  return *zoomcursor;
}

const So@Gui@Cursor &
So@Gui@Cursor::getPanCursor(void)
{
  static So@Gui@Cursor * pancursor = NULL;
  // FIXME: memory leak. 20011120 mortene.
  if (!pancursor) { pancursor = new So@Gui@Cursor(&pan); }
  return *pancursor;
}

const So@Gui@Cursor &
So@Gui@Cursor::getRotateCursor(void)
{
  static So@Gui@Cursor * rotatecursor = NULL;
  // FIXME: memory leak. 20011120 mortene.
  if (!rotatecursor) { rotatecursor = new So@Gui@Cursor(&rotate); }
  return *rotatecursor;
}
