/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SO@GUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@GUI@_DEBUG

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#include <stdlib.h>
#include <math.h>

#if HAVE_WINDOWS_H
#include <windows.h> // gl.h needs this.
#endif // HAVE_WINDOWS_H
#include <GL/gl.h>

#include <Inventor/SoDB.h>

#include <Inventor/nodes/SoBaseColor.h>
#include <Inventor/nodes/SoComplexity.h>
#include <Inventor/nodes/SoDirectionalLight.h>
#include <Inventor/nodes/SoDrawStyle.h>
#include <Inventor/nodes/SoLightModel.h>
#include <Inventor/nodes/SoLocateHighlight.h>
#include <Inventor/nodes/SoMaterialBinding.h>
#include <Inventor/nodes/SoOrthographicCamera.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/nodes/SoRotation.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/nodes/SoTransformSeparator.h>

#include <Inventor/actions/SoGetBoundingBoxAction.h>
#include <Inventor/actions/SoSearchAction.h>
#include <Inventor/actions/SoRayPickAction.h>

#include <Inventor/errors/SoDebugError.h>
#include <Inventor/misc/SoCallbackList.h>
#include <Inventor/sensors/SoTimerSensor.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/SoSceneManager.h>
#include <Inventor/SoPickedPoint.h>

#include <so@gui@defs.h>
#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/viewers/So@Gui@Viewer.h>

#if HAVE_SOPOLYGONOFFSET
#include <Inventor/nodes/SoPolygonOffset.h>
#endif // HAVE_SOPOLYGONOFFSET

#ifndef M_PI
#define M_PI 3.1415926535f
#endif // ! M_PI

// environment variable
static int COIN_SHOW_FPS_COUNTER = -1;

/*!
  \class So@Gui@Viewer Inventor/@Gui@/viewers/So@Gui@Viewer.h
  \brief The So@Gui@Viewer class is the top level base viewer class.
  \ingroup components viewers common

  TODO: more doc
  ...overview of what this class provides over parent class...
  ...keyboard combinations: Home, s, arrow keys (but only during
  viewing), Esc...
  ...explain pan, rotate, zoom, dolly, seek...
  ..explain the fact that we're moving the camera, not the scene...
  ...viewer modes (examine vs interact) w/ explanation of what they are
  useful for...

  The So@Gui@Viewer code is completely generated from autogenerated
  source code.
*/

// *************************************************************************

static char normal_scene_graph[] =
  "#Inventor V2.1\n"
  "\n"
  "Separator {\n"
    "renderCaching = OFF\n"
    "renderCulling = OFF\n"
    "Switch {\n"
      "whichChild = -1\n"
      "LightModel {\n"
        "override = TRUE\n"
        "model = BASE_COLOR\n"
      "}\n"
      "DrawStyle {\n"
        "override = TRUE\n"
        "pointSize = IGNORED\n"
        "lineWidth = IGNORED\n"
        "linePattern = IGNORED\n"
      "}\n"
      "Complexity {\n"
        "override = TRUE\n"
        "textureQuality = 0.0\n"
        "value = 1.0\n"
      "}\n"
    "}\n"
    "Switch {\n"
      "whichChild = -1\n"
      "BaseColor {"
        "override = TRUE\n"
      "}\n"
      "MaterialBinding {\n"
        "override = TRUE\n"
        "value = OVERALL\n"
      "}\n"
      "Switch {\n"
        "whichChild = -1\n"
        "PolygonOffset {\n"
          "override = TRUE\n"
        "}\n"
      "}\n"
    "}\n"
  "}";

// *************************************************************************

// The private data for the So@Gui@Viewer.
class So@Gui@ViewerP {
public:
  So@Gui@ViewerP( So@Gui@Viewer * publ );
  ~So@Gui@ViewerP(void);

  // Seek functionality
  SoTimerSensor * seeksensor;
  float seekperiod;
  SbBool inseekmode;
  SbBool seektopoint;
  SbVec3f camerastartposition, cameraendposition;
  float seekdistance;
  SbBool seekdistanceabs;

  // Camera handling
  SbBool deletecamera;
  SbVec3f storedposition;
  SbRotation storedorientation;
  float storedheightval;

  // Headlight handling
  SbBool lighton;
  SoGroup * lightroot;

  // Drawstyles
  So@Gui@Viewer::DrawStyle drawstyles[2];
  SoSwitch * drawstyleroot, * hiddenlineroot, * polygonoffsetparent;
  SoBaseColor * sobasecolor;
  SoComplexity * socomplexity;
  SoDrawStyle * sodrawstyle;
  SoLightModel * solightmodel;
  SoMaterialBinding * somaterialbinding;
  SoPolygonOffset * sopolygonoffset;

  // Automatic setting of clipping planes
  SbBool adjustclipplanes;

  // Keep track of the frames-per-second counter.
  enum { FRAMESARRAY_SIZE = 100 }; // Const value trick for old compilers.
  double lasttimeofday, frames[FRAMESARRAY_SIZE], totalval, currentframetime;
  int framecount;

  // Misc
  SoType cameratype;
  SbBool cursoron, localsetbuffertype;
  SoCallbackList * interactionstartCallbacks, * interactionendCallbacks;
  int interactionnesting;
  So@Gui@Viewer::BufferType buffertype;
  SbBool stereoviewing;
  float stereooffset;

  So@Gui@Viewer * pub;
};

So@Gui@ViewerP::So@Gui@ViewerP(
  So@Gui@Viewer * publ )
{
  this->pub = publ;
} // So@Gui@ViewerP()

So@Gui@ViewerP::~So@Gui@ViewerP(
  void )
{
}

#define THIS (this->pimpl)

// *************************************************************************

SO@GUI@_OBJECT_ABSTRACT_SOURCE(So@Gui@Viewer);

// *************************************************************************

/*!
  \enum So@Gui@Viewer::Type
  FIXME: write documentation for enum
*/
/*!
  \var So@Gui@Viewer::Type So@Gui@Viewer::BROWSER
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::Type So@Gui@Viewer::EDITOR
  FIXME: write documentation for enum definition
*/

/*!
  \enum So@Gui@Viewer::DecimationStrategy
  FIXME: write documentation for enum
*/
/*!
  \var So@Gui@Viewer::DecimationStrategy So@Gui@Viewer::NORMAL
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DecimationStrategy So@Gui@Viewer::FIXED_NUM_TRIANGLES
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DecimationStrategy So@Gui@Viewer::FRAMES_PER_SECOND
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DecimationStrategy So@Gui@Viewer::FIXED_PERCENTAGE
  FIXME: write documentation for enum definition
*/

/*!
  \enum So@Gui@Viewer::DrawStyle
  FIXME: write documentation for enum
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_AS_IS
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_HIDDEN_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_NO_TEXTURE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_LOW_COMPLEXITY
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_POINT
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_BBOX
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_LOW_RES_LINE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_LOW_RES_POINT
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawStyle So@Gui@Viewer::VIEW_SAME_AS_STILL
  FIXME: write documentation for enum definition
*/

/*!
  \enum So@Gui@Viewer::DrawType
  FIXME: write documentation for enum
*/
/*!
  \var So@Gui@Viewer::DrawType So@Gui@Viewer::STILL
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::DrawType So@Gui@Viewer::INTERACTIVE
  FIXME: write documentation for enum definition
*/

/*!
  \enum So@Gui@Viewer::BufferType
  FIXME: write documentation for enum
*/
/*!
  \var So@Gui@Viewer::BufferType So@Gui@Viewer::BUFFER_SINGLE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::BufferType So@Gui@Viewer::BUFFER_DOUBLE
  FIXME: write documentation for enum definition
*/
/*!
  \var So@Gui@Viewer::BufferType So@Gui@Viewer::BUFFER_INTERACTIVE
  FIXME: write documentation for enum definition
*/

/*!
  \var SoCamera * So@Gui@Viewer::camera

  Pointer to the viewer camera.
*/

/*!
  \var So@Gui@Viewer::Type So@Gui@Viewer::type

  The type of the viewer.
*/

/*!
  \var SbBool So@Gui@Viewer::viewingFlag

  Whether the viewer is in view mode or not.
*/

/*!
  \var SoSeparator * So@Gui@Viewer::sceneRoot

  The root of the viewer scene graph.
*/

/*!
  \var SoNode * So@Gui@Viewer::sceneGraph

  The root of the user scene graph.
*/

/*!
  \var SbBool So@Gui@Viewer::altSwitchBack

  Flag on returning from alt in pick mode?
*/

/*!
  \var SoGetBoundingBoxAction So@Gui@Viewer::autoClipBboxAction

  Action for getting the scene bounding box, for setting the clip planes.
*/

/*!
  \var float So@Gui@Viewer::minimumNearPlane

  Percentage of distance to far plane for distance to near plane.
*/

// *************************************************************************

/*!
  \internal

  Return the parent node in the scene graph of the given \a node.
  NB: this is just a quick'n'dirty thing for often executed code,
  and doesn't cover cases where nodes have multiple parents.
*/

static inline SoGroup *
GETPARENTOFNODE(SoNode * root, SoNode * node)
{
  SoSearchAction search;
  assert(node);
  search.setNode(node);
  assert(root);
  search.apply(root);
  assert(search.getPath());
  return (SoGroup *) ((SoFullPath *)search.getPath())->getNodeFromTail(1);
}

// *************************************************************************

/*!
  Constructor. \a parent, \a name and \a embed are passed on
  to So@Gui@RenderArea, so see the documentation for that constructor for
  for more information on those.
*/

So@Gui@Viewer::So@Gui@Viewer(
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  So@Gui@Viewer::Type t,
  SbBool build )
: inherited( parent, name, embed, TRUE, TRUE, FALSE )
{
  THIS = new So@Gui@ViewerP( this );

  // initialization of protected data
  this->type = t;
  this->viewingFlag = TRUE;
  this->camera = NULL;
  this->altSwitchBack = FALSE;
  this->sceneGraph = NULL;

  // initialization of internal data
  THIS->cursoron = TRUE;
  THIS->localsetbuffertype = FALSE;

  THIS->cameratype = SoPerspectiveCamera::getClassTypeId();
  THIS->deletecamera = FALSE;
  THIS->buffertype = this->isDoubleBuffer() ? BUFFER_DOUBLE : BUFFER_SINGLE;

  THIS->interactionstartCallbacks = new SoCallbackList;
  THIS->interactionendCallbacks = new SoCallbackList;
  THIS->interactionnesting = 0;

  THIS->seekdistance = 50.0f;
  THIS->seekdistanceabs = TRUE;
  THIS->seektopoint = TRUE;
  THIS->seekperiod = 2.0f;
  THIS->inseekmode = FALSE;
  THIS->seeksensor = new SoTimerSensor(So@Gui@Viewer::seeksensorCB, this);

  this->sceneRoot = new SoSeparator;
  this->sceneRoot->ref();
  this->sceneRoot->renderCaching.setValue(SoSeparator::OFF);
  this->sceneRoot->renderCulling.setValue(SoSeparator::OFF);

  // Drawstyle subgraph.
  {
    THIS->drawstyleroot = new SoSwitch;

    THIS->solightmodel = new SoLightModel;
    THIS->solightmodel->setOverride(TRUE);
    THIS->solightmodel->model = SoLightModel::BASE_COLOR;

    THIS->sodrawstyle = new SoDrawStyle;
    THIS->sodrawstyle->setOverride(TRUE);
    THIS->sodrawstyle->pointSize.setIgnored(TRUE);
    THIS->sodrawstyle->lineWidth.setIgnored(TRUE);
    THIS->sodrawstyle->linePattern.setIgnored(TRUE);

    THIS->socomplexity = new SoComplexity;
    THIS->socomplexity->setOverride(TRUE);
    THIS->socomplexity->textureQuality = 0.0f;
    THIS->socomplexity->value = 0.1f;

    THIS->drawstyleroot->addChild(THIS->solightmodel);
    THIS->drawstyleroot->addChild(THIS->sodrawstyle);
    THIS->drawstyleroot->addChild(THIS->socomplexity);
    this->sceneRoot->addChild(THIS->drawstyleroot);
    THIS->drawstyleroot->whichChild = SO_SWITCH_NONE;
  }

  // Hidden line rendering subgraph.
  {
    THIS->hiddenlineroot = new SoSwitch;

    THIS->sobasecolor = new SoBaseColor;
    THIS->sobasecolor->setOverride(TRUE);
    THIS->hiddenlineroot->addChild(THIS->sobasecolor);

    THIS->somaterialbinding = new SoMaterialBinding;
    THIS->somaterialbinding->setOverride(TRUE);
    THIS->somaterialbinding->value = SoMaterialBinding::OVERALL;
    THIS->hiddenlineroot->addChild(THIS->somaterialbinding);

    THIS->polygonoffsetparent = new SoSwitch;
    THIS->polygonoffsetparent->whichChild = SO_SWITCH_NONE;
#if HAVE_SOPOLYGONOFFSET
    THIS->sopolygonoffset = new SoPolygonOffset;
    THIS->sopolygonoffset->setOverride(TRUE);
    THIS->polygonoffsetparent->addChild(THIS->sopolygonoffset);
#endif // HAVE_SOPOLYGONOFFSET
    THIS->hiddenlineroot->addChild(THIS->polygonoffsetparent);

    THIS->drawstyleroot->addChild(THIS->hiddenlineroot);
    THIS->hiddenlineroot->whichChild = SO_SWITCH_NONE;
  }


  THIS->drawstyles[STILL] = VIEW_AS_IS;
  THIS->drawstyles[INTERACTIVE] = VIEW_SAME_AS_STILL;

  THIS->lighton = TRUE;
  THIS->lightroot = NULL;

  this->addStartCallback(So@Gui@Viewer::interactivestartCB);
  this->addFinishCallback(So@Gui@Viewer::interactiveendCB);

  THIS->adjustclipplanes = TRUE;
  this->autoClipBboxAction = NULL;

  THIS->stereoviewing = FALSE;
  THIS->stereooffset = 0.1f;

  if ( build ) {
    this->setClassName( "So@Gui@Viewer" );
    @WIDGET@ widget = this->buildWidget( this->getParentWidget() );
    this->setBaseWidget( widget );
  }

  this->resetFrameCounter();
} // So@Gui@Viewer()

// *************************************************************************

/*!
  Destructor.
*/

So@Gui@Viewer::~So@Gui@Viewer(
  void )
{
  delete this->autoClipBboxAction;

  delete THIS->interactionstartCallbacks;
  delete THIS->interactionendCallbacks;

  delete THIS->seeksensor;

  if ( this->sceneGraph ) this->setSceneGraph(NULL);
  if ( THIS->lightroot ) THIS->lightroot->unref();
  this->sceneRoot->unref();

  delete THIS;
} // ~So@Gui@Viewer()

// *************************************************************************

/*!
  Set the camera we want to view the scene with. This will
  set it up with the headlight and register it for later retrieval
  (from getCamera()) and subsequent use.

  \sa getCamera()
*/

void
So@Gui@Viewer::setCamera(SoCamera * cam)
{
  // Store for re-enabling after camera is attached.
  SbBool headlightflag = this->isHeadlight();

  if (this->camera) {
    // Detach headlight.
    if (this->isHeadlight()) this->setHeadlight(FALSE);

    // If we made the camera, detach it. Otherwise just leave it in
    // the graph.
    if (THIS->deletecamera) {
      SoGroup * cameraparent = GETPARENTOFNODE(this->sceneRoot, this->camera);
      cameraparent->removeChild(this->camera);
      THIS->deletecamera = FALSE;
    }

    this->camera->unref();
  }

  this->camera = cam;

  if (this->camera) {
    this->camera->ref();
    this->saveHomePosition();
    if (headlightflag) this->setHeadlight(TRUE);
    THIS->cameratype = this->camera->getTypeId();
  }
  else {
    THIS->lighton = headlightflag;
  }
} // setCamera()

// *************************************************************************

/*!
  Returns the camera currently used by the viewer for rendering
  the scene.

  \sa setCamera()
*/

SoCamera *
So@Gui@Viewer::getCamera(void) const
{
  return this->camera;
} // getCamera()

// *************************************************************************

/*!
  When the viewer has to make its own camera as a result of the graph
  passed to setSceneGraph() not containing any camera nodes, this call
  can be made in advance to decide which type the camera will be of.

  Default is to use an SoPerspectiveCamera.

  If this method is called when there is a scene graph and a camera
  already set up, it will delete the old camera and set up a camera
  with the new type if the \a t type is different from that of the
  current camera.

  \sa getCameraType()
*/

void
So@Gui@Viewer::setCameraType(SoType t)
{
  SoType perspectivetype = SoPerspectiveCamera::getClassTypeId();
  SoType orthotype = SoOrthographicCamera::getClassTypeId();
  SbBool oldisperspective = THIS->cameratype.isDerivedFrom(perspectivetype);
  SbBool newisperspective = t.isDerivedFrom(perspectivetype);

  if ( ( oldisperspective && newisperspective ) ||
       ( !oldisperspective && !newisperspective ) ) // Same old, same old..
    return;

#if SO@GUI@_DEBUG
  SbBool valid = TRUE;
  if (t == SoType::badType()) valid = FALSE;
  if (valid) {
    valid = FALSE;
    if ( newisperspective ) valid = TRUE;
    if ( t.isDerivedFrom( orthotype ) ) valid = TRUE;
  }

  if (!valid) {
    SoDebugError::post("So@Gui@Viewer::setCameraType",
                       "not a valid camera type: '%s'",
                       t == SoType::badType() ?
                       "badType" : t.getName().getString());
    return;
  }
#endif // SO@GUI@_DEBUG

  if ( this->camera != NULL ) {
    SoCamera * newcamera = (SoCamera *)t.createInstance();
    newcamera->aspectRatio.setValue( this->camera->aspectRatio.getValue() );
    newcamera->focalDistance.setValue( this->camera->focalDistance.getValue() );
    newcamera->orientation.setValue( this->camera->orientation.getValue() );
    newcamera->position.setValue( this->camera->position.getValue() );
    newcamera->viewportMapping.setValue( this->camera->viewportMapping.getValue() );

    SoPerspectiveCamera * newpcam = NULL, * oldpcam = NULL;
    SoOrthographicCamera * newocam = NULL, * oldocam = NULL;

    float focaldist = this->camera->focalDistance.getValue();

    if ( newisperspective ) {
      newpcam = (SoPerspectiveCamera *)newcamera;
      oldocam = (SoOrthographicCamera *)this->camera;

      if ( focaldist != 0.0f ) // focalDistance==0.0f happens for empty scenes.
        newpcam->heightAngle =
          2.0f * atan( oldocam->height.getValue() / 2.0f / focaldist );
      else
        newpcam->heightAngle = 0.0f;
    } else {
      newocam = (SoOrthographicCamera *)newcamera;
      oldpcam = (SoPerspectiveCamera *)this->camera;
      newocam->height =
        2 * focaldist * tan(oldpcam->heightAngle.getValue() / 2.0f);
    }

    SoGroup * cameraparent = GETPARENTOFNODE(this->sceneRoot, this->camera);
    cameraparent->insertChild( newcamera,
                               cameraparent->findChild( this->camera ) );
    SoCamera * oldcamera = !THIS->deletecamera ? this->camera : NULL;
    this->setCamera( newcamera ); // This will set THIS->cameratype.
    THIS->deletecamera = TRUE;
    if ( oldcamera )
      cameraparent->removeChild( oldcamera );
  } else { // A camera has not been instantiated for the scene.
    THIS->cameratype = t; // No call to setCamera(), so set type explicitly.
  }
} // setCameraType()

// *************************************************************************

/*!
  Returns camera type which will be used when the viewer has to make its
  own camera.

  Note that this call does \e not return the current cameratype, as one
  might expect. Use getCamera() and SoType::getTypeId() for that inquiry.

  \sa setCameraType()
*/

SoType
So@Gui@Viewer::getCameraType(void) const
{
  return THIS->cameratype;
} // getCameraType()

// *************************************************************************

/*!
  Reposition the current camera so we can see the complete scene.
*/

void
So@Gui@Viewer::viewAll(void)
{
  if ( this->camera && this->sceneGraph )
    this->camera->viewAll( this->sceneGraph, this->getViewportRegion() );
} // viewAll()

// *************************************************************************

/*!
  Store the current camera settings for later retrieval with
  resetToHomePosition().

  \sa resetToHomePosition()
*/

void
So@Gui@Viewer::saveHomePosition(void)
{
  if ( ! this->camera ) return; // probably a scene-less viewer

  THIS->storedorientation = this->camera->orientation.getValue();
  THIS->storedposition = this->camera->position.getValue();

  SoType t = this->camera->getTypeId();
  if (t.isDerivedFrom(SoOrthographicCamera::getClassTypeId())) {
    THIS->storedheightval =
      ((SoOrthographicCamera *)this->camera)->height.getValue();
  }
  else if (t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId())) {
    THIS->storedheightval =
      ((SoPerspectiveCamera *)this->camera)->heightAngle.getValue();
  }
} // saveHomePosition()

// *************************************************************************

/*!
  Restore the saved camera settings.

  \sa saveHomePosition()
*/

void
So@Gui@Viewer::resetToHomePosition(void)
{
  if ( ! this->camera ) return; // probably a scene-less viewer

  this->camera->orientation = THIS->storedorientation;
  this->camera->position = THIS->storedposition;

  SoType t = this->camera->getTypeId();
  if (t.isDerivedFrom(SoOrthographicCamera::getClassTypeId()))
    ((SoOrthographicCamera *)this->camera)->height = THIS->storedheightval;
  else if (t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId()))
    ((SoPerspectiveCamera *)this->camera)->heightAngle = THIS->storedheightval;

  this->setClippingPlanes();
  this->camera->focalDistance =
    (this->camera->farDistance.getValue() +
     this->camera->nearDistance.getValue())/2;
} // resetToHomePosition()

// *************************************************************************

/*!
  Turn the camera headlight on or off.

  Default is to have a headlight turned on.

  \sa isHeadlight(), getHeadlight()
*/

void
So@Gui@Viewer::setHeadlight(SbBool on)
{
  SoSearchAction search;

  if (on) {
    if (!THIS->lightroot) {
      THIS->lightroot = new SoTransformSeparator;
      THIS->lightroot->ref(); // Matched by an unref() in the destructor.
      THIS->lightroot->addChild(new SoRotation);
      SoDirectionalLight * dl = new SoDirectionalLight;
      dl->direction.setValue(1, -1, -10);
      THIS->lightroot->addChild(dl);
    }

    if (!this->camera) { // Headlight flag set early -- just store and return.
      THIS->lighton = on;
      return;
    }

    SoGroup * cameraparent = GETPARENTOFNODE(this->sceneRoot, this->camera);
    int lidx = cameraparent->findChild(THIS->lightroot);
    if (lidx == -1) {
      int idx = cameraparent->findChild(this->camera);
      cameraparent->insertChild(THIS->lightroot, idx+1);

      SoRotation * lorient = (SoRotation *) THIS->lightroot->getChild(0);
      lorient->rotation.connectFrom(& this->camera->orientation);
    }
  }
  else {
    if (THIS->lightroot) {
      SoGroup * lightparent = GETPARENTOFNODE(this->sceneRoot,
                                              THIS->lightroot);
      lightparent->removeChild(THIS->lightroot);

      SoRotation * lorient = (SoRotation *) THIS->lightroot->getChild(0);
      lorient->rotation.disconnect();
    }
  }

  THIS->lighton = on;
} // setHeadlight()

// *************************************************************************

/*!
  Returns status of the viewer headlight, whether it is on or off.

  Note that the returned flag does not check the state of the \a on
  field of the SoDirectionalLight headlight node, it only indicates
  whether or not a headlight is part of the scene graph.

  \sa setHeadlight(), getHeadlight()
*/

SbBool
So@Gui@Viewer::isHeadlight(void) const
{
  return THIS->lighton;
} // isheadlight()

// *************************************************************************

/*!
  Returns the a pointer to the directional light node which is the
  viewer headlight.

  The fields of the node is available for user editing.

  \sa isHeadlight(), setHeadlight()
*/

SoDirectionalLight *
So@Gui@Viewer::getHeadlight(void) const
{
  if (!THIS->lightroot) return NULL;

  SoDirectionalLight * dl =
    (SoDirectionalLight *) THIS->lightroot->getChild(1);
  assert(dl->isOfType(SoDirectionalLight::getClassTypeId()));
  return dl;
} // getHeadlight()

// *************************************************************************

/*!
  Set up a drawing style. The \a type argument specifies if the given
  \a style should be interpreted as the drawstyle during animation or
  when the camera is static.

  Default values for the drawing style is to render the scene "as is"
  in both still mode and while the camera is moving.

  See the documentation for the \a DrawType and \a DrawStyle for more
  information.

  \sa getDrawStyle()
*/

void
So@Gui@Viewer::setDrawStyle(So@Gui@Viewer::DrawType type,
                         So@Gui@Viewer::DrawStyle style)
{
#if SO@GUI@_DEBUG
  if ((type != STILL) && (type != INTERACTIVE)) {
    SoDebugError::postWarning("So@Gui@Viewer::setDrawStyle",
                              "unknown drawstyle type setting 0x%x", type);
    return;
  }
#endif // SO@GUI@_DEBUG

  if (style == this->getDrawStyle(type)) {
#if 0 // SO@GUI@_DEBUG
    SoDebugError::postWarning("So@Gui@Viewer::setDrawStyle",
                              "drawstyle for type 0x%02x already 0x%02x",
                              type, style);
#endif // SO@GUI@_DEBUG
    return;
  }

  THIS->drawstyles[type] = style;
  this->changeDrawStyle(this->currentDrawStyle());
} // setDrawStyle()

// *************************************************************************

/*!
  Return current drawstyles for the given type (\a STILL or
  \a INTERACTIVE).

  \sa setDrawStyle()
*/

So@Gui@Viewer::DrawStyle
So@Gui@Viewer::getDrawStyle(const So@Gui@Viewer::DrawType type) const
{
#if SO@GUI@_DEBUG
  if ((type != STILL) && (type != INTERACTIVE)) {
    SoDebugError::postWarning("So@Gui@Viewer::setDrawStyle",
                              "unknown drawstyle type setting 0x%x", type);
    return THIS->drawstyles[STILL];
  }
#endif // SO@GUI@_DEBUG
  return THIS->drawstyles[type];
} // getDrawStyle()

// *************************************************************************

/*!
  Set the viewer's buffer type. Available types are \c
  So@Gui@Viewer::BUFFER_SINGLE, \c So@Gui@Viewer::BUFFER_DOUBLE and \c
  So@Gui@Viewer::BUFFER_INTERACTIVE.

  (With a buffer type of \c So@Gui@Viewer::BUFFER_INTERACTIVE, the
  viewer will render with doublebuffering during user interaction and
  with single buffering otherwise.)

  Default is \c So@Gui@Viewer::BUFFER_DOUBLE.

  \sa getBufferingType()
*/

void
So@Gui@Viewer::setBufferingType(So@Gui@Viewer::BufferType type)
{
  if (type == THIS->buffertype) return;

  if (type != BUFFER_SINGLE &&
      type != BUFFER_DOUBLE &&
      type != BUFFER_INTERACTIVE) {
#if SO@GUI@_DEBUG
    SoDebugError::postWarning("So@Gui@Viewer::setBufferingType",
                              "unknown buffer type 0x%x", type);
#endif // SO@GUI@_DEBUG
    return;
  }

  THIS->buffertype = type;

  THIS->localsetbuffertype = TRUE;
  inherited::setDoubleBuffer(type == BUFFER_DOUBLE);
  THIS->localsetbuffertype = FALSE;
} // setBufferingType()

// *************************************************************************

/*!
  Return the viewer's buffer type.

  \sa setBufferingType()
*/

So@Gui@Viewer::BufferType
So@Gui@Viewer::getBufferingType(void) const
{
  return THIS->buffertype;
} // getBufferingType()

// *************************************************************************

/*!
  Set view mode.

  If the view mode is on, user events will be caught and used to
  influence the camera position/orientation. If view mode is off,
  all events in the viewer canvas will be passed along to the scene
  graph.

  Default is to have the view mode active.

  \sa getViewing()
*/

void
So@Gui@Viewer::setViewing(
  SbBool enable )
{
  if ( this->viewingFlag == enable ) {
#if SO@GUI@_DEBUG
    SoDebugError::postWarning( "So@Gui@Viewer::setViewing",
      "unnecessary called" );
#endif // SO@GUI@_DEBUG
    return;
  }

  this->viewingFlag = enable;

  // Turn off the selection indicators when we go back from picking
  // mode into viewing mode.
  if ( this->viewingFlag ) {
    SoGLRenderAction * action = this->getGLRenderAction();
    if ( action != NULL )
      SoLocateHighlight::turnOffCurrentHighlight( action );
  }
} // setViewing()

// *************************************************************************

/*!
  Return state of view mode.

  \sa setViewing()
*/

SbBool
So@Gui@Viewer::isViewing(void) const
{
  return this->viewingFlag;
} // isViewing()

// *************************************************************************

/*!
  Set whether or not the mouse cursor representation should be visible
  in the viewer canvas.

  Default value is on.

  \sa getCursorEnabled()
*/

void
So@Gui@Viewer::setCursorEnabled(SbBool on)
{
  THIS->cursoron = on;
} // setCursorEnabled()

// *************************************************************************

/*!
  Returns visibility status of mouse cursor.

  \sa setCursorEnabled()
*/

SbBool
So@Gui@Viewer::isCursorEnabled(void) const
{
  return THIS->cursoron;
} // isCursorEnabled()

// *************************************************************************

/*!
  Turn on or off continuous automatic adjustments of the near
  and far clipping planes.

  Automatic clipping is on as default.

  \sa getAutoClipping()
*/

void
So@Gui@Viewer::setAutoClipping(
  SbBool enable )
{
#if SO@GUI@_DEBUG
  if ( THIS->adjustclipplanes == enable ) {
    SoDebugError::postWarning("So@Gui@Viewer::setAutoClipping",
                              "unnecessary called");
    return;
  }
#endif // SO@GUI@_DEBUG
  THIS->adjustclipplanes = enable;
  if ( enable ) this->scheduleRedraw();
} // setAutoClipping()

// *************************************************************************

/*!
  Return value of the automatic near/far clipplane adjustment indicator.

  \sa setAutoClipping()
*/

SbBool
So@Gui@Viewer::isAutoClipping(
  void ) const
{
  return THIS->adjustclipplanes;
} // isAutoClipping()

// *************************************************************************

/*!
  Turn stereo viewing on or off.

  \sa isStereoViewing()
*/

void
So@Gui@Viewer::setStereoViewing( // virtual
  SbBool enable )
{
  THIS->stereoviewing = enable;
  this->scheduleRedraw();
} // setStereoViewing()

// *************************************************************************

/*!
  Returns a boolean indicating whether or not we're in stereo viewing
  mode.

  NOTE: in the original InventorXt API, this method was virtual.  It is not
  virtual here.

  \sa setStereoViewing()
*/

SbBool
So@Gui@Viewer::isStereoViewing(
  void ) const
{
  return THIS->stereoviewing;
} // setStereoViewing()

// *************************************************************************

/*!
  Set the offset between the two viewpoints when in stereo mode.

  NOTE: In the original InventorXt API, this method was not virtual.

  \sa getStereoOffset()
*/

void
So@Gui@Viewer::setStereoOffset( // virtual
  const float dist )
{
  THIS->stereooffset = dist;
  this->scheduleRedraw();
} // setStereoOffset()

/*!
  Return the offset distance between the two viewpoints when in stereo mode.

  \sa setStereoOffset()
*/

float
So@Gui@Viewer::getStereoOffset(
  void ) const
{
  return THIS->stereooffset;
} // getStereoOffset()

// *************************************************************************

/*!
  Toggle between seeking to a point or seeking to an object.

  Default is to seek to a point.

  \sa isDetailSeek()
*/

void
So@Gui@Viewer::setDetailSeek(const SbBool on)
{
#if SO@GUI@_DEBUG
  if (THIS->seektopoint == on) {
    SoDebugError::postWarning("So@Gui@Viewer::setDetailSeek",
                              "unnecessary called");
    return;
  }
#endif // SO@GUI@_DEBUG
  THIS->seektopoint = on;
} // setDetailSeek()

// *************************************************************************

/*!
  Returns a value indicating whether or not seeks will be performed
  to the exact point of picking or just towards the picked object.

  \sa setDetailSeek()
*/

SbBool
So@Gui@Viewer::isDetailSeek(void) const
{
  return THIS->seektopoint;
} // isDetailSeek()

// *************************************************************************

/*!
  Set the duration of animating the camera repositioning
  after a successful seek. Call with \a seconds equal to \a 0.0 to make
  the camera jump immediately to the correct spot.

  Default value is 2 seconds.

  \sa getSeekTime()
*/

void
So@Gui@Viewer::setSeekTime(const float seconds)
{
#if SO@GUI@_DEBUG
  if (seconds < 0.0f) {
    SoDebugError::postWarning("So@Gui@Viewer::setSeekTime",
                              "an attempt was made to set a negative seek "
                              "time duration");
    return;
  }
#endif // SO@GUI@_DEBUG
  THIS->seekperiod = seconds;
} // setSeekTime()

// *************************************************************************

/*!
  Returns the camera repositioning duration following a seek action.

  \sa setSeekTime()
*/

float
So@Gui@Viewer::getSeekTime(void) const
{
  return THIS->seekperiod;
} // getSeekTime()

// *************************************************************************

/*!
  Add a function to call when user interaction with the scene starts.

  \sa removeStartCallback(), addFinishCallback()
*/

void
So@Gui@Viewer::addStartCallback(So@Gui@ViewerCB * func, void * data)
{
  THIS->interactionstartCallbacks->addCallback((SoCallbackListCB *)func, data);
} // addStartCallback()

/*!
  Remove one of the functions which has been set up to be called when user
  interaction with the scene starts.

  \sa addStartCallback(), removeFinishCallback()
*/

void
So@Gui@Viewer::removeStartCallback(So@Gui@ViewerCB * func, void * data)
{
  THIS->interactionstartCallbacks->removeCallback((SoCallbackListCB *)func,
                                                  data);
} // removeStartCallback()

// *************************************************************************

/*!
  Add a function to call when user interaction with the scene ends.

  \sa removeFinishCallback(), addStartCallback()
*/

void
So@Gui@Viewer::addFinishCallback(So@Gui@ViewerCB * func, void * data)
{
  THIS->interactionendCallbacks->addCallback((SoCallbackListCB *)func, data);
} // addFinishCallback()

/*!
  Remove one of the functions which has been set up to be called when user
  interaction with the scene ends.

  \sa addFinishCallback(), removeStartCallback()
*/

void
So@Gui@Viewer::removeFinishCallback(So@Gui@ViewerCB * func, void * data)
{
  THIS->interactionendCallbacks->removeCallback((SoCallbackListCB *)func,
                                                data);
} // removeFinishCallback()

// *************************************************************************

/*!
  Copy the current camera to the system clipboard. This makes it
  easy to synchronize camera settings over different applications.

  Note: has not been implemented yet.

  \sa pasteView()
*/

void
So@Gui@Viewer::copyView(const SbTime /*eventTime*/)
{
  // FIXME: not implemented. Needs So@Gui@Clipboard implementation
  // first. 19990507 mortene.

  SoDebugError::postInfo("So@Gui@Viewer::copyView",
                         "clipboard support not implemented yet");
} // copyView()

// *************************************************************************

/*!
  Set a new camera from the system clipboard.

  Note: has not been implemented yet.

  \sa copyView()
*/

void
So@Gui@Viewer::pasteView(const SbTime /*eventTime*/)
{
  // FIXME: not implemented. Needs So@Gui@Clipboard implementation
  // first. 19990507 mortene.

  SoDebugError::postInfo("So@Gui@Viewer::pasteView",
                         "clipboard support not implemented yet");
} // pasteView()

// *************************************************************************

/*!
  Not used, only included for compatibility reasons.
*/

void
So@Gui@Viewer::recomputeSceneSize(
  void )
{
  SoDebugError::postInfo("So@Gui@Viewer::recomputeSceneSize",
                         "this method is obsoleted, don't use it");
} // recomputeSceneSize()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setDecimationStrategy(const So@Gui@Viewer::DecimationStrategy /*strategy*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setDecimationStrategy",
                         _( "not implemented yet" ));
} // setDecimationStrategy()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

So@Gui@Viewer::DecimationStrategy
So@Gui@Viewer::getDecimationStrategy(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getDecimationStrategy",
                         _( "not implemented yet" ));
  return NORMAL;
}

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setGoalNumberOfTriangles(const int32_t /*goal*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setGoalNumberOfTriangles",
                         _( "not implemented yet" ));
} // setGoalNumberOfTriangles()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

int32_t
So@Gui@Viewer::getGoalNumberOfTriangles(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getGoalNumberOfTriangles",
                         _( "not implemented yet" ));
  return -1;
} // getGoalNumberOfTriangles()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setGoalFramesPerSecond(const float /*goal*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setGoalFramesPerSecond",
                         _( "not implemented yet" ));
} // setGoalFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
So@Gui@Viewer::getGoalFramesPerSecond(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getGoalFramesPerSecond",
                         _( "not implemented yet" ));
  return 72.0f;
} // getGoalFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setFixedPercentage(const float /*percent*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setFixedPercentage",
                         _( "not implemented yet" ));
} // setFixedPercentage()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
So@Gui@Viewer::getFixedPercentage(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getFixedPercentage",
                         _( "not implemented yet" ));
  return 100.0f;
} // getFixedPercentage()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::enableFullRenderingWhenStill(const SbBool /*on*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::enableFullRenderingWhenStill",
                         _( "not implemented yet" ));
} // enableFullRendering()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

SbBool
So@Gui@Viewer::isFullRenderingWhenStill(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::isFullRenderingWhenStill",
                         _( "not implemented yet" ));
  return TRUE;
} // isFullRendering()

/*!
  Large Model Visualization; not implemented yet.
*/

SbBool
So@Gui@Viewer::isStillNow(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::isStillNow",
                         _( "not implemented yet" ));
  return this->getInteractiveCount() == 0;
} // isStillNow()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setFramesPerSecondCallback(So@Gui@ViewerFPSCB * /*callback*/, void * /*data*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setFramesPerSecondCallback",
                         _( "not implemented yet" ));
} // setFramesPerSecond()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setNumSamples(const int /*numFrames*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setNumSamples",
                         _( "not implemented yet" ));
} // setNumSamples()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

int
So@Gui@Viewer::getNumSamples(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getNumSamples",
                         _( "not implemented yet" ));
  return 10;
} // getNumSamples()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

void
So@Gui@Viewer::setDecimationPercentageCallback(So@Gui@ViewerDecimationPercentageCB * /*cb*/, void * /*data*/)
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::setDecimationPercentageCallback",
                         _( "not implemented yet" ));
} // setDecimationPercentageCallback()

// *************************************************************************

/*!
  Large Model Visualization; not implemented yet.
*/

float
So@Gui@Viewer::getCurrentDecimationPercentage(void) const
{
  // FIXME: implement. 19990508 mortene.
  SoDebugError::postInfo("So@Gui@Viewer::getCurrentDecimationPercentage",
                         _( "not implemented yet" ));
  return 100.0f;
} // getCurrentDecimateionPercentage()

// *************************************************************************

/*!
  Overloaded to update the local bufferingtype variable.

  \sa setBufferingType(), getBufferingType()
*/

void
So@Gui@Viewer::setDoubleBuffer(SbBool on)
{
  if (!THIS->localsetbuffertype)
    THIS->buffertype = on ? BUFFER_DOUBLE : BUFFER_SINGLE;

  inherited::setDoubleBuffer(on);
} // setDoubleBuffer()

// *************************************************************************

/*!
  Give the viewer a scenegraph to render and interact with. Overloaded
  from parent class so the viewer can add it's own nodes to control
  rendering in different styles, rendering with a headlight, etc.

  The \a root node will be inserted under the \e viewer's root node,
  which also covers the nodes necessary to implement the different
  preferences drawing style settings.

  If no camera is part of the scene graph under \a root, one will be
  added automatically.

  \sa getSceneGraph(), setCameraType()
*/

void
So@Gui@Viewer::setSceneGraph(SoNode * root)
{
  if ( root == this->sceneGraph ) {
#if SO@GUI@_DEBUG
    SoDebugError::postWarning( "So@Gui@Viewer::setSceneGraph",
      "called with the same root as already set" );
#endif // SO@GUI@_DEBUG
    return;
  }

  // If the SoRenderArea hasn't yet set up its pointer to the SoViewer
  // "viewer root" (i.e. the viewer-generated root above the
  // user-supplied root), do that first.
  if (!inherited::getSceneGraph()) inherited::setSceneGraph(this->sceneRoot);

  if ( this->sceneGraph ) {
    if (this->getCamera())
      this->setCamera(NULL);
    // Release the old user-supplied graph.
    this->sceneRoot->removeChild(this->sceneGraph);
  }

  this->sceneGraph = root;
  if (!root) return;

  this->sceneRoot->addChild(this->sceneGraph);

  // Search for a camera already present.
  SoSearchAction search;
  search.setType(SoCamera::getClassTypeId());
  search.apply(this->sceneGraph);
  SoCamera * scenecamera = NULL;
  SoFullPath * fullpath = (SoFullPath *)search.getPath();
  if (fullpath) scenecamera = (SoCamera *)fullpath->getTail();

#if 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::setSceneGraph",
                         "camera %sfound in graph",
                         scenecamera ? "" : "not ");
#endif // debug

  // Make our own camera if none was available.
  if (!scenecamera) {
    scenecamera = (SoCamera *)THIS->cameratype.createInstance();
    THIS->deletecamera = TRUE;

    if ( this->type == So@Gui@Viewer::BROWSER ) {
      this->sceneRoot->insertChild(scenecamera, 1);
    }
    else {
      if (this->sceneGraph->isOfType(SoGroup::getClassTypeId())) {
        ((SoGroup *)this->sceneGraph)->insertChild(scenecamera, 0);
      }
      else {
        SoGroup * g = new SoGroup;
        g->addChild(scenecamera);
        g->addChild(this->sceneGraph);
        this->sceneRoot->removeChild(this->sceneGraph);
        this->sceneRoot->addChild(g);
        this->sceneGraph = g;
      }
    }

    scenecamera->viewAll(this->sceneGraph, this->getViewportRegion());
  }

  // This will set up the headlight
  this->setCamera(scenecamera);
} // setSceneGraph()

// *************************************************************************

/*!
  Overloaded from parent class to return the root of the scene graph
  set by the user, without the extras added by the viewer to control
  rendering.

  \sa setSceneGraph()
*/

SoNode *
So@Gui@Viewer::getSceneGraph(void)
{
  return this->sceneGraph;
} // getSceneGraph()

// *************************************************************************

/*!
  Put the viewer in or out of seek mode.

  If the user performs a mouse button click when the viewer is in seek
  mode, the camera will be repositioned so the camera focal point lies
  on the point of the geometry under the mouse cursor.

  \sa isSeekMode(), setDetailSeek()
*/

void
So@Gui@Viewer::setSeekMode(
  SbBool enable )
{
#if SO@GUI@_DEBUG
  // user might have switched mode during seek, so if enable == FALSE,
  // isViewing() is irrelevant.
  if ( enable )
    assert( this->isViewing() );
#endif // SO@GUI@_DEBUG

  if ( ! enable && THIS->seeksensor->isScheduled() ) {
    THIS->seeksensor->unschedule();
    this->interactiveCountDec();
  }

  THIS->inseekmode = enable;
} // setSeekMode()

// *************************************************************************

/*!
  Return a flag which indicates whether or not the viewer is in seek mode.

  \sa setSeekMode()
*/

SbBool
So@Gui@Viewer::isSeekMode(void) const
{
  return THIS->inseekmode;
} // isSeekMode()

// *************************************************************************

/*!
  Call this method to initiate a seek action towards the 3D intersection
  of the scene and the ray from the screen coordinate's point and in the same
  direction as the camera is pointing.

  Returns \a TRUE if the ray from the \a screenpos position intersect with
  any parts of the onscreen geometry, otherwise FALSE.
*/

SbBool
So@Gui@Viewer::seekToPoint( const SbVec2s screenpos )
{
  if ( ! this->camera )
    return FALSE;

  SoRayPickAction rpaction(this->getViewportRegion());
  rpaction.setPoint(screenpos);
  rpaction.setRadius(2);
  rpaction.apply(this->sceneRoot);

  SoPickedPoint * picked = rpaction.getPickedPoint();
  if (!picked) {
//    this->setSeekMode(FALSE);
    return FALSE;
  }
//  this->setSeekMode(TRUE);

  SbVec3f hitpoint;
  if (THIS->seektopoint) {
    hitpoint = picked->getPoint();
  } else {
    SoGetBoundingBoxAction bbaction(this->getViewportRegion());
    bbaction.apply(picked->getPath());
    SbBox3f bbox = bbaction.getBoundingBox();
    hitpoint = bbox.getCenter();
  }

  THIS->camerastartposition = this->camera->position.getValue();

  float fd = THIS->seekdistance;
  if (THIS->seekdistanceabs)
    fd *= (hitpoint - this->camera->position.getValue()).length()/100.0f;
  this->camera->focalDistance = fd;

  SbVec3f dir;
  this->camera->orientation.getValue().multVec(SbVec3f(0, 0, -1), dir);
  THIS->cameraendposition = hitpoint - fd * dir;

  if (THIS->seeksensor->isScheduled()) {
    THIS->seeksensor->unschedule();
    this->interactiveCountDec();
  }

  THIS->seeksensor->setBaseTime(SbTime::getTimeOfDay());
  THIS->seeksensor->schedule();
  this->interactiveCountInc();

  return TRUE;
} // seeekToPoint()

// *************************************************************************


void 
So@Gui@Viewer::reallyRedraw(const SbBool clearcol, const SbBool clearz)
{
  if ( this->drawAsHiddenLine() ) {

    // First pass: render as filled, but with the background color.

    THIS->solightmodel->model.setIgnored(FALSE); // override as SoLightModel::BASE
    THIS->sodrawstyle->style.setIgnored(TRUE); // draw as-is filled/lines/points
    THIS->socomplexity->type.setIgnored(TRUE); // as-is rendering space
    THIS->socomplexity->value.setIgnored(TRUE); // as-is complexity on non-simple shapes
    // textureQuality field of socomplexity node is always 0.0

    THIS->sobasecolor->rgb.setValue(this->getBackgroundColor());
    THIS->sobasecolor->rgb.setIgnored(FALSE);
    THIS->somaterialbinding->value.setIgnored(FALSE); // override with OVERALL
    THIS->polygonoffsetparent->whichChild = SO_SWITCH_ALL;

    this->getSceneManager()->render(clearcol, clearz);


    // Second pass, render wireframe on top.

    THIS->sodrawstyle->style = SoDrawStyle::LINES;
    THIS->sodrawstyle->style.setIgnored(FALSE); // force lines
    THIS->sobasecolor->rgb.setIgnored(TRUE); // use as-is line colors
    THIS->somaterialbinding->value.setIgnored(TRUE); // as-is
    THIS->polygonoffsetparent->whichChild = SO_SWITCH_NONE;
    
    this->getSceneManager()->render(FALSE, FALSE);

    return;
  }


  SbBool clearzbuffer = TRUE;
  DrawStyle style = this->currentDrawStyle();
  switch (style) {
  case VIEW_LOW_RES_LINE:
  case VIEW_LOW_RES_POINT:
  case VIEW_BBOX:
    clearzbuffer = FALSE;
  default: break; // Include "default:" case to avoid compiler warning.
  }

  this->getSceneManager()->render(clearcol, clearzbuffer && clearz);
}


/*!
  Overloaded from parent class to be able to do the necessary two-pass
  rendering e.g. if the drawing style is \e hidden \e line.
*/

void
So@Gui@Viewer::actualRedraw(void)
{
  // Recalculate near/far planes.
  if ( this->isAutoClipping() )
    this->setClippingPlanes();

  SbBool clearcol = this->isClearBeforeRender();

  if (this->isStereoViewing()) {
    SbBool quadstereo = this->isQuadBufferStereo();
#ifndef HAVE_SOCAMERA_SETSTEREOMODE
    SoCamera * camera = this->getCamera();  
    SbVec3f camerapos = camera->position.getValue();
    SbVec3f cameradir(0.0f, 0.0f, -1.0f);
    SbVec3f offsetvec(1.0f, 0.0f, 0.0f);
    float offset = this->getStereoOffset() * 0.5f;
    SbRotation camerarot = camera->orientation.getValue();
    camerarot.multVec(cameradir, cameradir);
    camerarot.multVec(offsetvec, offsetvec);
    SbVec3f focalpoint = camerapos + cameradir * camera->focalDistance.getValue();

    SbBool notifystore = camera->isNotifyEnabled();
    SbBool positionstore = camera->position.isNotifyEnabled();
    SbBool orientationstore = camera->orientation.isNotifyEnabled();
    // turn off notification to avoid redraws
    camera->enableNotify(FALSE);
    camera->position.enableNotify(FALSE);
    camera->orientation.enableNotify(FALSE);

    camera->position = camerapos - offsetvec * offset;
    SbVec3f dir = focalpoint - camera->position.getValue();
    SbRotation rot(cameradir, dir);
    camera->orientation = camerarot * rot;
    if (quadstereo) {
      glDrawBuffer(GL_BACK_LEFT);
      this->reallyRedraw(clearcol);
    }
    else { // red/cyan
      glDrawBuffer(GL_BACK);
      glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
      glColorMask(1,0,0,1); // draw red-only
      this->reallyRedraw(FALSE, FALSE);
    }
    
    // right eye
    camera->position = camerapos + offsetvec * offset;
    dir = focalpoint - camera->position.getValue();
    rot.setValue(cameradir, dir);
    camera->orientation = camerarot * rot;

    if (quadstereo) {
      glDrawBuffer(GL_BACK_RIGHT);
      this->reallyRedraw(clearcol);
    }
    else {
      glColorMask(0,1,1,1); // draw green and blue
      this->reallyRedraw(FALSE, TRUE);
    }
    
    // restore camera values and enable notification
    camera->position = camerapos;
    camera->orientation = camerarot;
    camera->position.enableNotify(positionstore);
    camera->orientation.enableNotify(orientationstore);
    camera->enableNotify(notifystore);
    if (quadstereo) {
      glDrawBuffer(GL_BACK);
    }
    else {
      glColorMask(1,1,1,1); // restore GL color mask
    }
#else // HAVE_SOCAMERA_SETSTEREOMODE

    if (!quadstereo) {
      SoCamera * camera = this->getCamera();  
      glDrawBuffer(GL_BACK);
      glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
      glColorMask(1,0,0,1); // draw red-only
      camera->setStereoAdjustment(this->getStereoOffset());
      camera->setStereoMode(SoCamera::LEFT_VIEW);
      this->reallyRedraw(FALSE, FALSE);
      
      camera->setStereoMode(SoCamera::RIGHT_VIEW);
      glColorMask(0,1,1,1); // draw green and blue
      this->reallyRedraw(FALSE, TRUE);
      camera->setStereoMode(SoCamera::MONOSCOPIC);
      glColorMask(1,1,1,1); // restore GL color mask
    }
    else {
      SoCamera * camera = this->getCamera();  
      glDrawBuffer(GL_BACK_LEFT);
      camera->setStereoAdjustment(this->getStereoOffset());
      camera->setStereoMode(SoCamera::LEFT_VIEW);
      this->reallyRedraw(clearcol);
      camera->setStereoMode(SoCamera::RIGHT_VIEW);
      glDrawBuffer(GL_BACK_RIGHT);
      this->reallyRedraw(clearcol);
      camera->setStereoMode(SoCamera::MONOSCOPIC);
      glDrawBuffer(GL_BACK);
    }
#endif // HAVE_SOCAMERA_SETSTEREOMODE
  }
  else this->reallyRedraw(clearcol);

  if (this->getInteractiveCount() > 0) this->recordFPS();
} // actualRedraw()

// *************************************************************************

/*!
  To be able to trigger callback functions when user interaction starts
  and/or stops, we need to keep track of the viewer state (i.e. are we in
  still mode or in animation mode?).

  So@Gui@Viewer automatically adds callbacks to switch between still and
  moving draw style, and to switch between single/double buffer when
  the buffer type is \a INTERACTIVE.

  \sa interactiveCountDec(), getInteractiveCount()
  \sa addStartCallback(), addFinishCallback()
  \sa removeStartCallback(), removeFinishCallback()
  \sa setDrawStyle(), setBufferingType()
*/

void
So@Gui@Viewer::interactiveCountInc(void)
{
  // Catch problems with missing interactiveCountDec() calls.
  assert(THIS->interactionnesting < 100);

  if (++(THIS->interactionnesting) == 1)
    THIS->interactionstartCallbacks->invokeCallbacks(this);

#if 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::interactiveCountInc", "%d -> %d",
                         THIS->interactionnesting - 1,
                         THIS->interactionnesting);
#endif // debug
} // interactiveCountInc()

// *************************************************************************

/*!
  To be able to trigger callback functions when user interaction starts
  and/or stops, we need to keep track of the viewer state (i.e. are we in
  still mode or in animation mode?).

  So@Gui@Viewer automatically adds callbacks to switch between still and
  moving draw style, and to switch between single/double buffer when
  the buffer type is \a INTERACTIVE.

  \sa interactiveCountInc(), getInteractiveCount()
  \sa addStartCallback(), addFinishCallback()
  \sa removeStartCallback(), removeFinishCallback()
  \sa setDrawStyle(), setBufferingType()
*/

void
So@Gui@Viewer::interactiveCountDec(void)
{
#if SO@GUI@_DEBUG
  if (THIS->interactionnesting <= 0) {
    SoDebugError::postWarning("So@Gui@Viewer::interactiveCountDec",
        "interaction count nesting went below zero" );
  }
#endif // SO@GUI@_DEBUG

  if (--(THIS->interactionnesting) <= 0) {
    THIS->interactionendCallbacks->invokeCallbacks(this);
    THIS->interactionnesting = 0;
    this->resetFrameCounter();
  }
} // interactiveCountDec()

// *************************************************************************

/*!
  Return current interaction count nesting. If equal to zero, the viewer
  is in animation mode, otherwise the camera is still.

  \sa interactiveCountInc(), interactiveCountDec()
*/

int
So@Gui@Viewer::getInteractiveCount(void) const
{
  return THIS->interactionnesting;
} // getInteractiveCount()

// *************************************************************************

/*!
  Set the value used for calculating how close the camera and intersection
  hit point should be made at the end of a seek operation.

  The value can be interpreted as an absolute value in the given world
  unit (which typically is meters) or as a percentage value of the
  distance between the camera starting position and the intersection
  hit point. This can be controlled through the
  setSeekValueAsPercentage() method. It is as default used as an
  absolute value.

  Default value is 50 (absolute distance or percent).

  \sa getSeekDistance(), setSeekValueAsPercentage(), setSeekTime()
*/

void
So@Gui@Viewer::setSeekDistance(const float distance)
{
#if SO@GUI@_DEBUG
  if (distance <= 0.0f) {
    SoDebugError::postWarning("So@Gui@Viewer::setSeekDistance",
                              "invalid seek distance value: %f",
                              distance);
    return;
  }
#endif // SO@GUI@_DEBUG
  THIS->seekdistance = distance;
} // setSeekDistance()

// *************************************************************************

/*!
  Returns the current seek distance. Value given as an absolute scalar
  length or as a percentage value of the original distance between
  the hitpoint and the camera starting position.

  \sa setSeekDistance(), isSeekValueAsPercentage()
*/

float
So@Gui@Viewer::getSeekDistance(void) const
{
  return THIS->seekdistance;
} // getSeekDistance()

// *************************************************************************

/*!
  Control whether or not the seek distance value should be interpreted as
  a percentage value or as an absolute distance. See documentation on
  setSeekDistance() for more information.

  \sa setSeekDistance(), isSeekValueAsPercentage()
*/

void
So@Gui@Viewer::setSeekValueAsPercentage(const SbBool on)
{
#if SO@GUI@_DEBUG
  if ((on && this->isSeekValuePercentage()) ||
      (!on && !this->isSeekValuePercentage())) {
    SoDebugError::postWarning("So@Gui@Viewer::setSeekDistanceAsPercentage",
                              "unnecessary called, value already %s",
                              on ? "on" : "off");
    return;
  }
#endif // SO@GUI@_DEBUG
  THIS->seekdistanceabs = on ? FALSE : TRUE;
} // setSeekValkueAsPercentage()

// *************************************************************************

/*!
  Returns an boolean which indicates if the seek distance value from
  getSeekDistance() should be interpreted as a percentage value or
  as an absolute value.

  \sa setSeekValuePercentage(), getSeekDistance()
*/

SbBool
So@Gui@Viewer::isSeekValuePercentage(void) const
{
  return THIS->seekdistanceabs ? FALSE : TRUE;
} // isSeekValuePercentage()

// *************************************************************************

/*!
  If the current camera is of perspective type, switch to orthographic,
  and vice versa.
*/

void
So@Gui@Viewer::toggleCameraType(void)
{
  SoType perspectivetype = SoPerspectiveCamera::getClassTypeId();
  SoType orthotype = SoOrthographicCamera::getClassTypeId();

  this->setCameraType( THIS->cameratype.isDerivedFrom( perspectivetype )
                       ? orthotype : perspectivetype );
} // toggleCameraType()

// *************************************************************************

/*!
  \internal

  Returns a boolean to indicate if the dynamic drawstyle equals
  the static drawstyle.
*/

SbBool
So@Gui@Viewer::drawInteractiveAsStill(void) const
{
  SbBool moveasstill = THIS->drawstyles[INTERACTIVE] == VIEW_SAME_AS_STILL;
  if (!moveasstill)
    moveasstill = THIS->drawstyles[INTERACTIVE] == THIS->drawstyles[STILL];
  if (!moveasstill)
    moveasstill =
      THIS->drawstyles[INTERACTIVE] == VIEW_NO_TEXTURE &&
      THIS->drawstyles[STILL] != VIEW_AS_IS;
  return moveasstill;
} // drawInteractiveAsStill()

// *************************************************************************

/*!
  \internal

  Returns the current drawing style.
*/

So@Gui@Viewer::DrawStyle
So@Gui@Viewer::currentDrawStyle(void) const
{
  SbBool interactivemode = this->getInteractiveCount() > 0 ? TRUE : FALSE;

  if (!interactivemode || this->drawInteractiveAsStill())
    return THIS->drawstyles[STILL];
  else
    return THIS->drawstyles[INTERACTIVE];
} // currentDrawStyle()

// *************************************************************************

/*!
  \internal

  Returns a boolean to indicate if the current drawstyle settings implies
  hidden line rendering.
*/

SbBool
So@Gui@Viewer::drawAsHiddenLine(void) const
{
  return ((this->currentDrawStyle() == VIEW_HIDDEN_LINE) ? TRUE : FALSE);
} // drawAsHiddenLine()

// *************************************************************************

/*!
  \internal

  Use the given style setting to set the correct states in the
  rendering control nodes. This will affect the way the scene is
  currently rendered.
*/

void
So@Gui@Viewer::changeDrawStyle(So@Gui@Viewer::DrawStyle style)
{
  // Turn on/off Z-buffering based on the style setting.
  switch (style) {
  case VIEW_LOW_RES_LINE:
  case VIEW_LOW_RES_POINT:
  case VIEW_BBOX:
    this->glLock();
    // FIXME: shouldn't this be done "lazy", i.e. before we do any
    // actual rendering? 20001126 mortene.
    glDisable(GL_DEPTH_TEST);
    this->glUnlock();
    break;
    
  default:
    this->glLock();
    // FIXME: shouldn't this be done "lazy", i.e. before we do any
    // actual rendering? 20001126 mortene.
    glEnable(GL_DEPTH_TEST);
    this->glUnlock();
    break;
  }

  // Render everything as its supposed to be done, don't override
  // any of the settings in the ``real'' graph.
  if (style == VIEW_AS_IS) {
    THIS->drawstyleroot->whichChild = SO_SWITCH_NONE;
    return;
  }

  THIS->drawstyleroot->whichChild = SO_SWITCH_ALL;
  if (style == VIEW_HIDDEN_LINE) {
    THIS->hiddenlineroot->whichChild = SO_SWITCH_ALL;
    return;
  }
  else {
    THIS->hiddenlineroot->whichChild = SO_SWITCH_NONE;
  }

  // Set or unset lightmodel override.
  switch (style) {
  case VIEW_NO_TEXTURE:
  case VIEW_LOW_COMPLEXITY:
    THIS->solightmodel->model.setIgnored(TRUE); // as-is BASE or PHONG
    break;

  case VIEW_LINE:
  case VIEW_POINT:
  case VIEW_BBOX:
  case VIEW_LOW_RES_LINE:
  case VIEW_LOW_RES_POINT:
    THIS->solightmodel->model.setIgnored(FALSE); // force BASE lighting
    break;

  default:
    assert(FALSE); break;
  }


  // Set or unset drawstyle override.
  switch (style) {
  case VIEW_NO_TEXTURE:
  case VIEW_LOW_COMPLEXITY:
    THIS->sodrawstyle->style.setIgnored(TRUE); // as-is drawing style filled/lines/points
    break;

  case VIEW_LINE:
  case VIEW_LOW_RES_LINE:
  case VIEW_BBOX:
    THIS->sodrawstyle->style = SoDrawStyle::LINES;
    THIS->sodrawstyle->style.setIgnored(FALSE); // force line rendering
    break;

  case VIEW_POINT:
  case VIEW_LOW_RES_POINT:
    THIS->sodrawstyle->style = SoDrawStyle::POINTS;
    THIS->sodrawstyle->style.setIgnored(FALSE); // force point rendering
    break;

  default:
    assert(FALSE); break;
  }

  // Set or unset complexity value override.
  switch (style) {
  case VIEW_NO_TEXTURE:
  case VIEW_LINE:
  case VIEW_POINT:
  case VIEW_BBOX:
    THIS->socomplexity->value.setIgnored(TRUE); // as-is complexity
    break;

  case VIEW_LOW_COMPLEXITY:
  case VIEW_LOW_RES_LINE:
  case VIEW_LOW_RES_POINT:
    THIS->socomplexity->value.setIgnored(FALSE); // force complexity setting of 0.1
    break;

  default:
    assert(FALSE); break;
  }

  // Set or unset complexity type override.
  switch (style) {
  case VIEW_NO_TEXTURE:
  case VIEW_LOW_COMPLEXITY:
  case VIEW_LINE:
  case VIEW_POINT:
  case VIEW_LOW_RES_LINE:
  case VIEW_LOW_RES_POINT:
    THIS->socomplexity->type.setIgnored(TRUE); // as-is
    break;

  case VIEW_BBOX:
    THIS->socomplexity->type = SoComplexity::BOUNDING_BOX;
    THIS->socomplexity->type.setIgnored(FALSE); // force bounding box rendering
    break;

  default:
    assert(FALSE); break;
  }

#if 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::changeDrawStyle",
                         "\n"
                         "\tdrawstyle style: 0x%02x (isIgnored() == %s)\n"
                         "\tlightmodel model: 0x%02x, (isIgnored() == %s)\n"
                         "\tcomplexity type: 0x%02x, (isIgnored() == %s)\n"
                         "\tcomplexity value: %f, (isIgnored() == %s)\n"
                         "",
                         THIS->sodrawstyle->style.getValue(),
                         THIS->sodrawstyle->style.isIgnored() ? "T" : "F",
                         THIS->solightmodel->model.getValue(),
                         THIS->solightmodel->model.isIgnored() ? "T" : "F",
                         THIS->socomplexity->type.getValue(),
                         THIS->socomplexity->type.isIgnored() ? "T" : "F",
                         THIS->socomplexity->value.getValue(),
                         THIS->socomplexity->value.isIgnored() ? "T" : "F");
#endif // debug
} // changeDrawStyle()

// *************************************************************************

/*!
  \internal

  Position the near and far clipping planes just in front of and behind
  the scene's bounding box. This will give us the optimal utilization of
  the z buffer resolution by shrinking it to its minimum depth.

  Near and far clipping planes are specified in the camera fields
  nearDistance and farDistance.
*/

void
So@Gui@Viewer::setClippingPlanes(
  void )
{
  // This is necessary to avoid a crash in case there is no scene
  // graph specified by the user.
  if ( this->camera == NULL ) return;

  if ( this->autoClipBboxAction == NULL )
    this->autoClipBboxAction =
      new SoGetBoundingBoxAction( this->getViewportRegion() );
  else
    this->autoClipBboxAction->setViewportRegion( this->getViewportRegion() );

  this->autoClipBboxAction->apply( this->sceneRoot );

  SbXfBox3f xbox = this->autoClipBboxAction->getXfBoundingBox();
  SbMatrix mat;
  mat.setTranslate(- this->camera->position.getValue());
  xbox.transform(mat);
  mat = this->camera->orientation.getValue().inverse();
  xbox.transform(mat);
  SbBox3f box = xbox.project();

  // Bounding box was calculated in camera space, so we need to "flip"
  // the box (because camera is pointing in the (0,0,-1) direction
  // from origo.
  float nearval = -box.getMax()[2];
  float farval = -box.getMin()[2];

  // This factor should really be made dependent on the underlying
  // hardware or software Z buffer resolution.
  const float SLACK = 1.0f/1000.0f;

  // Scene is completely behind us.
  if (farval < SLACK) return;


  float farslack = SLACK * farval;
  
  if (this->camera->isOfType(SoPerspectiveCamera::getClassTypeId())) {
    // Disallow negative near clipping plane distance, and make sure the
    // z-buffer depth utilization is kept below a certain threshold.
    nearval = farslack > nearval ? farslack : nearval;
  }

  // Give a bit of slack to avoid artifacts when scene fits exactly
  // inside bounding box.
  this->camera->nearDistance = nearval * (1.0f - SLACK);
  this->camera->farDistance = farval * (1.0f + SLACK);

#if 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::setClippingPlanes",
                         "near, far: %f (%f), %f (%f)",
                         nearval, this->camera->nearDistance.getValue(),
                         farval, this->camera->farDistance.getValue());
#endif // debug
} // setClippingPlanes()

// *************************************************************************

/*!
  \internal

  Translate camera a distance equal to the difference in projected,
  normalized screen coordinates given by the argument.
*/

void
So@Gui@Viewer::moveCameraScreen(const SbVec2f & screenpos)
{
  SoCamera * cam = this->getCamera();
  assert(cam);

#if SO@GUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::moveCameraScreen",
                         "screenpos: <%f, %f>, campos: <%f, %f, %f>",
                         screenpos[0], screenpos[1],
                         cam->position.getValue()[0],
                         cam->position.getValue()[1],
                         cam->position.getValue()[2]);
#endif // debug

  SbViewVolume vv = cam->getViewVolume(this->getGLAspectRatio());
  SbPlane panplane = vv.getPlane(cam->focalDistance.getValue());

  SbLine line;
  vv.projectPointToLine(screenpos + SbVec2f(0.5, 0.5f), line);
  SbVec3f current_planept;
  panplane.intersect(line, current_planept);
  vv.projectPointToLine(SbVec2f(0.5f, 0.5f), line);
  SbVec3f old_planept;
  panplane.intersect(line, old_planept);

  // Reposition camera according to the vector difference between the
  // projected points.
  cam->position = cam->position.getValue() - (current_planept - old_planept);

#if SO@GUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@Gui@Viewer::moveCameraScreen",
                         "newcampos: <%f, %f, %f>",
                         cam->position.getValue()[0],
                         cam->position.getValue()[1],
                         cam->position.getValue()[2]);
#endif // debug
} // moveCameraScreen()

// *************************************************************************

/*!
  \internal

  Called when viewer enters interactive mode (animation, drag, ...).
*/

void
So@Gui@Viewer::interactivestartCB(void *, So@Gui@Viewer * thisp)
{
  // In interactive buffer mode, doublebuffering is used during interaction.
  if (thisp->pimpl->buffertype == BUFFER_INTERACTIVE) {
    thisp->pimpl->localsetbuffertype = TRUE;
    thisp->inherited::setDoubleBuffer(TRUE);
    thisp->pimpl->localsetbuffertype = FALSE;
  }

  // Use the dynamic drawstyle.
  if (!thisp->drawInteractiveAsStill())
    thisp->changeDrawStyle(thisp->pimpl->drawstyles[INTERACTIVE]);
} // interactivestartCB()

// *************************************************************************

/*!
  \internal

  Called when viewer goes out of interactive mode and into
  "frozen" mode.
*/

void
So@Gui@Viewer::interactiveendCB(void *, So@Gui@Viewer * thisp)
{
  // In interactive buffer mode, doublebuffering is used during
  // interaction, singelbuffering while the camera is static.
  if (thisp->pimpl->buffertype == BUFFER_INTERACTIVE) {
    thisp->pimpl->localsetbuffertype = TRUE;
    thisp->inherited::setDoubleBuffer(FALSE);
    thisp->pimpl->localsetbuffertype = FALSE;
  }

  // Back to static drawstyle.
  if (!thisp->drawInteractiveAsStill())
    thisp->changeDrawStyle(thisp->pimpl->drawstyles[STILL]);
} // interactiveendCB()

// *************************************************************************

/*!
  \internal

  Called repeatedly during the seek animation.
*/

void
So@Gui@Viewer::seeksensorCB(void * data, SoSensor * s)
{
  SbTime currenttime = SbTime::getTimeOfDay();

  So@Gui@Viewer * thisp = (So@Gui@Viewer *)data;
  SoTimerSensor * sensor = (SoTimerSensor *)s;

  float t =
    (currenttime - sensor->getBaseTime()).getValue() / thisp->pimpl->seekperiod;
  if ((t > 1.0f) || (t + sensor->getInterval().getValue() > 1.0f)) t = 1.0f;
  SbBool end = (t == 1.0f);

//  t = 0.5f - cos(M_PI * t) * 0.5f;
  thisp->camera->position = thisp->pimpl->camerastartposition +
    (thisp->pimpl->cameraendposition - thisp->pimpl->camerastartposition) * t;

  if (end) thisp->setSeekMode(FALSE);
} // seeksensorCB()

// *************************************************************************

/*!
  FIXME: write doc
*/

void
So@Gui@Viewer::sizeChanged(
  const SbVec2s size )
{
  inherited::sizeChanged( size );
} // sizeChanged()

// *************************************************************************

/*!
  Reset the frames-per-second counter upon window resize events,
  abnormal delays, etc.

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa addFrametime(), recordFPS()
*/
void
So@Gui@Viewer::resetFrameCounter(void)
{
  THIS->framecount = 0;
  for(int i=0; i < So@Gui@ViewerP::FRAMESARRAY_SIZE; i++) THIS->frames[i] = 0.0;
  THIS->totalval = 0.0;
  THIS->currentframetime = 0.0;
  THIS->lasttimeofday = 0.0;
}

/*!
  Adds the time spent drawing the last frame to the array of past
  frame times.

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa resetFrameCounter(), recordFPS()
*/
void
So@Gui@Viewer::addFrametime(const double ft)
{
  THIS->framecount++;

  int arrayptr = (THIS->framecount - 1) % So@Gui@ViewerP::FRAMESARRAY_SIZE;
  double oldval = THIS->frames[arrayptr];
  THIS->frames[arrayptr] = ft;
  THIS->totalval += (ft - oldval);
  THIS->currentframetime =
    THIS->totalval / So@Gui@Min(THIS->framecount,
                                (int) So@Gui@ViewerP::FRAMESARRAY_SIZE);
}

static unsigned char fps2dfont[][12] = {
  {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, //
  {  0,  0, 12, 12,  0,  8, 12, 12, 12, 12, 12,  0 }, // !
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 20, 20 }, // "
  {  0,  0, 18, 18, 18, 63, 18, 18, 63, 18, 18,  0 }, // #
  {  0,  8, 28, 42, 10, 10, 12, 24, 40, 42, 28,  8 }, // $
  {  0,  0,  6, 73, 41, 22,  8, 52, 74, 73, 48,  0 }, // %
  {  0, 12, 18, 18, 12, 25, 37, 34, 34, 29,  0,  0 }, // &
  { 12, 12, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // '
  {  0,  6,  8,  8, 16, 16, 16, 16, 16,  8,  8,  6 }, // (
  {  0, 48,  8,  8,  4,  4,  4,  4,  4,  8,  8, 48 }, // )
  {  0,  0,  0,  0,  0,  0,  8, 42, 20, 42,  8,  0 }, // *
  {  0,  0,  0,  8,  8,  8,127,  8,  8,  8,  0,  0 }, // +
  {  0, 24, 12, 12,  0,  0,  0,  0,  0,  0,  0,  0 }, // ,
  {  0,  0,  0,  0,  0,  0,127,  0,  0,  0,  0,  0 }, // -
  {  0,  0, 24, 24,  0,  0,  0,  0,  0,  0,  0,  0 }, // .
  {  0, 32, 32, 16, 16,  8,  8,  8,  4,  4,  2,  2 }, // /
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 28,  0 }, // 0
  {  0,  0,  8,  8,  8,  8,  8,  8, 40, 24,  8,  0 }, // 1
  {  0,  0, 62, 32, 16,  8,  4,  2,  2, 34, 28,  0 }, // 2
  {  0,  0, 28, 34,  2,  2, 12,  2,  2, 34, 28,  0 }, // 3
  {  0,  0,  4,  4,  4,126, 68, 36, 20, 12,  4,  0 }, // 4
  {  0,  0, 28, 34,  2,  2,  2, 60, 32, 32, 62,  0 }, // 5
  {  0,  0, 28, 34, 34, 34, 60, 32, 32, 34, 28,  0 }, // 6
  {  0,  0, 16, 16, 16,  8,  8,  4,  2,  2, 62,  0 }, // 7
  {  0,  0, 28, 34, 34, 34, 28, 34, 34, 34, 28,  0 }, // 8
  {  0,  0, 28, 34,  2,  2, 30, 34, 34, 34, 28,  0 }, // 9
  {  0,  0, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // :
  {  0, 48, 24, 24,  0,  0,  0, 24, 24,  0,  0,  0 }, // ;
  {  0,  0,  0,  2,  4,  8, 16,  8,  4,  2,  0,  0 }, // <
  {  0,  0,  0,  0,  0,127,  0,127,  0,  0,  0,  0 }, // =
  {  0,  0,  0, 16,  8,  4,  2,  4,  8, 16,  0,  0 }, // >
  {  0,  0, 16, 16,  0, 16, 28,  2,  2,  2, 60,  0 }, // ?
  {  0,  0, 28, 32, 73, 86, 82, 82, 78, 34, 28,  0 }, // @
  {  0,  0, 33, 33, 33, 63, 18, 18, 18, 12, 12,  0 }, // A
  {  0,  0, 60, 34, 34, 34, 60, 34, 34, 34, 60,  0 }, // B
  {  0,  0, 14, 16, 32, 32, 32, 32, 32, 18, 14,  0 }, // C
  {  0,  0, 56, 36, 34, 34, 34, 34, 34, 36, 56,  0 }, // D
  {  0,  0, 62, 32, 32, 32, 60, 32, 32, 32, 62,  0 }, // E
  {  0,  0, 16, 16, 16, 16, 30, 16, 16, 16, 30,  0 }, // F
  {  0,  0, 14, 18, 34, 34, 32, 32, 32, 18, 14,  0 }, // G
  {  0,  0, 34, 34, 34, 34, 62, 34, 34, 34, 34,  0 }, // H
  {  0,  0, 62,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // I
  {  0,  0,112,  8,  8,  8,  8,  8,  8,  8, 62,  0 }, // J
  {  0,  0, 33, 33, 34, 36, 56, 40, 36, 34, 33,  0 }, // K
  {  0,  0, 30, 16, 16, 16, 16, 16, 16, 16, 16,  0 }, // L
  {  0,  0, 33, 33, 33, 45, 45, 45, 51, 51, 33,  0 }, // M
  {  0,  0, 34, 34, 38, 38, 42, 42, 50, 50, 34,  0 }, // N
  {  0,  0, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // O
  {  0,  0, 32, 32, 32, 60, 34, 34, 34, 34, 60,  0 }, // P
  {  3,  6, 12, 18, 33, 33, 33, 33, 33, 18, 12,  0 }, // Q
  {  0,  0, 34, 34, 34, 36, 60, 34, 34, 34, 60,  0 }, // R
  {  0,  0, 60,  2,  2,  6, 28, 48, 32, 32, 30,  0 }, // S
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,127,  0 }, // T
  {  0,  0, 28, 34, 34, 34, 34, 34, 34, 34, 34,  0 }, // U
  {  0,  0, 12, 12, 18, 18, 18, 33, 33, 33, 33,  0 }, // V
  {  0,  0, 34, 34, 34, 54, 85, 73, 73, 73, 65,  0 }, // W
  {  0,  0, 34, 34, 20, 20,  8, 20, 20, 34, 34,  0 }, // X
  {  0,  0,  8,  8,  8,  8, 20, 20, 34, 34, 34,  0 }, // Y
  {  0,  0, 62, 32, 16, 16,  8,  4,  4,  2, 62,  0 }, // Z
  {  0, 14,  8,  8,  8,  8,  8,  8,  8,  8,  8, 14 }, // [
  {  0,  2,  2,  4,  4,  8,  8,  8, 16, 16, 32, 32 }, // [backslash]
  {  0, 56,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // ]
  {  0,  0,  0,  0,  0, 34, 34, 20, 20,  8,  8,  0 }, // ^
  {  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }, // _
  {  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 24, 12 }, // `
  {  0,  0, 29, 34, 34, 30,  2, 34, 28,  0,  0,  0 }, // a
  {  0,  0, 60, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // b
  {  0,  0, 14, 16, 32, 32, 32, 16, 14,  0,  0,  0 }, // c
  {  0,  0, 26, 38, 34, 34, 34, 34, 30,  2,  2,  2 }, // d
  {  0,  0, 28, 34, 32, 62, 34, 34, 28,  0,  0,  0 }, // e
  {  0,  0, 16, 16, 16, 16, 16, 16, 62, 16, 16, 14 }, // f
  { 28,  2,  2, 26, 38, 34, 34, 34, 30,  0,  0,  0 }, // g
  {  0,  0, 34, 34, 34, 34, 34, 50, 44, 32, 32, 32 }, // h
  {  0,  0,  8,  8,  8,  8,  8,  8, 56,  0,  8,  8 }, // i
  { 56,  4,  4,  4,  4,  4,  4,  4, 60,  0,  4,  4 }, // j
  {  0,  0, 33, 34, 36, 56, 40, 36, 34, 32, 32, 32 }, // k
  {  0,  0,  8,  8,  8,  8,  8,  8,  8,  8,  8, 56 }, // l
  {  0,  0, 73, 73, 73, 73, 73,109, 82,  0,  0,  0 }, // m
  {  0,  0, 34, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // n
  {  0,  0, 28, 34, 34, 34, 34, 34, 28,  0,  0,  0 }, // o
  { 32, 32, 60, 34, 34, 34, 34, 50, 44,  0,  0,  0 }, // p
  {  2,  2, 26, 38, 34, 34, 34, 34, 30,  0,  0,  0 }, // q
  {  0,  0, 16, 16, 16, 16, 16, 24, 22,  0,  0,  0 }, // r
  {  0,  0, 60,  2,  2, 28, 32, 32, 30,  0,  0,  0 }, // s
  {  0,  0, 14, 16, 16, 16, 16, 16, 62, 16, 16,  0 }, // t
  {  0,  0, 26, 38, 34, 34, 34, 34, 34,  0,  0,  0 }, // u
  {  0,  0,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // v
  {  0,  0, 34, 34, 34, 85, 73, 73, 65,  0,  0,  0 }, // w
  {  0,  0, 34, 34, 20,  8, 20, 34, 34,  0,  0,  0 }, // x
  { 48, 16,  8,  8, 20, 20, 34, 34, 34,  0,  0,  0 }, // y
  {  0,  0, 62, 32, 16,  8,  4,  2, 62,  0,  0,  0 }, // z
  {  0,  6,  8,  8,  8,  4, 24,  4,  8,  8,  8,  6 }, // {
  {  0,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8 }, // |
  {  0, 48,  8,  8,  8, 16, 12, 16,  8,  8,  8, 48 }, // }
  {  0,  0,  0,  0,  0,  0, 78, 57,  0,  0,  0,  0 }  // ~
};

static void
printString(const char * s)
{
#if defined(__COIN__)
  int i,n;
  n = strlen(s);
  for (i = 0; i < n; i++)
    glBitmap(8, 12, 0.0, 2.0, 10.0, 0.0, fps2dfont[s[i] - 32]);
#endif
}

static void
Draw2DString(const char * str, SbVec2s glsize, SbVec2f position)
{
  // Store GL state.
  glPushAttrib(GL_ALL_ATTRIB_BITS);

  glDisable(GL_LIGHTING);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_TEXTURE_2D);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
        
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0.0, glsize[0], 0.0, glsize[1], -1, 1);

  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glColor3f(0.0, 0.0, 0.0);
  glRasterPos2f(position[0] + 1, position[1]);
  printString( str );
  glRasterPos2f(position[0] - 1, position[1]);
  printString( str );
  glRasterPos2f(position[0], position[1] + 1);
  printString( str );
  glRasterPos2f(position[0], position[1] - 1);
  printString( str );

  glColor3f(1.0, 1.0, 0.0);
  glRasterPos2f(position[0], position[1]);
  printString( str );
  
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();

  glPopAttrib();
}


// FIXME: the following is just a temporary hack to enable the FPS
// counter. We should really write a proper interface against it, so
// applications can set up feedback loops to control scene complexity
// and get a nice and steady maximum framerate, for instance.
//
// For anyone who want to execute that task, check what TGS has done
// first. If their API is fine, use the same approach.
//
// 20001124 mortene.

/*!
  Draw a text string showing the current frame-per-seconds value in
  the lower left corner of the OpenGL canvas (after recording
  information needed to calculate the fps).

  The methods for recording FPS values are Coin extensions, not
  available in the original Open Inventor API.

  \sa resetFrameCounter(), addFrametime()
*/
void
So@Gui@Viewer::recordFPS(void)
{
  if (COIN_SHOW_FPS_COUNTER == -1) {
    char * env = getenv("COIN_SHOW_FPS_COUNTER");
    if (env) COIN_SHOW_FPS_COUNTER = atoi(env);
    else COIN_SHOW_FPS_COUNTER = 0;
  }

  if (COIN_SHOW_FPS_COUNTER) {
    double frametime, timeofday = SbTime::getTimeOfDay().getValue();
    if((THIS->lasttimeofday == 0.0) ||
       ((timeofday - THIS->lasttimeofday) > 1.0)) {
      this->resetFrameCounter();
    
      frametime = 0.0;
      THIS->lasttimeofday = timeofday;
    }
    else {
      frametime = timeofday - THIS->lasttimeofday;
      THIS->lasttimeofday = timeofday;
      this->addFrametime(frametime);

      char buffer[64];
      int nr = sprintf(buffer, "%.1f fps", 1.0/THIS->currentframetime);
      assert(nr < 64);
      Draw2DString(buffer, this->getGLSize(), SbVec2f(10, 10));
    }
  }
}

// *************************************************************************

/*!
  FIXME: write doc
*/

SbBool
So@Gui@Viewer::processSoEvent( // virtual
  const SoEvent * const event )
{
  const SoType type( event->getTypeId() );

  if ( type.isDerivedFrom( SoKeyboardEvent::getClassTypeId() ) ) {
    do {
      SoKeyboardEvent * const keyevent = (SoKeyboardEvent *) event;

      if ( keyevent->getState() != SoButtonEvent::DOWN )
        break;

      // key events for both view and interact mode

      switch ( keyevent->getKey() ) {
      case SoKeyboardEvent::ESCAPE:
        this->setViewing( this->isViewing() ? FALSE : TRUE );
        return TRUE;
      default:
        break;
      } // switch ( keyevent->getKey() )

      if ( ! this->isViewing() )
        break;

      // key events just for the view mode

      switch ( keyevent->getKey() ) {
      case SoKeyboardEvent::S:
        this->setSeekMode( this->isSeekMode() ? FALSE : TRUE );
        return TRUE;
      case SoKeyboardEvent::Q:
        this->hide();
        So@Gui@::exitMainLoop();
        return TRUE;
      case SoKeyboardEvent::HOME:
        this->resetToHomePosition();
        return TRUE;
      case SoKeyboardEvent::LEFT_ARROW:
        this->moveCameraScreen( SbVec2f( -0.1f, 0.0f ) );
        return TRUE;
      case SoKeyboardEvent::UP_ARROW:
        this->moveCameraScreen( SbVec2f( 0.0f, 0.1f ) );
        return TRUE;
      case SoKeyboardEvent::RIGHT_ARROW:
        this->moveCameraScreen( SbVec2f( 0.1f, 0.0f ) );
        return TRUE;
      case SoKeyboardEvent::DOWN_ARROW:
        this->moveCameraScreen( SbVec2f( 0.0f, -0.1f ) );
        return TRUE;
      default:
        break;
      } // switch ( keyevent->getKey() )
    } while ( FALSE );
  }

  if ( ! this->isViewing() )
    return inherited::processSoEvent(event);

  return FALSE;
} // processSoEvent()

// *************************************************************************

/*!
  This method is obsoleted.
*/

SbBool
So@Gui@Viewer::processCommonEvents(
  @EVENT@ event )
{
  if ( this->invokeAppCB( event ) )
    return TRUE;

  return FALSE;
} // processCommonEvents()

// *************************************************************************

#if SO@GUI@_DEBUG
static const char * getSo@Gui@ViewerRCSId(void) { return rcsid; }
#endif // SO@GUI@_DEBUG

