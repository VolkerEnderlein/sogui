/**************************************************************************\
 *
 *  This file is part of the Coin GUI toolkit libraries.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public License
 *  version 2.1 as published by the Free Software Foundation.  See the
 *  file LICENSE.LGPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you want to use this library with software that is incompatible
 *  licensewise with the LGPL, and / or you would like to take
 *  advantage of the additional benefits with regard to our support
 *  services, please contact Systems in Motion about acquiring a Coin
 *  Professional Edition License.  See <URL:http://www.coin3d.org> for
 *  more information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

// @configure_input@

// This file contains the generic, "templatize-able" parts of the
// So*FullViewer sourcecode.


// *************************************************************************

#include <Inventor/@Gui@/viewers/So@Gui@FullViewer.h>
#include <Inventor/@Gui@/widgets/So@Gui@PopupMenu.h>
#include <Inventor/@Gui@/widgets/So@Gui@ThumbWheel.h>
#include <so@gui@defs.h>

#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/errors/SoDebugError.h>

// ************************************************************************

// Note: the following function documentation block will also be used
// for all the miscellaneous viewer subclasses, so keep it general.
/*!
  \fn void So@Gui@FullViewer::createViewerButtons(@WIDGET@ parent, SbPList * buttonlist)

  Set up the viewer buttons with pixmaps and event connections.


  One important note if you want to override this method to add your
  own buttons to the list (in the explanation below, it is assumed
  that you know how virtual function table pointers are handled by
  C++):

  createViewerButtons() is called (indirectly) from the constructors
  of the viewer classes. This means that you need to delay it's
  invocation until your own subclass's constructor is run, because
  otherwise your re-implementation won't have been added to the
  internal virtual function table yet.

  Delaying a superclass viewer from building it's decorations is done
  by passing build==FALSE as the last argument of the protected
  constructors. You will then have to explicitly trigger the building
  in your own constructor.

  Here's a minimal example that shows the steps needed to be able to
  override createViewerButtons() from So@Gui@ExaminerViewer:

  \code
  class MyExaminerViewer : public So@Gui@ExaminerViewer {
  
  public:
    MyExaminerViewer(@WIDGET@ parent);
  
  protected:
    virtual void createViewerButtons(@WIDGET@ parent, SbPList * buttonlist);
  };
  
  MyExaminerViewer::MyExaminerViewer(@WIDGET@ parent)
    : So@Gui@ExaminerViewer(parent, NULL, TRUE,
                            So@Gui@FullViewer::BUILD_ALL, So@Gui@FullViewer::BROWSER,
                            // build == FALSE, to delay creation of decorations
                            FALSE)
  {
    // Explicitly trigger the construction of viewer decorations.
    @WIDGET@ widget = this->buildWidget(this->getParentWidget());
    this->setBaseWidget(widget);
  }
  
  void
  MyExaminerViewer::createViewerButtons(@WIDGET@ parent, SbPList * buttonlist)
  {
    So@Gui@ExaminerViewer::createViewerButtons(parent, buttonlist);
    // [now add your own button(s) to the buttonlist]
  }
  \endcode
*/

// ************************************************************************

// Note: the following function documentation blocks for thumbwheel
// handling will also be used for all the miscellaneous viewer
// subclasses, so keep'em general.

/*!
  Called when the user start to drag the thumbwheel in the left
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa leftWheelMotion(), leftWheelFinish()
  \sa bottomWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::leftWheelStart(void)
{
  this->interactiveCountInc();
}

/*!
  Called repeatedly as the user drags the thumbwheel in the left
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa leftWheelStart(), leftWheelFinish()
  \sa bottomWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::leftWheelMotion(float value)
{
  this->leftWheelVal = value;
}

/*!
  Called as the user let go of the thumbwheel in the left frame
  after a drag operation. Override this method in subclassed viewers
  to provide your own functionality on the thumbwheel.

  \sa leftWheelStart(), leftWheelMotion()
  \sa bottomWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::leftWheelFinish(void)
{
  this->interactiveCountDec();
}

#ifdef __COIN_SOXT__
#define SO@GUI@_SETTHUMBWHEEL_VAL(wheel, val) SoXtThumbWheelSetValue(wheel, val)
#else // SoQt, SoGtk, SoWin
#define SO@GUI@_SETTHUMBWHEEL_VAL(wheel, val) ((So@Gui@ThumbWheel *)wheel)->setValue(val)
#endif

/*!
  Set a new value for the left thumbwheel.
*/
void
So@Gui@FullViewer::setLeftWheelValue(const float value)
{
  this->leftWheelVal = value;
  SO@GUI@_SETTHUMBWHEEL_VAL(this->leftWheel, value);
}

/*!
  Get current value of the left thumbwheel.

  \sa leftWheelMotion()
*/
float
So@Gui@FullViewer::getLeftWheelValue(void) const
{
  return this->leftWheelVal;
}

/*!
  Called when the user start to drag the thumbwheel in the bottom
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa bottomWheelMotion(), bottomWheelFinish()
  \sa leftWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::bottomWheelStart(void)
{
  this->interactiveCountInc();
}

/*!
  Called repeatedly as the user drags the thumbwheel in the bottom
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa bottomWheelStart(), bottomWheelFinish()
  \sa leftWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::bottomWheelMotion(float value)
{
  this->bottomWheelVal = value;
}

/*!
  Called as the user let go of the thumbwheel in the bottom frame
  after a drag operation. Override this method in subclassed viewers
  to provide your own functionality on the thumbwheel.

  \sa bottomWheelStart(), bottomWheelMotion()
  \sa leftWheelStart(), rightWheelStart()
*/
void
So@Gui@FullViewer::bottomWheelFinish(void)
{
  this->interactiveCountDec();
}

/*!
  Set a new value for the bottom thumbwheel.
*/
void
So@Gui@FullViewer::setBottomWheelValue(const float value)
{
  this->bottomWheelVal = value;
  SO@GUI@_SETTHUMBWHEEL_VAL(this->bottomWheel, value);
}

/*!
  Get current value of the bottom thumbwheel.

  \sa bottomWheelMotion()
*/
float
So@Gui@FullViewer::getBottomWheelValue(void) const
{
  return this->bottomWheelVal;
}

/*!
  Called when the user start to drag the thumbwheel in the right
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa rightWheelMotion(), rightWheelFinish()
  \sa leftWheelStart(), bottomWheelStart()
*/
void
So@Gui@FullViewer::rightWheelStart(void)
{
  this->interactiveCountInc();
}

/*!
  Called repeatedly as the user drags the thumbwheel in the right
  frame.  Override this method in subclassed viewers to provide your
  own functionality on the thumbwheel.

  \sa rightWheelStart(), rightWheelFinish()
  \sa leftWheelStart(), bottomWheelStart()
*/
void
So@Gui@FullViewer::rightWheelMotion(float value)
{
  this->rightWheelVal = value;
}

/*!
  Called as the user let go of the thumbwheel in the right frame
  after a drag operation. Override this method in subclassed viewers
  to provide your own functionality on the thumbwheel.

  \sa rightWheelStart(), rightWheelMotion()
  \sa leftWheelStart(), bottomWheelStart()
*/
void
So@Gui@FullViewer::rightWheelFinish(void)
{
  this->interactiveCountDec();
}

/*!
  Set a new value for the right thumbwheel.
*/
void
So@Gui@FullViewer::setRightWheelValue(const float value)
{
  this->rightWheelVal = value;
  SO@GUI@_SETTHUMBWHEEL_VAL(this->rightWheel, value);
}

/*!
  Get current value of the right thumbwheel.

  \sa rightWheelMotion()
*/
float
So@Gui@FullViewer::getRightWheelValue(void) const
{
  return this->rightWheelVal;
}

// *************************************************************************

/*!
  This method returns the native widget for the label below the left
  thumb wheel.
*/

@WIDGET@
So@Gui@FullViewer::getLeftWheelLabelWidget(void) const
{
  return this->leftWheelLabel;
}

/*!
  This method returns the native widget for the label below the right thumb
  wheel.
*/
@WIDGET@
So@Gui@FullViewer::getRightWheelLabelWidget(void) const
{
  return this->rightWheelLabel;
}

/*!
  This method returns the native widget for the label beside the
  bottom thumb wheel.
*/
@WIDGET@
So@Gui@FullViewer::getBottomWheelLabelWidget(void) const
{
  return this->bottomWheelLabel;
}

// ************************************************************************

/*!
  Set title of popup menu.
*/
void
So@Gui@FullViewer::setPopupMenuString(const char * name)
{
  this->popupmenutitle = name;
  if (this->prefmenu) { this->prefmenu->setMenuTitle(ROOT_MENU, name); }
}

// ************************************************************************

So@Gui@PopupMenu *
So@Gui@FullViewer::setupStandardPopupMenu(void)
{
  So@Gui@PopupMenu * menu = So@Gui@PopupMenu::createInstance();

  menu->newMenu("rootmenu", ROOT_MENU);
  // FIXME: none of the So*-toolkits so far uses the rootmenu title to
  // set up a title string at the top of the root popupmenu. 20010810 mortene.
  menu->setMenuTitle(ROOT_MENU, this->popupmenutitle.getString());

#if 0 // OBSOLETED: this looks ugly and confusing for the user. 20010810 mortene.
  // Simple hack for a common / generic way of setting up a title for
  // the popupmenu.
  menu->newMenuItem("rootmenutitle", ROOT_MENU_TITLE);
  menu->setMenuItemTitle(ROOT_MENU_TITLE, this->popupmenutitle.getString());
  menu->addMenuItem(ROOT_MENU, ROOT_MENU_TITLE);
  menu->setMenuItemEnabled(ROOT_MENU_TITLE, FALSE);
  menu->addSeparator(ROOT_MENU);
#endif // OBSOLETED

  menu->newMenu("functionsmenu", FUNCTIONS_MENU);
  menu->setMenuTitle(FUNCTIONS_MENU, _("Functions"));
  menu->newMenu("drawstylesmenu", DRAWSTYLES_MENU);
  menu->setMenuTitle(DRAWSTYLES_MENU, _("Draw Styles"));
  menu->newMenu("stereomenu", STEREO_MENU);
  menu->setMenuTitle(STEREO_MENU, _("Stereo Viewing"));
  menu->newMenuItem("examining", EXAMINING_ITEM);
  menu->setMenuItemTitle(EXAMINING_ITEM, _("Viewing"));
  menu->newMenuItem("decoration", DECORATION_ITEM);
  menu->setMenuItemTitle(DECORATION_ITEM, _("Decorations"));
  menu->newMenuItem("headlight", HEADLIGHT_ITEM);
  menu->setMenuItemTitle(HEADLIGHT_ITEM, _("Headlight"));
  menu->newMenuItem("fullscreen", FULLSCREEN_ITEM);
  menu->setMenuItemTitle(FULLSCREEN_ITEM, _("Fullscreen"));
  menu->newMenuItem("preferences", PREFERENCES_ITEM);
  menu->setMenuItemTitle(PREFERENCES_ITEM, _("Preferences..."));

  menu->addMenu(ROOT_MENU, FUNCTIONS_MENU);
  menu->addMenu(ROOT_MENU, DRAWSTYLES_MENU);
  menu->addMenu(ROOT_MENU, STEREO_MENU);
  menu->addMenuItem(ROOT_MENU, EXAMINING_ITEM);
  menu->addMenuItem(ROOT_MENU, DECORATION_ITEM);
  menu->addMenuItem(ROOT_MENU, HEADLIGHT_ITEM);
  menu->addMenuItem(ROOT_MENU, FULLSCREEN_ITEM);
  menu->addSeparator(ROOT_MENU);
  menu->addMenuItem(ROOT_MENU, PREFERENCES_ITEM);

  menu->newMenuItem("help", HELP_ITEM);
  menu->setMenuItemTitle(HELP_ITEM, _("Help"));
  menu->newMenuItem("home", HOME_ITEM);
  menu->setMenuItemTitle(HOME_ITEM, _("Home"));
  menu->newMenuItem("set_home", SET_HOME_ITEM);
  menu->setMenuItemTitle(SET_HOME_ITEM, _("Set Home"));
  menu->newMenuItem("view_all", VIEW_ALL_ITEM);
  menu->setMenuItemTitle(VIEW_ALL_ITEM, _("View All"));
  menu->newMenuItem("seek", SEEK_ITEM);
  menu->setMenuItemTitle(SEEK_ITEM, _("Seek"));
  menu->newMenuItem("copy_view", COPY_VIEW_ITEM);
  menu->setMenuItemTitle(COPY_VIEW_ITEM, _("Copy View"));
  menu->newMenuItem("paste_view", PASTE_VIEW_ITEM);
  menu->setMenuItemTitle(PASTE_VIEW_ITEM, _("Paste View"));

  menu->addMenuItem(FUNCTIONS_MENU, HELP_ITEM);
  menu->addMenuItem(FUNCTIONS_MENU, HOME_ITEM);
  menu->addMenuItem(FUNCTIONS_MENU, SET_HOME_ITEM);
  menu->addMenuItem(FUNCTIONS_MENU, VIEW_ALL_ITEM);
  menu->addMenuItem(FUNCTIONS_MENU, SEEK_ITEM);
  menu->addSeparator(FUNCTIONS_MENU);
  menu->addMenuItem(FUNCTIONS_MENU, COPY_VIEW_ITEM);
  menu->addMenuItem(FUNCTIONS_MENU, PASTE_VIEW_ITEM);

  menu->newMenu("drawstylesstill", DRAWSTYLES_STILL_MENU);
  menu->setMenuTitle(DRAWSTYLES_STILL_MENU, _("Still Drawstyle"));

  menu->newMenuItem("as_is", AS_IS_ITEM);
  menu->setMenuItemTitle(AS_IS_ITEM, _("as is"));
  menu->newMenuItem("hidden_line", HIDDEN_LINE_ITEM);
  menu->setMenuItemTitle(HIDDEN_LINE_ITEM, _("hidden line"));
  menu->newMenuItem("wireframe_overlay", WIREFRAME_OVERLAY_ITEM);
  menu->setMenuItemTitle(WIREFRAME_OVERLAY_ITEM, _("wireframe overlay"));
  menu->newMenuItem("no_textures", NO_TEXTURE_ITEM);
  menu->setMenuItemTitle(NO_TEXTURE_ITEM, _("no texture"));
  menu->newMenuItem("low_resolution", LOW_RESOLUTION_ITEM);
  menu->setMenuItemTitle(LOW_RESOLUTION_ITEM, _("low resolution"));
  menu->newMenuItem("wireframe", WIREFRAME_ITEM);
  menu->setMenuItemTitle(WIREFRAME_ITEM, _("wireframe"));
  menu->newMenuItem("points", POINTS_ITEM);
  menu->setMenuItemTitle(POINTS_ITEM, _("points"));
  menu->newMenuItem("bounding_box", BOUNDING_BOX_ITEM);
  menu->setMenuItemTitle(BOUNDING_BOX_ITEM, _("bounding box (no depth)"));

  menu->newRadioGroup(STILL_GROUP);
  menu->addRadioGroupItem(STILL_GROUP, AS_IS_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, HIDDEN_LINE_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, WIREFRAME_OVERLAY_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, NO_TEXTURE_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, LOW_RESOLUTION_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, WIREFRAME_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, POINTS_ITEM);
  menu->addRadioGroupItem(STILL_GROUP, BOUNDING_BOX_ITEM);

  menu->addMenuItem(DRAWSTYLES_STILL_MENU, AS_IS_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, HIDDEN_LINE_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, WIREFRAME_OVERLAY_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, NO_TEXTURE_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, LOW_RESOLUTION_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, WIREFRAME_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, POINTS_ITEM);
  menu->addMenuItem(DRAWSTYLES_STILL_MENU, BOUNDING_BOX_ITEM);

  menu->newMenu("drawstylesanimation", DRAWSTYLES_ANIMATING_MENU);
  menu->setMenuTitle(DRAWSTYLES_ANIMATING_MENU, _("Animating Drawstyle"));

  menu->newMenuItem("move_same_as_still", MOVE_SAME_AS_STILL_ITEM);
  menu->setMenuItemTitle(MOVE_SAME_AS_STILL_ITEM, _("same as still"));
  menu->newMenuItem("move_no_texture", MOVE_NO_TEXTURE_ITEM);
  menu->setMenuItemTitle(MOVE_NO_TEXTURE_ITEM, _("no texture"));
  menu->newMenuItem("move_low_res", MOVE_LOW_RES_ITEM);
  menu->setMenuItemTitle(MOVE_LOW_RES_ITEM, _("low resolution"));
  menu->newMenuItem("move_wireframe", MOVE_WIREFRAME_ITEM);
  menu->setMenuItemTitle(MOVE_WIREFRAME_ITEM, _("wireframe"));
  menu->newMenuItem("move_low_res_wireframe", MOVE_LOW_RES_WIREFRAME_ITEM);
  menu->setMenuItemTitle(MOVE_LOW_RES_WIREFRAME_ITEM,
    _("low res wireframe (no depth)"));
  menu->newMenuItem("move_points", MOVE_POINTS_ITEM);
  menu->setMenuItemTitle(MOVE_POINTS_ITEM, _("points"));
  menu->newMenuItem("move_low_res_points", MOVE_LOW_RES_POINTS_ITEM);
  menu->setMenuItemTitle(MOVE_LOW_RES_POINTS_ITEM,
    _("low res points (no depth)"));
  menu->newMenuItem("move_bounding_box", MOVE_BOUNDING_BOX_ITEM);
  menu->setMenuItemTitle(MOVE_BOUNDING_BOX_ITEM, _("bounding box (no depth)"));

  menu->newRadioGroup(MOVE_GROUP);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_SAME_AS_STILL_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_NO_TEXTURE_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_LOW_RES_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_WIREFRAME_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_LOW_RES_WIREFRAME_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_POINTS_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_LOW_RES_POINTS_ITEM);
  menu->addRadioGroupItem(MOVE_GROUP, MOVE_BOUNDING_BOX_ITEM);

  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_SAME_AS_STILL_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_NO_TEXTURE_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_WIREFRAME_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_WIREFRAME_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_POINTS_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_POINTS_ITEM);
  menu->addMenuItem(DRAWSTYLES_ANIMATING_MENU, MOVE_BOUNDING_BOX_ITEM);

  menu->newMenu("transparencytype", TRANSPARENCY_TYPE_MENU);
  menu->setMenuTitle(TRANSPARENCY_TYPE_MENU, _("Transparency Type"));
  menu->newRadioGroup(TRANSPARENCY_GROUP);

  { // Fill in menu items in radiomenu with transparency selections.

    struct menutransparencyitem {
      const char * name, * title;
      int id;
    };

    struct menutransparencyitem items[] = {
      { "screen_door", _("screen door"), SCREEN_DOOR_TRANSPARENCY_ITEM },
      { "add", _("add"), ADD_TRANSPARENCY_ITEM },
      { "delayed_add", _("delayed add"), DELAYED_ADD_TRANSPARENCY_ITEM },
      { "sorted_object_add", _("sorted object add"), SORTED_OBJECT_ADD_TRANSPARENCY_ITEM },
      { "blend", _("blend"), BLEND_TRANSPARENCY_ITEM },
      { "delayed_blend", _("delayed blend"), DELAYED_BLEND_TRANSPARENCY_ITEM },
      { "sorted_object_blend", _("sorted object blend"), SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM }
#ifdef __COIN__ // Coin extensions
      ,
      { "sorted_object_sorted_triangle_add", _("sorted object sorted triangle add"), SORTED_OBJECT_SORTED_TRIANGLE_ADD_TRANSPARENCY_ITEM },
      { "sorted_object_sorted_triangle_blend", _("sorted object sorted triangle blend"), SORTED_OBJECT_SORTED_TRIANGLE_BLEND_TRANSPARENCY_ITEM }
#endif // __COIN__
    };

    int nritems = sizeof(items) / sizeof(struct menutransparencyitem);
    for (int i = 0; i < nritems; i++) {
      menu->newMenuItem(items[i].name, items[i].id);
      menu->setMenuItemTitle(items[i].id, items[i].title);
      menu->addRadioGroupItem(TRANSPARENCY_GROUP, items[i].id);
      menu->addMenuItem(TRANSPARENCY_TYPE_MENU, items[i].id);
    }
  }

  menu->newMenuItem("stereooff", STEREO_OFF_ITEM);
  menu->newMenuItem("stereoredcyan", STEREO_ANAGLYPH_ITEM);
  menu->newMenuItem("stereoquadbuffer", STEREO_QUADBUFFER_ITEM);
  menu->setMenuItemTitle(STEREO_OFF_ITEM, _("Off"));
  menu->setMenuItemTitle(STEREO_ANAGLYPH_ITEM, _("Red/Cyan"));
  menu->setMenuItemTitle(STEREO_QUADBUFFER_ITEM, _("Quad buffer"));

  menu->newRadioGroup(STEREO_GROUP);
  menu->addRadioGroupItem(STEREO_GROUP, STEREO_OFF_ITEM);
  menu->addRadioGroupItem(STEREO_GROUP, STEREO_ANAGLYPH_ITEM);
  menu->addRadioGroupItem(STEREO_GROUP, STEREO_QUADBUFFER_ITEM);

  menu->addMenuItem(STEREO_MENU, STEREO_OFF_ITEM);
  menu->addMenuItem(STEREO_MENU, STEREO_ANAGLYPH_ITEM);
  menu->addMenuItem(STEREO_MENU, STEREO_QUADBUFFER_ITEM);

  menu->newMenu("renderbuffertype", RENDER_BUFFER_TYPE_MENU);
  menu->setMenuTitle(RENDER_BUFFER_TYPE_MENU, _("Render Buffer Type"));

  menu->newMenuItem("single_buffer", SINGLE_BUFFER_ITEM);
  menu->setMenuItemTitle(SINGLE_BUFFER_ITEM, _("single"));
  menu->newMenuItem("double_buffer", DOUBLE_BUFFER_ITEM);
  menu->setMenuItemTitle(DOUBLE_BUFFER_ITEM, _("double"));
  menu->newMenuItem("interactive_buffer", INTERACTIVE_BUFFER_ITEM);
  menu->setMenuItemTitle(INTERACTIVE_BUFFER_ITEM, _("interactive"));

  menu->newRadioGroup(BUFFER_GROUP);
  menu->addRadioGroupItem(BUFFER_GROUP, SINGLE_BUFFER_ITEM);
  menu->addRadioGroupItem(BUFFER_GROUP, DOUBLE_BUFFER_ITEM);
  menu->addRadioGroupItem(BUFFER_GROUP, INTERACTIVE_BUFFER_ITEM);

  menu->addMenuItem(RENDER_BUFFER_TYPE_MENU, SINGLE_BUFFER_ITEM);
  menu->addMenuItem(RENDER_BUFFER_TYPE_MENU, DOUBLE_BUFFER_ITEM);
  menu->addMenuItem(RENDER_BUFFER_TYPE_MENU, INTERACTIVE_BUFFER_ITEM);

  menu->addMenu(DRAWSTYLES_MENU, DRAWSTYLES_STILL_MENU);
  menu->addMenu(DRAWSTYLES_MENU, DRAWSTYLES_ANIMATING_MENU);
  menu->addMenu(DRAWSTYLES_MENU, TRANSPARENCY_TYPE_MENU);
  menu->addMenu(DRAWSTYLES_MENU, RENDER_BUFFER_TYPE_MENU);

  int toggle;
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem(toggle, EXAMINING_ITEM);
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem(toggle, DECORATION_ITEM);
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem(toggle, HEADLIGHT_ITEM);
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem(toggle, FULLSCREEN_ITEM);

  menu->addMenuSelectionCallback(So@Gui@FullViewer::menuSelectionCallback,
    (void *) this);

  this->prefmenu = menu;
  return menu;
}

// ************************************************************************

void
So@Gui@FullViewer::prepareMenu(So@Gui@PopupMenu * menu)
{
  //// Misc. //////////////////////////////////////////////////////////
  menu->setMenuItemMarked(DECORATION_ITEM, this->isDecoration());
  menu->setMenuItemMarked(EXAMINING_ITEM, this->isViewing());
  menu->setMenuItemMarked(HEADLIGHT_ITEM, this->isHeadlight());
  menu->setMenuItemMarked(FULLSCREEN_ITEM, this->isFullScreen());

  //// Basic drawstyles. //////////////////////////////////////////////
  this->setDrawStyleMenuActivation(So@Gui@FullViewer::STILL,
                                   this->getDrawStyle(So@Gui@FullViewer::STILL));
  this->setDrawStyleMenuActivation(So@Gui@FullViewer::INTERACTIVE,
                                   this->getDrawStyle(So@Gui@FullViewer::INTERACTIVE));

  //// Transparency setting. //////////////////////////////////////////
  switch (this->getTransparencyType()) {
  case SoGLRenderAction::SCREEN_DOOR:
    menu->setMenuItemMarked(SCREEN_DOOR_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::ADD:
    menu->setMenuItemMarked(ADD_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::DELAYED_ADD:
    menu->setMenuItemMarked(DELAYED_ADD_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::SORTED_OBJECT_ADD:
    menu->setMenuItemMarked(SORTED_OBJECT_ADD_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::BLEND:
    menu->setMenuItemMarked(BLEND_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::DELAYED_BLEND:
    menu->setMenuItemMarked(DELAYED_BLEND_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::SORTED_OBJECT_BLEND:
    menu->setMenuItemMarked(SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM, TRUE);
    break;
#ifdef __COIN__  // Coin extensions
  case SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_ADD:
    menu->setMenuItemMarked(SORTED_OBJECT_SORTED_TRIANGLE_ADD_TRANSPARENCY_ITEM, TRUE);
    break;
  case SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND:
    menu->setMenuItemMarked(SORTED_OBJECT_SORTED_TRIANGLE_BLEND_TRANSPARENCY_ITEM, TRUE);
    break;
#endif // __COIN__
  default: assert(FALSE && "unknown transparency type");
  }

  //// Stereo viewing. ////////////////////////////////////////////////
  SbBool stereo = this->isStereoViewing();
  SbBool quadbuffer = this->isQuadBufferStereo();
 if (!stereo)
  menu->setMenuItemMarked(STEREO_OFF_ITEM, TRUE);
 if (stereo && !quadbuffer)
  menu->setMenuItemMarked(STEREO_ANAGLYPH_ITEM, TRUE);
 if (stereo && quadbuffer)
  menu->setMenuItemMarked(STEREO_QUADBUFFER_ITEM, TRUE);

  //// GL canvas settings. ////////////////////////////////////////////
  switch (this->getBufferingType()) {
  case So@Gui@Viewer::BUFFER_SINGLE:
    menu->setMenuItemMarked(SINGLE_BUFFER_ITEM, TRUE);
    break;
  case So@Gui@Viewer::BUFFER_DOUBLE:
    menu->setMenuItemMarked(DOUBLE_BUFFER_ITEM, TRUE);
    break;
  case So@Gui@Viewer::BUFFER_INTERACTIVE:
    menu->setMenuItemMarked(INTERACTIVE_BUFFER_ITEM, TRUE);
    break;
  default:
    assert(0 && "unsupported buffer type");
    break;
  }
}

// ************************************************************************

void
So@Gui@FullViewer::menuSelection(int menuitemid)
{
  switch (menuitemid) {
  case -1:
    // means no item was selected
#if SO@GUI@_DEBUG
    SoDebugError::postInfo("So@Gui@FullViewer::menuSelection",
      "-1 not appropriate on callback usage");
#endif // SO@GUI@_DEBUG
    break;

  case EXAMINING_ITEM:
    this->setViewing(this->isViewing() ? FALSE : TRUE);
    break;
  case DECORATION_ITEM:
    this->setDecoration(this->isDecoration() ? FALSE : TRUE);
    break;
  case HEADLIGHT_ITEM:
    this->setHeadlight(this->isHeadlight() ? FALSE : TRUE);
    break;
  case FULLSCREEN_ITEM:
    (void)this->setFullScreen(this->isFullScreen() ? FALSE : TRUE);
    break;
  case PREFERENCES_ITEM:
    this->selectedPrefs();
    break;

  case HELP_ITEM:
    this->openViewerHelpCard();
    break;
  case HOME_ITEM:
    this->resetToHomePosition();
    break;
  case SET_HOME_ITEM:
    this->saveHomePosition();
    break;
  case VIEW_ALL_ITEM:
    this->viewAll();
    break;
  case SEEK_ITEM:
    this->seekbuttonClicked();
    break;
  case COPY_VIEW_ITEM:
    this->copyView(SbTime::getTimeOfDay());

    break;
  case PASTE_VIEW_ITEM:
    this->pasteView(SbTime::getTimeOfDay());
    break;

  case AS_IS_ITEM:
  case HIDDEN_LINE_ITEM:
  case WIREFRAME_OVERLAY_ITEM:
  case NO_TEXTURE_ITEM:
  case LOW_RESOLUTION_ITEM:
  case WIREFRAME_ITEM:
  case POINTS_ITEM:
  case BOUNDING_BOX_ITEM:
    this->drawstyleActivated(menuitemid);
    break;

  case MOVE_SAME_AS_STILL_ITEM:
  case MOVE_NO_TEXTURE_ITEM:
  case MOVE_LOW_RES_ITEM:
  case MOVE_WIREFRAME_ITEM:
  case MOVE_LOW_RES_WIREFRAME_ITEM:
  case MOVE_POINTS_ITEM:
  case MOVE_LOW_RES_POINTS_ITEM:
  case MOVE_BOUNDING_BOX_ITEM:
    this->drawstyleActivated(menuitemid);
    break;

  case SCREEN_DOOR_TRANSPARENCY_ITEM:
  case ADD_TRANSPARENCY_ITEM:
  case DELAYED_ADD_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_ADD_TRANSPARENCY_ITEM:
  case BLEND_TRANSPARENCY_ITEM:
  case DELAYED_BLEND_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_SORTED_TRIANGLE_ADD_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_SORTED_TRIANGLE_BLEND_TRANSPARENCY_ITEM:
    this->drawstyleActivated(menuitemid);
    this->scheduleRedraw();
    break;

  case SINGLE_BUFFER_ITEM:
  case DOUBLE_BUFFER_ITEM:
  case INTERACTIVE_BUFFER_ITEM:
    this->drawstyleActivated(menuitemid);
    break;

  case STEREO_OFF_ITEM:
    this->setStereoViewing(FALSE);
    this->setQuadBufferStereo(FALSE);
    break;
  case STEREO_ANAGLYPH_ITEM:
    this->setStereoViewing(TRUE);
    this->setQuadBufferStereo(FALSE);
    break;
  case STEREO_QUADBUFFER_ITEM:
    this->setStereoViewing(TRUE);
    this->setQuadBufferStereo(TRUE);
    if (!this->isQuadBufferStereo()) {
      this->setStereoViewing(FALSE);
      this->prefmenu->setMenuItemMarked(STEREO_OFF_ITEM, TRUE);
    }
    break;

  default:
    SoDebugError::postInfo("So@Gui@FullViewer::menuSelection",
                           "popup menu handling for item %d is not implemented", 
                           menuitemid);
    break;
  }
}


// ************************************************************************

void
So@Gui@FullViewer::menuSelectionCallback(int menuitemid,
                                         void * userdata)
{
  So@Gui@FullViewer * viewer = (So@Gui@FullViewer *) userdata;
  viewer->menuSelection(menuitemid);
}

// ************************************************************************

/*!
 \internal
*/

void
So@Gui@FullViewer::setDrawStyleMenuActivation(So@Gui@Viewer::DrawType type,
                                              So@Gui@Viewer::DrawStyle value)
{
  assert(this->prefmenu != NULL);

  switch (type) {
  case So@Gui@Viewer::STILL:
    switch (value) {
    case So@Gui@Viewer::VIEW_AS_IS:
      this->prefmenu->setMenuItemMarked(AS_IS_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_HIDDEN_LINE:
      this->prefmenu->setMenuItemMarked(HIDDEN_LINE_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_WIREFRAME_OVERLAY:
      this->prefmenu->setMenuItemMarked(WIREFRAME_OVERLAY_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_NO_TEXTURE:
      this->prefmenu->setMenuItemMarked(NO_TEXTURE_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_COMPLEXITY:
      this->prefmenu->setMenuItemMarked(LOW_RESOLUTION_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_LINE:
#if SO@GUI@_DEBUG
      SoDebugError::postWarning("So@Gui@FullViewer::setDrawStyleMenuActivation",
                                "Use VIEW_LINE, not VIEW_LOW_RES_LINE for the STILL drawstyle.");
#endif // debug
    case So@Gui@Viewer::VIEW_LINE:
      this->prefmenu->setMenuItemMarked(WIREFRAME_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_POINT:
#if SO@GUI@_DEBUG
      SoDebugError::postWarning("So@Gui@FullViewer::setDrawStyleMenuActivation",
                                "Use VIEW_POINT, not VIEW_LOW_RES_POINT for the STILL drawstyle.");
#endif // debug
    case So@Gui@Viewer::VIEW_POINT:
      this->prefmenu->setMenuItemMarked(POINTS_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_BBOX:
      this->prefmenu->setMenuItemMarked(BOUNDING_BOX_ITEM, TRUE);
      break;
    default:
      assert(0 && "unsupported default switch-case");
      break;
    }
    break;

  case So@Gui@Viewer::INTERACTIVE:
    switch (value) {
    case So@Gui@Viewer::VIEW_SAME_AS_STILL:
      this->prefmenu->setMenuItemMarked(MOVE_SAME_AS_STILL_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_NO_TEXTURE:
      this->prefmenu->setMenuItemMarked(MOVE_NO_TEXTURE_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_COMPLEXITY:
      this->prefmenu->setMenuItemMarked(MOVE_LOW_RES_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LINE:
      this->prefmenu->setMenuItemMarked(MOVE_WIREFRAME_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_LINE:
      this->prefmenu->setMenuItemMarked(MOVE_LOW_RES_WIREFRAME_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_POINT:
      this->prefmenu->setMenuItemMarked(MOVE_POINTS_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_POINT:
      this->prefmenu->setMenuItemMarked(MOVE_LOW_RES_POINTS_ITEM, TRUE);
      break;
    case So@Gui@Viewer::VIEW_BBOX:
      this->prefmenu->setMenuItemMarked(MOVE_BOUNDING_BOX_ITEM, TRUE);
      break;
    default:
      assert(0 && "unsupported default switch-case");
      break;
    }
    break;

  default:
    assert(0 && "unsupported default switch-case");
    break;
  }
}

// ************************************************************************

/*!
  \internal
*/

void
So@Gui@FullViewer::drawstyleActivated(int menuitemid)
{
  switch (menuitemid) {
  case SINGLE_BUFFER_ITEM:
    this->setBufferingType(So@Gui@Viewer::BUFFER_SINGLE);
    return;
  case DOUBLE_BUFFER_ITEM:
    this->setBufferingType(So@Gui@Viewer::BUFFER_DOUBLE);
    return;
  case INTERACTIVE_BUFFER_ITEM:
    this->setBufferingType(So@Gui@Viewer::BUFFER_INTERACTIVE);
    return;
  default:
    break;
  }

  switch (menuitemid) {
  case SCREEN_DOOR_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::SCREEN_DOOR);
    return;
  case ADD_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::ADD);
    return;
  case DELAYED_ADD_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::DELAYED_ADD);
    return;
  case SORTED_OBJECT_ADD_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_ADD);
    return;
  case BLEND_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::BLEND);
    return;
  case DELAYED_BLEND_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::DELAYED_BLEND);
    return;
  case SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_BLEND);
    return;
#ifdef __COIN__ // Coin extensions
  case SORTED_OBJECT_SORTED_TRIANGLE_ADD_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_ADD);
    return;
  case SORTED_OBJECT_SORTED_TRIANGLE_BLEND_TRANSPARENCY_ITEM:
    this->setTransparencyType(SoGLRenderAction::SORTED_OBJECT_SORTED_TRIANGLE_BLEND);
    return;
#endif // __COIN__
  default:
    break;
  }

  So@Gui@Viewer::DrawStyle val = So@Gui@Viewer::VIEW_AS_IS;
  switch (menuitemid) {
  case AS_IS_ITEM:
    val = So@Gui@Viewer::VIEW_AS_IS;
    break;
  case HIDDEN_LINE_ITEM:
    val = So@Gui@Viewer::VIEW_HIDDEN_LINE;
    break;
  case WIREFRAME_OVERLAY_ITEM:
    val = So@Gui@Viewer::VIEW_WIREFRAME_OVERLAY;
    break;
  case NO_TEXTURE_ITEM:
    val = So@Gui@Viewer::VIEW_NO_TEXTURE;
    break;
  case LOW_RESOLUTION_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_COMPLEXITY;
    break;
  case WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LINE;
    break;
  case POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_POINT;
    break;
  case BOUNDING_BOX_ITEM:
    val = So@Gui@Viewer::VIEW_BBOX;
    break;

  case MOVE_SAME_AS_STILL_ITEM:
    val = So@Gui@Viewer::VIEW_SAME_AS_STILL;
    break;
  case MOVE_NO_TEXTURE_ITEM:
    val = So@Gui@Viewer::VIEW_NO_TEXTURE;
    break;
  case MOVE_LOW_RES_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_COMPLEXITY;
    break;
  case MOVE_WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LINE;
    break;
  case MOVE_LOW_RES_WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_RES_LINE;
    break;
  case MOVE_POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_POINT;
    break;
  case MOVE_LOW_RES_POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_RES_POINT;
    break;
  case MOVE_BOUNDING_BOX_ITEM:
    val = So@Gui@Viewer::VIEW_BBOX;
    break;

  default:
    assert(0);
    break;
  }

  So@Gui@Viewer::DrawType type = So@Gui@Viewer::STILL;

  switch (menuitemid) {
  case AS_IS_ITEM:
  case HIDDEN_LINE_ITEM:
  case WIREFRAME_OVERLAY_ITEM:
  case NO_TEXTURE_ITEM:
  case LOW_RESOLUTION_ITEM:
  case WIREFRAME_ITEM:
  case POINTS_ITEM:
  case BOUNDING_BOX_ITEM:
    type = So@Gui@Viewer::STILL;
    break;

  case MOVE_SAME_AS_STILL_ITEM:
  case MOVE_NO_TEXTURE_ITEM:
  case MOVE_LOW_RES_ITEM:
  case MOVE_WIREFRAME_ITEM:
  case MOVE_LOW_RES_WIREFRAME_ITEM:
  case MOVE_POINTS_ITEM:
  case MOVE_LOW_RES_POINTS_ITEM:
  case MOVE_BOUNDING_BOX_ITEM:
    type = So@Gui@Viewer::INTERACTIVE;
    break;

  default:
    assert(0);
    break;
  }

  this->setDrawStyle(type, val);
}

// ************************************************************************

// Documented in superclass.
SbBool
So@Gui@FullViewer::processSoEvent(const SoEvent * const ev)
{
  // We're in "interact" mode (ie *not* the camera modification mode),
  // so don't handle the event here. It should either be forwarded to
  // the scenegraph, or caught by So@Gui@Viewer::processSoEvent() if
  // it's an ESC press (to switch modes).
  if (!this->isViewing()) { return inherited::processSoEvent(ev); }

  // Note: with the original SGI InventorXt, the popup menu is also
  // activated by RMB clicks in non-viewing mode. We want to allow RMB
  // clicks to pass through to the scenegraph in non-viewing mode, so
  // we don't copy that behavior.

  if (ev->getTypeId().isDerivedFrom(SoMouseButtonEvent::getClassTypeId())) {
    SoMouseButtonEvent * const e = (SoMouseButtonEvent *) ev;
    if ((e->getButton() == SoMouseButtonEvent::BUTTON2)) {
      if (this->isPopupMenuEnabled()) {
        if (e->getState() == SoButtonEvent::DOWN) {
          this->openPopupMenu(e->getPosition());
        }
        // Steal all RMB-events if the viewer uses the popup-menu.
        return TRUE;
      }
    }
  }

  return inherited::processSoEvent(ev);
}

// *************************************************************************

/*!
  Override this method to provide functionality when the user clicks
  the Help button. Default implementation does nothing.
*/
void
So@Gui@FullViewer::openViewerHelpCard(void)
{
#if SO@GUI@_DEBUG
  SoDebugError::postWarning("So@Gui@FullViewer::openViewerHelpCard",
                            "should be overridden");
#endif // SO@GUI@_DEBUG
}

// *************************************************************************

// FIXME: get rid of this hack and make this file truly
// "generic". 20020109 mortene.
#ifndef __COIN_SOWIN__

// *************************************************************************

// Doc in superclass.
void
So@Gui@FullViewer::setComponentCursor(const So@Gui@Cursor & cursor)
{
  // Overridden to apply the new cursor only for the rendering canvas
  // widget. Otherwise, the default So@Gui@Component
  // setComponentCursor() method will set the cursor for the top-most
  // parent widget, which makes it affect all sub-widgets, like the
  // decorations stuff.

  So@Gui@Component::setWidgetCursor(this->getGLWidget(), cursor);
}

// *************************************************************************

#endif // ! __COIN_SOWIN__
