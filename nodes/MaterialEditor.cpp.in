/**************************************************************************\
 *
 *  This file is part of the Coin family of 3D visualization libraries.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and / or
 *  modify it under the terms of the GNU General Public License
 *  version 2 as published by the Free Software Foundation.  See the
 *  file LICENSE.GPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you desire to use this library in software that is incompatible
 *  with the GNU GPL, and / or you would like to take advantage of the
 *  additional benefits with regard to our support services, please
 *  contact Systems in Motion about acquiring a Coin Professional
 *  Edition License.  See <URL:http://www.coin3d.org> for more
 *  information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

#include <assert.h>

#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/sensors/SoFieldSensor.h>

#include <Inventor/@Gui@/SoAny.h>
#include <Inventor/@Gui@/nodes/SoGuiPane.h>
#include <Inventor/@Gui@/nodes/SoGuiImage.h>
#include <Inventor/@Gui@/nodes/SoGuiSceneTexture2.h>
#include <Inventor/@Gui@/nodes/SoGuiSlider1.h>

#include <Inventor/@Gui@/nodes/SoGuiMaterialEditor.h>

// *************************************************************************

class MaterialEditor {
public:
  MaterialEditor(void);

  SoGuiMaterialEditor * api;

  SoMaterial * material;
  SoGuiSlider1 * slider1;
  SoGuiSlider1 * slider2;
  SoGuiSlider1 * slider3;
  SoGuiSlider1 * slider4;
  SoGuiSlider1 * slider5;
  SoGuiSlider1 * slider6;

  SoFieldSensor * ambient_slider_sensor;
  SoFieldSensor * diffuse_slider_sensor;
  SoFieldSensor * specular_slider_sensor;
  SoFieldSensor * emissive_slider_sensor;
  SoFieldSensor * shininess_slider_sensor;
  SoFieldSensor * transparency_slider_sensor;
  static void ambient_slider_cb(void * closure, SoSensor * sensor);
  static void diffuse_slider_cb(void * closure, SoSensor * sensor);
  static void specular_slider_cb(void * closure, SoSensor * sensor);
  static void emissive_slider_cb(void * closure, SoSensor * sensor);
  static void shininess_slider_cb(void * closure, SoSensor * sensor);
  static void transparency_slider_cb(void * closure, SoSensor * sensor);

  static const char * texturescene[];
  static const char * editorscene[];
};

// *************************************************************************

#define PRIVATE(obj) ((MaterialEditor *) ((SoGuiMaterialEditor *) obj)->internals)

void
SoGuiMaterialEditor::initClass(void)
{
  SO_KIT_INIT_CLASS(SoGuiMaterialEditor, SoBaseKit, SoBaseKit);
}

SO_KIT_SOURCE(SoGuiMaterialEditor);

SoGuiMaterialEditor::SoGuiMaterialEditor(void)
{
  PRIVATE(this) = new MaterialEditor;
  PRIVATE(this)->api = this;

  SO_KIT_CONSTRUCTOR(SoGuiMaterialEditor); 

  SO_KIT_ADD_FIELD(material, (NULL));
  SO_KIT_ADD_FIELD(update, (CONTINUOUS));
      
  SO_KIT_DEFINE_ENUM_VALUE(Update, CONTINUOUS);
  SO_KIT_DEFINE_ENUM_VALUE(Update, AFTER_ACCEPT);

  SO_KIT_SET_SF_ENUM_TYPE(update, Update);

  SO_KIT_ADD_CATALOG_ENTRY(root, SoGuiPane, TRUE, this, "", FALSE);

  SO_KIT_INIT_INSTANCE(); 

  SoNode * scene = SoAny::loadSceneGraph(MaterialEditor::editorscene);
  assert(scene != NULL);
  assert(scene->isOfType(SoGuiPane::getClassTypeId()));
  scene->ref();

  SoGuiImage * sphereimage =
    (SoGuiImage *) SoAny::scanSceneForName(scene, "image");
  assert(sphereimage != NULL);
  scene->unrefNoDelete();
  SbBool ok = this->setAnyPart("root", scene);
  assert(ok);

  PRIVATE(this)->slider1 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider1");
  PRIVATE(this)->slider2 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider2");
  PRIVATE(this)->slider3 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider3");
  PRIVATE(this)->slider4 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider4");
  PRIVATE(this)->slider5 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider5");
  PRIVATE(this)->slider6 = (SoGuiSlider1 *) SoAny::scanSceneForName(scene, "slider6");
  assert(PRIVATE(this)->slider1);
  assert(PRIVATE(this)->slider2);
  assert(PRIVATE(this)->slider3);
  assert(PRIVATE(this)->slider4);
  assert(PRIVATE(this)->slider5);
  assert(PRIVATE(this)->slider6);
  PRIVATE(this)->slider1->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));
  PRIVATE(this)->slider2->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));
  PRIVATE(this)->slider3->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));
  PRIVATE(this)->slider4->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));
  PRIVATE(this)->slider5->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));
  PRIVATE(this)->slider6->setSurfaceColor(SbColor(0,0,0), SbColor(1,1,1));

  SoNode * textureroot = SoAny::loadSceneGraph(MaterialEditor::texturescene);
  assert(textureroot != NULL);
  assert(textureroot->isOfType(SoSeparator::getClassTypeId()));
  SoNode * texture = ((SoSeparator *) textureroot)->getChild(0);
  assert(texture != NULL);
  assert(texture->isOfType(SoGuiSceneTexture2::getClassTypeId()));

  SoNode * subscene = ((SoGuiSceneTexture2 *) texture)->scene.getValue();
  assert(subscene);
  subscene->ref();
  PRIVATE(this)->material = (SoMaterial *) SoAny::scanSceneForName(subscene, "material");
  subscene->unrefNoDelete();
  assert(PRIVATE(this)->material);

  ok = sphereimage->setPart("texture", texture);
  assert(ok);

  /*
  PRIVATE(this)->slider5->value.connectFrom(&(PRIVATE(this)->material->shininess));
  PRIVATE(this)->slider5->value.getValue();
  PRIVATE(this)->material->shininess.connectFrom(&(PRIVATE(this)->slider5->value));
  PRIVATE(this)->slider6->value.connectFrom(&(PRIVATE(this)->material->transparency));
  PRIVATE(this)->slider6->value.getValue();
  PRIVATE(this)->material->transparency.connectFrom(&(PRIVATE(this)->slider6->value));
  */
  // set up sensors

  SoFieldSensor * ambient_slider_sensor;
  SoFieldSensor * diffuse_slider_sensor;
  SoFieldSensor * specular_slider_sensor;
  SoFieldSensor * emissive_slider_sensor;
  SoFieldSensor * shininess_slider_sensor;
  SoFieldSensor * transparency_slider_sensor;

  PRIVATE(this)->ambient_slider_sensor = new SoFieldSensor(MaterialEditor::ambient_slider_cb, PRIVATE(this));
  PRIVATE(this)->diffuse_slider_sensor = new SoFieldSensor(MaterialEditor::diffuse_slider_cb, PRIVATE(this));
  PRIVATE(this)->specular_slider_sensor = new SoFieldSensor(MaterialEditor::specular_slider_cb, PRIVATE(this));
  PRIVATE(this)->emissive_slider_sensor = new SoFieldSensor(MaterialEditor::emissive_slider_cb, PRIVATE(this));
  PRIVATE(this)->shininess_slider_sensor = new SoFieldSensor(MaterialEditor::shininess_slider_cb, PRIVATE(this));
  PRIVATE(this)->transparency_slider_sensor = new SoFieldSensor(MaterialEditor::transparency_slider_cb, PRIVATE(this));
  PRIVATE(this)->ambient_slider_sensor->attach(&(PRIVATE(this)->slider1->value));
  PRIVATE(this)->diffuse_slider_sensor->attach(&(PRIVATE(this)->slider2->value));
  PRIVATE(this)->specular_slider_sensor->attach(&(PRIVATE(this)->slider3->value));
  PRIVATE(this)->emissive_slider_sensor->attach(&(PRIVATE(this)->slider4->value));
  PRIVATE(this)->shininess_slider_sensor->attach(&(PRIVATE(this)->slider5->value));
  PRIVATE(this)->transparency_slider_sensor->attach(&(PRIVATE(this)->slider6->value));
}

SoGuiMaterialEditor::~SoGuiMaterialEditor(void)
{
  MaterialEditor * obj = PRIVATE(this);
  delete obj;
}

#undef PRIVATE

// *************************************************************************
// MaterialEditor
// *************************************************************************

#define PUBLIC(obj) (((MaterialEditor *) obj)->api)

// +--------------------------------------------------------------------+
// |                   |  o x  Ambient    |======================| 0.00 |
// |                   |  o x  Diffuse    |======================| 0.00 |
// |                   |  o x  Specular   |======================| 0.00 |
// |                   |  o x  Emissive   |======================| 0.00 |
// |                   |                                                |
// |                   |       Shininess  |======================| 0.00 |
// |                   |       Transp     |======================| 0.00 |
// +--------------------------------------------------------------------+

const char *
MaterialEditor::texturescene[] =
{
  "#Inventor V2.1 ascii",
  "",
  "SoGuiSceneTexture2 {",
  "  scene",
  "    Separator {",
  "      OrthographicCamera {",
  "        position 0 0 2",
  "        nearDistance 1",
  "        farDistance 3",
  "        height 2",
  "      }",
  "      LightModel { model BASE_COLOR }",
  "      BaseColor {",
  "        rgb [ 0.3 0.3 0.3,  0.6 0.6 0.6,  0.6 0.6 0.6,  0.3 0.3 0.3 ]",
  "      }",
  "      MaterialBinding { value PER_FACE }",
  "      Coordinate3 {",
  "        point [",
  "          -3  3  0,  0  3  0,  3  3  0,",
  "          -3  0  0,  0  0  0,  3  0  0,",
  "          -3 -3  0,  0 -3  0,  3 -3  0",
  "        ]",
  "      }",
  "      QuadMesh {",
  "        verticesPerColumn 3",
  "        verticesPerRow 3",
  "      }",
  "      LightModel { model PHONG }",
  "      DirectionalLight { direction  0.556 -0.623 -0.551 }",
  "      DirectionalLight { direction -0.556 -0.623 -0.551 }",
  "      DEF material Material { }",
  "      Complexity { value 0.8 }",
  "      ShapeHints { vertexOrdering COUNTERCLOCKWISE shapeType SOLID }",
  "      Sphere { radius 0.85 }",
  "    }",
  "  }",
  "}",
  NULL
};

const char *
MaterialEditor::editorscene[] =
{
  "#Inventor V2.1 ascii",
  "",
  "DEF pane SoGuiPane {",
  "  worldSize 1 1 0",
  "  objectSize 550 300 0",
  "  SoGuiPosition {",
  "    position 0 0 0",
  "    = DEF wm Calculator {",
  "      A 0 0 0 = USE pane.objectSize",
  "      expression [",
  "        \"ta = (A[0] / 2 < A[1]) ? (A[0]/2)-20 : A[1]-20\"",
  "        \"tb = (A[1] - ta) / 2\"",
  "        \"oA = vec3f(10, tb, 0)\"", // image position
  "        \"oB = vec3f(ta, ta, 0)\"", // image size
  "        \"oC = vec3f(ta + 30, A[1] - 25, 0)\"", // radio1 position
  "        \"oD = vec3f(0, -30, 0)\"", // ratio translation
  "      ]",
  "    } . oA",
  "  }",
  "  DEF image SoGuiImage { size 0 0 0 = USE wm.oB }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE image.size",
  "    design EMBOSS",
  "    width 2",
  "    complement TRUE",
  "  }",
  "  SoGuiPosition { position 0 0 0 = USE wm.oC }",
  "  DEF rbutton1 SoGuiRadioButton {",
  "    size 10 10 0",
  "    on FALSE",
  "    = DEF rbuttons SoGuiRadioGroup {",
  "      in0 FALSE = USE rbutton1.on",
  "      in1 FALSE = DEF rbutton2 SoGuiRadioButton { size 10 10 0 on FALSE = USE rbuttons.out1 } . on",
  "      in2 FALSE = DEF rbutton3 SoGuiRadioButton { size 10 10 0 on FALSE = USE rbuttons.out2 } . on",
  "      in3 FALSE = DEF rbutton4 SoGuiRadioButton { size 10 10 0 on FALSE = USE rbuttons.out3 } . on",
  "    } . out0",
  "  }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE rbutton1.size",
  "    width 2",
  "    complement FALSE = USE rbutton1.on",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE rbutton2",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE rbutton2.size",
  "    width 2",
  "    complement FALSE = USE rbutton2.on",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE rbutton3",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE rbutton3.size",
  "    width 2",
  "    complement FALSE = USE rbutton3.on",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE rbutton4",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE rbutton4.size",
  "    width 2",
  "    complement FALSE = USE rbutton4.on",
  "  }",
  "  SoGuiPosition {",
  "    position 0 0 0",
  "    = DEF wm2 Calculator {",
  "      A 0 0 0 = USE pane.objectSize",
  "      expression [",
  "        \"ta = (A[0] / 2 < A[1]) ? (A[0]/2)-20 : A[1]-20\"",
  "        \"oA = vec3f(ta + 60, A[1] - 25, 0)\"",
  "        \"oB = vec3f(ta + 90, A[1] - 25, 0)\"",
  "        \"oC = vec3f(ta - 100, 15, 0)\"",
  "      ]",
  "    } . oA",
  "  }",
  "  DEF tbutton1 SoGuiToggleButton {",
  "    size 10 10 0"
  "    on FALSE = USE rbuttons.out0",
  "  }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE tbutton1.size",
  "    width 2",
  "    complement FALSE = USE tbutton1.on",
  "    design EMBOSS",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF tbutton2 SoGuiToggleButton {",
  "    size 10 10 0"
  "    on FALSE = USE rbuttons.out1",
  "  }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE tbutton2.size",
  "    width 2",
  "    complement FALSE = USE tbutton2.on",
  "    design EMBOSS",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF tbutton3 SoGuiToggleButton {",
  "    size 10 10 0"
  "    on FALSE = USE rbuttons.out2",
  "  }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE tbutton3.size",
  "    width 2",
  "    complement FALSE = USE tbutton3.on",
  "    design EMBOSS",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF tbutton4 SoGuiToggleButton {",
  "    size 10 10 0"
  "    on FALSE = USE rbuttons.out3",
  "  }",
  "  SoGuiFrame {",
  "    size 0 0 0 = USE tbutton4.size",
  "    width 2",
  "    complement FALSE = USE tbutton4.on",
  "    design EMBOSS",
  "  }",
  "  SoGuiPosition { position 0 0 0 = USE wm2.oB }",
  "  DEF frame1 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider1 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame1.size",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF frame2 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider2 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame2.size",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF frame3 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider3 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame3.size",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF frame4 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider4 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame4.size",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF frame5 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider5 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame5.size",
  "  }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  DEF frame6 SoGuiFrame {",
  "    size 0 0 0 = USE wm2.oC",
  "    width 2",
  "    complement TRUE",
  "    design EMBOSS",
  "  }",
  "  DEF slider6 SoGuiSlider1 {",
  "    size 0 0 0 = USE frame6.size",
  "  }",

  "  SoGuiPosition { position 0 0 0 = USE pane.objectSize }",
  "  SoGuiTranslation { translation -35 -25 0 }",
  "  DEF labelframe SoGuiFrame { size 25 15 0 width 2 design EMBOSS complement TRUE }",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider1.value } . output }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE labelframe",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider2.value } . output }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE labelframe",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider3.value } . output }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE labelframe",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider4.value } . output }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE labelframe",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider5.value } . output }",
  "  SoGuiTranslation { translation 0 0 0 = USE wm.oD }",
  "  USE labelframe",
  "  SoGuiLabel { text \"\" = SoGuiFormat { format \"%4.2f\" float1 0 = USE slider6.value } . output }",
  "}",
  NULL
};

MaterialEditor::MaterialEditor(void)
{
  this->api = NULL;
  this->slider1 = NULL;
  this->slider2 = NULL;
  this->slider3 = NULL;
  this->slider4 = NULL;
  this->slider5 = NULL;
  this->slider6 = NULL;
  this->ambient_slider_sensor = NULL;
  this->diffuse_slider_sensor = NULL;
  this->specular_slider_sensor = NULL;
  this->emissive_slider_sensor = NULL;
  this->shininess_slider_sensor = NULL;
  this->transparency_slider_sensor = NULL;
}

void
MaterialEditor::ambient_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider1);
  SbColor ambient = me->material->ambientColor.operator[](0);
  float h, s, v;
  ambient.getHSVValue(h, s, v);
  v = me->slider1->value.getValue();
  ambient.setHSVValue(h, s, v);
  me->material->ambientColor.setValue(ambient);
}

void
MaterialEditor::diffuse_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider2);
  SbColor diffuse = me->material->diffuseColor.operator[](0);
  float h, s, v;
  diffuse.getHSVValue(h, s, v);
  v = me->slider2->value.getValue();
  diffuse.setHSVValue(h, s, v);
  me->material->diffuseColor.set1Value(0, diffuse);
}

void
MaterialEditor::specular_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider3);
  SbColor specular = me->material->specularColor.operator[](0);
  float h, s, v;
  specular.getHSVValue(h, s, v);
  v = me->slider3->value.getValue();
  specular.setHSVValue(h, s, v);
  me->material->specularColor.set1Value(0, specular);
}

void
MaterialEditor::emissive_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider4);
  SbColor emissive = me->material->emissiveColor.operator[](0);
  float h, s, v;
  emissive.getHSVValue(h, s, v);
  v = me->slider4->value.getValue();
  emissive.setHSVValue(h, s, v);
  me->material->emissiveColor.set1Value(0, emissive);
}

void
MaterialEditor::shininess_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider5);
  float shininess = me->slider5->value.getValue();
  me->material->shininess.set1Value(0, shininess);
}

void
MaterialEditor::transparency_slider_cb(void * closure, SoSensor * sensor)
{
  assert(closure);
  MaterialEditor * me = (MaterialEditor *) closure;
  assert(me->material);
  assert(me->slider6);
  float transparency = me->slider6->value.getValue();
  me->material->transparency.set1Value(0, transparency);
}

#undef PUBLIC

// *************************************************************************
