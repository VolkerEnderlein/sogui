#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#include <Inventor/SbMatrix.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/bundles/SoMaterialBundle.h>
#include <Inventor/actions/SoGLRenderAction.h>
#include <Inventor/actions/SoPickAction.h>
#include <Inventor/actions/SoRayPickAction.h>
#include <Inventor/actions/SoGetMatrixAction.h>
#include <Inventor/actions/SoGetBoundingBoxAction.h>
#include <Inventor/elements/SoModelMatrixElement.h>
#include <Inventor/misc/SoState.h>
#include <Inventor/misc/SoChildList.h>

#include <Inventor/@Gui@/common/gl.h>

#include <Inventor/@Gui@/nodes/SoGuiPane.h>

// *************************************************************************

class Pane {
public:
  SbMatrix modelmatrix;
  SbVec3f position;
};

// *************************************************************************

#define PRIVATE(obj) ((Pane *) obj->internals)

SO_NODE_SOURCE(SoGuiPane);

void
SoGuiPane::initClass(void)
{
  SO_NODE_INIT_CLASS(SoGuiPane, SoSeparator, SoSeparator);
}

SoGuiPane::SoGuiPane(void)
{
  this->internals = (void *) new Pane;
  SO_NODE_CONSTRUCTOR(SoGuiPane);
  SO_NODE_ADD_FIELD(worldSize, (SbVec3f(1.0f, 1.0f, 0.0f)));
  SO_NODE_ADD_FIELD(objectSize, (SbVec3f(100.0f, 100.0f, 0.0f)));
}

SoGuiPane::~SoGuiPane(void)
{
  Pane * obj = PRIVATE(this);
  delete obj;
  this->internals = NULL;
}

void
SoGuiPane::doAction(SoAction * action)
{
  // SoDebugError::postInfo("SoGuiPane::doAction", "type %s", action->getTypeId().getName().getString());

  SoState * state = action->getState();
  state->push();
  if ( state->isElementEnabled(SoModelMatrixElement::getClassStackIndex()) ) {
    SbVec3f world = this->worldSize.getValue();
    SbVec3f object = this->objectSize.getValue();
    SbVec3f scalefactor(world[0] / object[0], world[1] / object[1], 1.0f);
    SoModelMatrixElement::scaleBy(state, this, scalefactor);
  }
  inherited::doAction(action);
  state->pop();
}

void
SoGuiPane::GLRenderBelowPath(SoGLRenderAction * action)
{
  SoState * state = action->getState();
  state->push();

  SbVec3f world = this->worldSize.getValue();
  SbVec3f object = this->objectSize.getValue();

  // adjust scale for new object space
  SbVec3f scalefactor(world[0] / object[0], world[1] / object[1], 1.0f);
  SoModelMatrixElement::scaleBy(state, this, scalefactor);

  // store current model matrix
  PRIVATE(this)->modelmatrix = SoModelMatrixElement::get(state);
  PRIVATE(this)->position = SbVec3f(0.0f, 0.0f, 0.0f);

  GLint olddepthfunc = 0;
  glGetIntegerv(GL_DEPTH_FUNC, &olddepthfunc);
  glDepthFunc(GL_LEQUAL);

  // what's the deal with the first frame?
  SoMaterialBundle mb(action);
  mb.sendFirst();

  if ( object[0] != 0.0f && object[1] != 0.0f ) {
    // draw pane
    glBegin(GL_QUADS);
    glVertex3f(0.0f, 0.0f, 0.0f);
    glVertex3f(0.0f, object[1], 0.0f);
    glVertex3f(object[0], object[1], 0.0f);
    glVertex3f(object[0], 0.0f, 0.0f);
    glEnd(); // GL_QUADS
  }

  // FIXME: set up clipping planes to go around pane
  //        - useful for placing panes into 3D worlds
  inherited::GLRenderBelowPath(action);

  glDepthFunc((GLenum) olddepthfunc);
  state->pop();
}

void
SoGuiPane::GLRenderInPath(SoGLRenderAction * action)
{
  SoDebugError::postInfo("SoGuiPane::GLRenderInPath", "tidelidu");
  SoState * state = action->getState();
  state->push();

  SbVec3f world = this->worldSize.getValue();
  SbVec3f object = this->objectSize.getValue();

  SoMaterialBundle mb(action);
  mb.sendFirst();

  // draw pane
  glBegin(GL_QUADS);
  glVertex3f(0.0f, 0.0f, 0.0f);
  glVertex3f(0.0f, world[1], 0.0f);
  glVertex3f(world[0], world[1], 0.0f);
  glVertex3f(world[0], 0.0f, 0.0f);
  glEnd(); // GL_QUADS

  // adjust scale for new object space
  SbVec3f scalefactor(world[0] / object[0], world[1] / object[1], 1.0f);
  SoModelMatrixElement::scaleBy(state, this, scalefactor);

  // store current model matrix
  PRIVATE(this)->modelmatrix = SoModelMatrixElement::get(state);
  PRIVATE(this)->position = SbVec3f(0.0f, 0.0f, 0.0f);

  GLint olddepthfunc = 0;
  glGetIntegerv(GL_DEPTH_FUNC, &olddepthfunc);
  glDepthFunc(GL_LEQUAL);

  // FIXME: set up clipping around pane
  inherited::GLRenderInPath(action);

  glDepthFunc((GLenum) olddepthfunc);
  state->pop();
}

void
SoGuiPane::GLRenderOffPath(SoGLRenderAction * action)
{
  // is this one ever invoked?
  SoDebugError::postInfo("SoGuiPane::GLRenderOffPath", "actually invoked");
  inherited::GLRenderOffPath(action);
}

void
SoGuiPane::pick(SoPickAction * action)
{
  this->doAction(action);
}

void
SoGuiPane::rayPick(SoRayPickAction * action)
{
  this->doAction(action);
}

void
SoGuiPane::getMatrix(SoGetMatrixAction * action)
{
  SoDebugError::postInfo("SoGuiPane::getMatrix", "invoked");
  SbVec3f world = this->worldSize.getValue();
  SbVec3f object = this->objectSize.getValue();
  SbVec3f scalefactor(world[0] / object[0], world[1] / object[1], 1.0f);
  SbMatrix matrix = SbMatrix::identity();
  matrix.setScale(scalefactor);
  action->getMatrix().multLeft(matrix);
  // FIXME: update inverse matrix
  inherited::getMatrix(action);
}

void
SoGuiPane::getBoundingBox(SoGetBoundingBoxAction * action)
{
  SoDebugError::postInfo("SoGuiPane::getBB", "invoked");
  this->doAction(action);
}

void
SoGuiPane::moveTo(SoState * state, SbVec3f position)
{
  SbVec3f object = this->objectSize.getValue();
  if ( position[0] < 0.0f ) position[0] = object[0] + position[0];
  if ( position[1] < 0.0f ) position[1] = object[1] + position[1];
  PRIVATE(this)->position = position;
  SbVec3f translation(0.0f, 0.0f, 0.0f);
  translation[0] = PRIVATE(this)->position[0];
  translation[1] = PRIVATE(this)->position[1];
  SoModelMatrixElement::set(state, this, PRIVATE(this)->modelmatrix);
  // SoDebugError::postInfo("SoGuiPane::moveTo", "origo in %g %g", translation[0], translation[1]);
  SoModelMatrixElement::translateBy(state, this, translation);
}

void
SoGuiPane::applyMoveTo(SoGetMatrixAction * action, SbVec3f position)
{
  // FIXME: support negative coordinates
  SoDebugError::postInfo("SoGuiPane::applyMoveTo", "target %g %g", position[0], position[1]);
  action->getMatrix() = PRIVATE(this)->modelmatrix;
  SbMatrix matrix = SbMatrix::identity();
  matrix.setTranslate(position);
  action->getMatrix().multLeft(matrix);
  // FIXME: update inverse matrix
}

void
SoGuiPane::moveBy(SoState * state, SbVec3f offset)
{
  PRIVATE(this)->position += offset;
  SbVec3f translation(0.0f, 0.0f, 0.0f);
  translation[0] = PRIVATE(this)->position[0];
  translation[1] = PRIVATE(this)->position[1];
  SoModelMatrixElement::set(state, this, PRIVATE(this)->modelmatrix);
  // SoDebugError::postInfo("SoGuiPane::moveBy", "origo in %g %g", translation[0], translation[1]);
  SoModelMatrixElement::translateBy(state, this, translation);
}

void
SoGuiPane::applyMoveBy(SoGetMatrixAction * action, SbVec3f offset)
{
  SoDebugError::postInfo("SoGuiPane::applyMoveBy", "offset %g %g", offset[0], offset[1]);
  action->getMatrix() = PRIVATE(this)->modelmatrix;
  SbMatrix matrix = SbMatrix::identity();
  SbVec3f position = PRIVATE(this)->position + offset;
  matrix.setTranslate(position);
  action->getMatrix().multLeft(matrix);
  // FIXME: update inverse matrix
}

