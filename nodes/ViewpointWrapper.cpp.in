/**************************************************************************\
 *
 *  This file is part of the Coin family of 3D visualization libraries.
 *  Copyright (C) 1998-2003 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and / or
 *  modify it under the terms of the GNU General Public License
 *  version 2 as published by the Free Software Foundation.  See the
 *  file LICENSE.GPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you desire to use this library in software that is incompatible
 *  with the GNU GPL, and / or you would like to take advantage of the
 *  additional benefits with regard to our support services, please
 *  contact Systems in Motion about acquiring a Coin Professional
 *  Edition License.  See <URL:http://www.coin3d.org> for more
 *  information.
 *
 *  Systems in Motion, Abels gate 5, Teknobyen, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

#include <Inventor/@Gui@/nodes/SoGuiViewpointWrapper.h>
#include <Inventor/SoPath.h>
#include <Inventor/sensors/SoPathSensor.h>
#include <Inventor/sensors/SoFieldSensor.h>
#include <Inventor/actions/SoGetMatrixAction.h>
#include <Inventor/actions/SoSearchAction.h>
#include <assert.h>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H
#ifdef HAVE_SOVRMLVIEWPOINT
#include <Inventor/VRMLnodes/SoVRMLViewpoint.h>
#endif // HAVE_SOVRMLVIEWPOINT

void
SoGuiViewpointWrapper::initClass(void)
{
  SO_NODE_INIT_CLASS(SoGuiViewpointWrapper, SoPerspectiveCamera, "PerspectiveCamera");
}

SO_NODE_SOURCE(SoGuiViewpointWrapper);

SoGuiViewpointWrapper::SoGuiViewpointWrapper(void)
{
  SO_NODE_CONSTRUCTOR(SoGuiViewpointWrapper);
  this->pathtoviewpoint = NULL;
  this->positionsensor = new SoFieldSensor(fieldsensor_cb, this);
  this->orientationsensor = new SoFieldSensor(fieldsensor_cb, this);
  this->heightanglesensor = new SoFieldSensor(fieldsensor_cb, this);
  this->pathsensor = new SoPathSensor(pathsensor_cb, this);
  this->attachFieldSensors();
  this->gmaction = new SoGetMatrixAction(SbViewportRegion(100, 100));
}

SoGuiViewpointWrapper::~SoGuiViewpointWrapper(void)
{
  this->pathsensor->detach();
  delete this->pathsensor;
  if (this->pathtoviewpoint) this->pathtoviewpoint->unref();
  this->detachFieldSensors();
  delete this->positionsensor;
  delete this->orientationsensor;
  delete this->heightanglesensor;
  delete this->gmaction;
}

void 
SoGuiViewpointWrapper::setViewpoint(SoPath * path)
{
  if (this->pathtoviewpoint) {
    this->pathtoviewpoint->unref();
    this->pathsensor->detach();
  }
  this->pathtoviewpoint = (SoFullPath*) path;
  if (path) {
    path->ref();
    this->pathsensor->attach(path); 
    this->updateCamera();
  }
}

void 
SoGuiViewpointWrapper::updateCamera(void)
{
#ifdef HAVE_SOVRMLVIEWPOINT
  if (this->pathtoviewpoint == NULL) return;

  this->detachFieldSensors();

  SoVRMLViewpoint * vp = (SoVRMLViewpoint*)
    this->pathtoviewpoint->getTail();
  assert(vp->getTypeId() == SoVRMLViewpoint::getClassTypeId());
  
  this->gmaction->apply(this->pathtoviewpoint);
  SbVec3f pos = vp->position.getValue();
  float angle = vp->fieldOfView.getValue();

  SbRotation rot = vp->orientation.getValue();
  SbMatrix m;
  m.setRotate(rot);  
  this->gmaction->getMatrix().multVecMatrix(pos, pos);
  m.multRight(this->gmaction->getInverse());
  m.multLeft(this->gmaction->getMatrix());
  rot.setValue(m);
  
  this->position = pos;
  this->orientation = rot;
  this->heightAngle = angle;

  this->attachFieldSensors();
#endif // HAVE_SOVRMLVIEWPOINT
}

void
SoGuiViewpointWrapper::updateViewpoint(void)
{
#ifdef HAVE_SOVRMLVIEWPOINT
  if (this->pathtoviewpoint == NULL) return;
  this->pathsensor->detach();
  
  SoVRMLViewpoint * vp = (SoVRMLViewpoint*)
    this->pathtoviewpoint->getTail();
  assert(vp->getTypeId() == SoVRMLViewpoint::getClassTypeId());
  
  this->gmaction->apply(this->pathtoviewpoint);
  SbVec3f pos = this->position.getValue();
  float angle = this->heightAngle.getValue();

  SbRotation rot = this->orientation.getValue();
  SbMatrix m;
  m.setRotate(rot);  
  this->gmaction->getInverse().multVecMatrix(pos, pos);
  m.multRight(this->gmaction->getMatrix());
  m.multLeft(this->gmaction->getInverse());
  rot.setValue(m);
  
  vp->position = pos;
  vp->orientation = rot;
  vp->fieldOfView = angle;

  this->pathsensor->attach(this->pathtoviewpoint); 
#endif // HAVE_SOVRMLVIEWPOINT
}

void 
SoGuiViewpointWrapper::attachFieldSensors(void)
{
  this->positionsensor->attach(&this->position);
  this->orientationsensor->attach(&this->orientation);
  this->heightanglesensor->attach(&this->heightAngle);
}

void 
SoGuiViewpointWrapper::detachFieldSensors(void)
{
  this->positionsensor->detach();
  this->orientationsensor->detach();
  this->heightanglesensor->detach();
}

void 
SoGuiViewpointWrapper::fieldsensor_cb(void * data, SoSensor * sensor)
{
  SoGuiViewpointWrapper * thisp = (SoGuiViewpointWrapper *) data;
  thisp->updateViewpoint();
}

void 
SoGuiViewpointWrapper::pathsensor_cb(void * data, SoSensor * sensor)
{
  SoGuiViewpointWrapper * thisp = (SoGuiViewpointWrapper *) data;
  thisp->updateCamera();
}

SbBool 
SoGuiViewpointWrapper::hasViewpoints(SoNode * root)
{
#ifdef HAVE_SOVRMLVIEWPOINT
  SoSearchAction sa;
  sa.setInterest(SoSearchAction::ALL);
  sa.setType(SoVRMLViewpoint::getClassTypeId());
  sa.apply(root);
  return sa.getPaths().getLength() > 0;
#else // HAVE_SOVRMLVIEWPOINT
  return FALSE;
#endif // ! HAVE_SOVRMLVIEWPOINT
}

void
SoGuiViewpointWrapper::setSceneGraph(SoNode * root)
{
#ifdef HAVE_SOVRMLVIEWPOINT
  this->nodelist.truncate(0);
  this->setViewpoint(NULL);
  
  SoSearchAction sa;
  sa.setInterest(SoSearchAction::ALL);
  sa.setType(SoVRMLViewpoint::getClassTypeId());
  sa.apply(root);
  SoPathList & pl = sa.getPaths();
  if (pl.getLength()) {
    for (int i = 0; i < pl.getLength(); i++) {
      SoFullPath * p = (SoFullPath*) pl[i];
      if (p->getTail()->isOfType(SoVRMLViewpoint::getClassTypeId())) {
        this->nodelist.append(p->getTail());
      }
    }
    this->setViewpoint(pl[0]);
  }
#endif // HAVE_SOVRMLVIEWPOINT
}
