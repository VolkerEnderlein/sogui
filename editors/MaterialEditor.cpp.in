
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/VRMLnodes/SoVRMLMaterial.h>
#include <Inventor/sensors/SoNodeSensor.h>

#include <Inventor/@Gui@/SoAny.h>
#include <Inventor/@Gui@/nodes/SoGuiMaterialEditor.h>
#include <Inventor/@Gui@/editors/So@Gui@MaterialEditor.h>

// *************************************************************************

class MaterialEditorComponent {
public:
  MaterialEditorComponent(void);
  ~MaterialEditorComponent(void);

  SoNodeSensor * attachment;
  SoGuiMaterialEditor * editor;

  SoMaterial * dummy;

  SbPList * callbacks;

  static SoSeparator * getSuperScene(void);
  static SoNode * getSceneGraph(void);
  static const char * superscene[];
};

// *************************************************************************

#define PRIVATE(obj) ((MaterialEditorComponent *) obj->internals)

SO@GUI@_OBJECT_SOURCE(So@Gui@MaterialEditor);

So@Gui@MaterialEditor::So@Gui@MaterialEditor(@WIDGET@ parent, const char * name, SbBool embed)
  : inherited(parent, name, embed)
{
  this->internals = new MaterialEditorComponent;
  this->setSize(SbVec2s(550,300));
  SoNode * scene = MaterialEditorComponent::getSceneGraph();
  this->setSceneGraph(scene);
  assert(scene->isOfType(SoSeparator::getClassTypeId()));
  PRIVATE(this)->editor = (SoGuiMaterialEditor *) ((SoSeparator *) scene)->getChild(((SoSeparator *) scene)->getNumChildren()-1);
  assert(PRIVATE(this)->editor->isOfType(SoGuiMaterialEditor::getClassTypeId()));
}

So@Gui@MaterialEditor::So@Gui@MaterialEditor(@WIDGET@ parent, const char * const name, SbBool embed, SbBool build)
: inherited(parent, name, embed)
{
  this->internals = new MaterialEditorComponent;
  this->setSize(SbVec2s(550,300));
  SoNode * scene = MaterialEditorComponent::getSceneGraph();
  this->setSceneGraph(scene);
  assert(scene->isOfType(SoSeparator::getClassTypeId()));
  PRIVATE(this)->editor = (SoGuiMaterialEditor *) ((SoSeparator *) scene)->getChild(((SoSeparator *) scene)->getNumChildren()-1);
  assert(PRIVATE(this)->editor->isOfType(SoGuiMaterialEditor::getClassTypeId()));
}

So@Gui@MaterialEditor::~So@Gui@MaterialEditor(void)
{
  assert(PRIVATE(this)->editor);
  if ( PRIVATE(this)->dummy ) PRIVATE(this)->dummy->unref();
  MaterialEditorComponent * obj = PRIVATE(this);
  delete obj;
}

void
So@Gui@MaterialEditor::attach(SoMaterial * material, int index)
{
  assert(PRIVATE(this)->editor);
  PRIVATE(this)->editor->material.setValue(material);
  PRIVATE(this)->editor->index.setValue(index);
}

void
So@Gui@MaterialEditor::attach(SoVRMLMaterial * material)
{
  assert(PRIVATE(this)->editor);
  PRIVATE(this)->editor->material.setValue(material);
}

void
So@Gui@MaterialEditor::detach(void)
{
  PRIVATE(this)->editor->material.setValue(NULL);
}

SbBool
So@Gui@MaterialEditor::isAttached(void)
{
  assert(PRIVATE(this)->editor != NULL);
  return (PRIVATE(this)->editor->material.getValue() != NULL) ? TRUE : FALSE;
}

void
So@Gui@MaterialEditor::addMaterialChangedCallback(So@Gui@MaterialEditorCB * callback, void * closure)
{
}

void
So@Gui@MaterialEditor::removeMaterialChangedCallback(So@Gui@MaterialEditorCB * callback, void * closure)
{
}

void
So@Gui@MaterialEditor::setUpdateFrequency(So@Gui@MaterialEditor::UpdateFrequency frequency)
{
}

So@Gui@MaterialEditor::UpdateFrequency
So@Gui@MaterialEditor::getUpdateFrequency(void) const
{
  return CONTINUOUS;
}

void
So@Gui@MaterialEditor::setMaterial(const SoMaterial & material)
{
  // PRIVATE(this)->material->copyFrom(material);
}

void
So@Gui@MaterialEditor::setMaterial(const SoVRMLMaterial & material)
{
  // PRIVATE(this)->material->copyFrom(material);
}

const SoMaterial &
So@Gui@MaterialEditor::getMaterial(void) const
{
  PRIVATE(this)->dummy = new SoMaterial;
  PRIVATE(this)->dummy->ref();
  // FIXME: update values
  return *(PRIVATE(this)->dummy);
}

SbBool
So@Gui@MaterialEditor::isAttachedVRML(void)
{
  SoNode * material = PRIVATE(this)->editor->material.getValue();
  return (material && material->isOfType(SoVRMLMaterial::getClassTypeId())) ? TRUE : FALSE;
}

const char *
So@Gui@MaterialEditor::getDefaultWidgetName(void) const
{
  static const char widgetName[] = "So@Gui@MaterialEditor";
  return widgetName;
}

const char *
So@Gui@MaterialEditor::getDefaultTitle(void) const
{
  static const char title[] = "MaterialEditor";
  return title;
}

const char *
So@Gui@MaterialEditor::getDefaultIconTitle(void) const
{
  static const char iconTitle[] = "MatEd";
  return iconTitle;
}

#undef PRIVATE

// *************************************************************************
// MaterialEditorComponent
// *************************************************************************

#define PUBLIC(obj)  (obj->api)

const char *
MaterialEditorComponent::superscene[] =
{
  "#Inventor V2.1 ascii",
  "",
  "Separator {",
  "  DirectionalLight { direction 0 0 -1 color 1 1 1 intensity 0.8 }",
  "  OrthographicCamera { }",
  "  DEF viewportfix SoGuiViewportFix { }",
  "  Material { ambientColor 0.8 0.8 0.8 }",
  "}",
  NULL
};

// *************************************************************************

MaterialEditorComponent::MaterialEditorComponent(void)
{
  this->attachment = NULL;
  this->editor = NULL;
  this->callbacks = NULL;
  this->dummy = NULL;
}

MaterialEditorComponent::~MaterialEditorComponent(void)
{
  if ( this->attachment != NULL ) {
    delete this->attachment;
  }
  if ( this->callbacks != NULL )
    delete this->callbacks;
}

SoSeparator *
MaterialEditorComponent::getSuperScene(void)
{
  SoNode * root = SoAny::loadSceneGraph(MaterialEditorComponent::superscene);
  assert(root != NULL);
  assert(root->isOfType(SoSeparator::getClassTypeId()));
  return (SoSeparator *) root;
}

SoNode *
MaterialEditorComponent::getSceneGraph(void)
{
  SoSeparator * root = MaterialEditorComponent::getSuperScene();
  assert(root != NULL);
  // FIXME: route ViewportFix field value into editor
  root->addChild(new SoGuiMaterialEditor);
  return root;
}

#undef PUBLIC

// *************************************************************************
