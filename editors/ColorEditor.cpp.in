/**************************************************************************\
 *
 *  This file is part of the Coin family of 3D visualization libraries.
 *  Copyright (C) 1998-2002 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and / or
 *  modify it under the terms of the GNU General Public License
 *  version 2 as published by the Free Software Foundation.  See the
 *  file LICENSE.GPL at the root directory of this source distribution
 *  for more details.
 *
 *  If you desire to use this library in software that is incompatible
 *  with the GNU GPL, and / or you would like to take advantage of the
 *  additional benefits with regard to our support services, please
 *  contact Systems in Motion about acquiring a Coin Professional
 *  Edition License.  See <URL:http://www.coin3d.org> for more
 *  information.
 *
 *  Systems in Motion, Prof Brochs gate 6, 7030 Trondheim, NORWAY
 *  <URL:http://www.sim.no>, <mailto:support@sim.no>
 *
\**************************************************************************/

// FIXME: overload the getClassName() type functions

#include <Inventor/SbPList.h>
#include <Inventor/SoSceneManager.h>
#include <Inventor/fields/SoSFColor.h>
#include <Inventor/fields/SoMFColor.h>
#include <Inventor/fields/SoMFUInt32.h>
#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/sensors/SoFieldSensor.h>
#include <Inventor/actions/SoGLRenderAction.h>

#include <Inventor/@Gui@/SoAny.h>

#include <Inventor/@Gui@/nodes/SoGuiViewportFix.h>
#include <Inventor/@Gui@/nodes/SoGuiPane.h>
#include <Inventor/@Gui@/nodes/SoGuiClickCounter.h>
#include <Inventor/@Gui@/nodes/SoGuiSlider1.h>

#include <Inventor/@Gui@/editors/So@Gui@ColorEditor.h>

/*!
  \class So@Gui@ColorEditor Inventor/@Gui@/editors/So@Gui@ColorEditor.h
  \brief The So@Gui@ColorEditor class is a GUI component for interactively
  editing color fields.
*/

/*!
  \enum So@Gui@ColorEditor::Sliders
*/

/*!
  \val So@Gui@ColorEditor::NONE
*/

/*!
  \val So@Gui@ColorEditor::INTENSITY
*/

/*!
  \val So@Gui@ColorEditor::RGB
*/

/*!
  \val So@Gui@ColorEditor::HSV
*/

/*!
  \val So@Gui@ColorEditor::RGB_V
*/

/*!
  \val So@Gui@ColorEditor::RGB_HSV
*/

/*!
  \enum So@Gui@ColorEditor::UpdateFrequency
*/

/*!
  \val So@Gui@ColorEditor::CONTINUOUS
*/

/*!
  \val So@Gui@ColorEditor::AFTER_ACCEPT
*/

// *************************************************************************

static const SbBool SGI_ATTACHMENT_REF_COMPATIBILITY = TRUE;

enum Attachment {
  DETACHED,
  SFCOLOR,
  MFCOLOR,
  MFUINT32
};

class ColorEditor {
public:
  So@Gui@ColorEditor * api;

  SbPList callbacks;

  SbColor color;
  SbBool wysiwyg;
  So@Gui@ColorEditor::Sliders sliders;
  So@Gui@ColorEditor::UpdateFrequency update;

  // attachment is redundant - the existence of the field sensor, and the
  // field type it is attached to is all the info needed really
  Attachment attachment;
  // the field pointers can actually be dropped since the sensor will have
  // that info
  SoSFColor * sfcolor;
  SoMFColor * mfcolor;
  SoMFUInt32 * mfuint32;
  int mfindex;
  SoFieldSensor * sensor;

  SbBool updating;

  void attachedToColor(const SbColor & color);
  void colorChange(void);
  static void update_cb(void * closure, SoSensor * sensor);
  static void delete_cb(void * closure, SoSensor * sensor);

  SoGuiPane * editor;
  SoGuiClickCounter * switcher;
  SoGuiSlider1 * slider_r; // red
  SoGuiSlider1 * slider_g; // green
  SoGuiSlider1 * slider_b; // blue
  SoGuiSlider1 * slider_h; // hue
  SoGuiSlider1 * slider_s; // saturation
  SoGuiSlider1 * slider_v; // value

  SoFieldSensor * sensor_r;
  SoFieldSensor * sensor_g;
  SoFieldSensor * sensor_b;
  SoFieldSensor * sensor_h;
  SoFieldSensor * sensor_s;
  SoFieldSensor * sensor_v;

  static void update_r_cb(void * closure, SoSensor * sensor);
  static void update_g_cb(void * closure, SoSensor * sensor);
  static void update_b_cb(void * closure, SoSensor * sensor);
  static void update_h_cb(void * closure, SoSensor * sensor);
  static void update_s_cb(void * closure, SoSensor * sensor);
  static void update_v_cb(void * closure, SoSensor * sensor);

  static const char * superscene[];
  static const char * editorscene[];
};

const char *
ColorEditor::superscene[] =
{
  "#Inventor V2.1 ascii",
  "",
  "Separator {",
  "  DirectionalLight { direction 0 0 -1 color 1 1 1 intensity 0.8 }",
  "  OrthographicCamera { }",
  "  DEF viewportfix SoGuiViewportFix { }",
  "  Material { ambientColor 0.8 0.8 0.8 }",
  "}",
  NULL
};

const char *
ColorEditor::editorscene[] = {
  "#Inventor V2.1 ascii",
  "",
  "DEF pane SoGuiPane {",
  "  worldSize 1 1 0",
  "  objectSize 1 1 0",
  "  SoGuiPosition {",
  "    position 0 0 0",
  "    = DEF windowgeometry Calculator {",
  "      A 0 0 0 = USE pane.objectSize",
  "      expression [",
  "        \"ta = floor(A[1] / 14)\"",                    // slider height
  "        \"tb = floor(((A[1] / 2) - (4 * ta)) / 5)\"",  // inter-slider height
  "        \"oA = vec3f(tb, A[1] - 20 - tb, 0)\"",        // clickcounter pos
  "        \"oB = vec3f(A[0] - 100, A[1] - 100, 0)\"",    // colorwheel pos
  "      ]",
  "    } . oA",
  "  }",
  "  DEF switcher SoGuiClickCounter {",
  "    size 50 20 0",
  "    first 2", // the INTENSITY sliders
  "    last 6",  // the RGB_HSV sliders
  "    value 5", // start with the RGB_V group
  "  }",
#if 0
  "  SoGuiPosition { position 0 0 0 = USE windowgeometry.oB }",
  "  DEF slider_wheel SoGuiSlider2 {",
  "    size 80 80 0",
  "  }",
#endif
  // the bottom-left positioning of sliders is done right here (position = [...] . oB)
  "  SoGuiPosition {",
  "    position 0 0 0",
  "    = DEF slidergeometry Calculator {",
  "      A 0 0 0 = USE pane.objectSize",
  "      expression [", // hehe :)
  "        \"ta = floor(A[1] / 14)\"",                    // slider height
  "        \"tb = floor(((A[1] / 2) - (4 * ta)) / 5)\"",  // inter-slider height
  "        \"oA = vec3f(A[0] - (tb * 2), ta, 0)\"",       // slider size
  "        \"oB = vec3f(tb, tb, 0)\"",                    // slider pos
  "        \"oC = vec3f(0, ta + tb, 0)\"",                // slider translation
  "      ]",
  "    } . oB",
  "  }",
  "  Switch {",
  "    whichChild -1 = USE switcher.value",
  "    DEF instances Group {", // never to be rendered...
  "      DEF slider_r SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_g SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_b SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_h SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_s SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_v SoGuiSlider1 { size 200 8 0 = USE slidergeometry.oA }",
  "      DEF slider_translation SoGuiTranslation { translation 0 0 0 = USE slidergeometry.oC }"
  "      DEF slider_frame SoGuiFrame { areaSize 0 0 0 = USE slidergeometry.oA design EMBOSS }",
  "    }",
  "    DEF sliders_NONE Group {", // in case we search for names once, instead of indexing
  "    }",                        // children directly inside setCurrentSliders()
  "    DEF sliders_INTENSITY Group {",
  "      USE slider_frame", // frames before sliders - the knobs must paint over frames
  "      USE slider_v",
  "    }",
  "    DEF sliders_RGB Group {",
  "      USE slider_frame",
  "      USE slider_b",
  "      USE slider_translation",
  "      USE slider_frame",
  "      USE slider_g",
  "      USE slider_translation",
  "      USE slider_frame",
  "      USE slider_r",
  "    }",
  "    DEF sliders_HSV Group {",
  "      USE slider_frame",
  "      USE slider_v",
  "      USE slider_translation",
  "      USE slider_frame",
  "      USE slider_s",
  "      USE slider_translation",
  "      USE slider_frame",
  "      USE slider_h",
  "    }",
  "    DEF sliders_RGB_V Group {",
  "      USE sliders_INTENSITY",
  "      USE slider_translation",
  "      USE sliders_RGB",
  "    }",
  "    DEF sliders_RGB_HSV Group {",
  "      USE sliders_HSV",
  "      USE slider_translation",
  "      USE sliders_RGB",
  "    }",
  "  } # Switch",
  "} # Pane pane",
  NULL
};

// *************************************************************************

#define PRIVATE(obj) ((ColorEditor *) ((So@Gui@ColorEditor *) obj)->internals)
#define PUBLIC(obj) (((ColorEditor *) obj)->api)

So@Gui@ColorEditor::So@Gui@ColorEditor(@WIDGET@ parent, const char * name, SbBool embed)
  : inherited(parent, name, embed)
{
  this->internals = (void *) new ColorEditor;
  PRIVATE(this)->api = this;
  PRIVATE(this)->wysiwyg = FALSE;
  PRIVATE(this)->color = SbColor(0, 0, 0);
  PRIVATE(this)->sliders = NONE;
  PRIVATE(this)->update = AFTER_ACCEPT;

  PRIVATE(this)->attachment = DETACHED;
  PRIVATE(this)->sensor = NULL;
  PRIVATE(this)->sfcolor = NULL;
  PRIVATE(this)->sfcolor = NULL;
  PRIVATE(this)->mfcolor = NULL;
  PRIVATE(this)->mfuint32 = NULL;
  PRIVATE(this)->mfindex = 0;

  PRIVATE(this)->updating = FALSE;
  PRIVATE(this)->switcher = NULL;
  PRIVATE(this)->sensor_r = NULL;
  PRIVATE(this)->sensor_g = NULL;
  PRIVATE(this)->sensor_b = NULL;
  PRIVATE(this)->sensor_h = NULL;
  PRIVATE(this)->sensor_s = NULL;
  PRIVATE(this)->sensor_v = NULL;

  PRIVATE(this)->editor = NULL;

  this->setSize(SbVec2s(320, 256));

  SoNode * scene = SoAny::loadSceneGraph(ColorEditor::editorscene);
  assert(scene != NULL);
  assert(scene->isOfType(SoGuiPane::getClassTypeId()));

  PRIVATE(this)->editor = (SoGuiPane *) scene;
  PRIVATE(this)->editor->ref();
  PRIVATE(this)->switcher = (SoGuiClickCounter *) SoAny::scanSceneForName(PRIVATE(this)->editor, "switcher");
  PRIVATE(this)->slider_r = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_r", TRUE);
  PRIVATE(this)->slider_g = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_g", TRUE);
  PRIVATE(this)->slider_b = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_b", TRUE);
  PRIVATE(this)->slider_h = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_h", TRUE);
  PRIVATE(this)->slider_s = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_s", TRUE);
  PRIVATE(this)->slider_v = (SoGuiSlider1 *) SoAny::scanSceneForName(PRIVATE(this)->editor, "slider_v", TRUE);
  if ( PRIVATE(this)->slider_r ) {
    PRIVATE(this)->slider_r->ref();
    PRIVATE(this)->slider_r->setSurfaceColor(SbColor(0, 0, 0), SbColor(1, 0, 0));
    PRIVATE(this)->sensor_r = new SoFieldSensor(ColorEditor::update_r_cb, PRIVATE(this));
    // priority 0 is a must for the this->updating test to be able to break loops
    PRIVATE(this)->sensor_r->setPriority(0);
    PRIVATE(this)->sensor_r->attach(&(PRIVATE(this)->slider_r->value));
  }
  if ( PRIVATE(this)->slider_g ) {
    PRIVATE(this)->slider_g->ref();
    PRIVATE(this)->slider_g->setSurfaceColor(SbColor(0, 0, 0), SbColor(0, 1, 0));
    PRIVATE(this)->sensor_g = new SoFieldSensor(ColorEditor::update_g_cb, PRIVATE(this));
    PRIVATE(this)->sensor_g->setPriority(0);
    PRIVATE(this)->sensor_g->attach(&(PRIVATE(this)->slider_g->value));
  }
  if ( PRIVATE(this)->slider_b ) {
    PRIVATE(this)->slider_b->ref();
    PRIVATE(this)->slider_b->setSurfaceColor(SbColor(0, 0, 0), SbColor(0, 0, 1));
    PRIVATE(this)->sensor_b = new SoFieldSensor(ColorEditor::update_b_cb, PRIVATE(this));
    PRIVATE(this)->sensor_b->setPriority(0);
    PRIVATE(this)->sensor_b->attach(&(PRIVATE(this)->slider_b->value));
  }
  if ( PRIVATE(this)->slider_h ) {
    PRIVATE(this)->slider_h->ref();
    PRIVATE(this)->slider_h->setSurfaceColor(SbColor(0, 0, 0), SbColor(1, 1, 1));
    PRIVATE(this)->sensor_h = new SoFieldSensor(ColorEditor::update_h_cb, PRIVATE(this));
    PRIVATE(this)->sensor_h->setPriority(0);
    PRIVATE(this)->sensor_h->attach(&(PRIVATE(this)->slider_h->value));
  }
  if ( PRIVATE(this)->slider_s ) {
    PRIVATE(this)->slider_s->ref();
    PRIVATE(this)->slider_s->setSurfaceColor(SbColor(0, 0, 0), SbColor(1, 1, 1));
    PRIVATE(this)->sensor_s = new SoFieldSensor(ColorEditor::update_s_cb, PRIVATE(this));
    PRIVATE(this)->sensor_s->setPriority(0);
    PRIVATE(this)->sensor_s->attach(&(PRIVATE(this)->slider_s->value));
  }
  if ( PRIVATE(this)->slider_v ) {
    PRIVATE(this)->slider_v->ref();
    PRIVATE(this)->slider_v->setSurfaceColor(SbColor(0, 0, 0), SbColor(1, 1, 1));
    PRIVATE(this)->sensor_v = new SoFieldSensor(ColorEditor::update_v_cb, PRIVATE(this));
    PRIVATE(this)->sensor_v->setPriority(0);
    PRIVATE(this)->sensor_v->attach(&(PRIVATE(this)->slider_v->value));
  }
  this->setSceneGraph(PRIVATE(this)->editor);
  PRIVATE(this)->editor->unref();

  SoGuiViewportFix * viewportfix = (SoGuiViewportFix *) SoAny::scanSceneForName(inherited::getSceneGraph(), "viewportfix", FALSE);
  assert(viewportfix != NULL);
  PRIVATE(this)->editor->objectSize.connectFrom(&(viewportfix->viewportSize));
}

So@Gui@ColorEditor::~So@Gui@ColorEditor(void)
{
  this->setSceneGraph(NULL);
  this->detach();
  ColorEditor * instance = PRIVATE(this);
  delete instance;
}

/*!
  Attach the editor to a color single field.  Any existing attachments are
  detached.

  The node argument defaults to NULL and is ignored.  It is part of the
  argument list for compatibility reasons.
*/

void
So@Gui@ColorEditor::attach(SoSFColor * color, SoBase * node)
{
  if ( PRIVATE(this)->attachment != DETACHED )
    this->detach();
  if ( color != NULL ) {
    if ( SGI_ATTACHMENT_REF_COMPATIBILITY ) {
      SoFieldContainer * container = color->getContainer();
      if ( container != NULL ) container->ref();
    }
    PRIVATE(this)->attachment = SFCOLOR;
    PRIVATE(this)->sfcolor = color;
    assert(PRIVATE(this)->sensor == NULL);
    PRIVATE(this)->sensor = new SoFieldSensor(ColorEditor::update_cb, PRIVATE(this));
    PRIVATE(this)->sensor->setDeleteCallback(ColorEditor::delete_cb, PRIVATE(this));
    // FIXME: sensor priority?
    PRIVATE(this)->sensor->attach(color);
    PRIVATE(this)->attachedToColor(color->getValue());
  }
}

/*!
  Attach the editor to an element in a color multi field.  Any existing attachments are
  detached.
  
  The node argument defaults to NULL and is ignored.  It is part of the
  argument list for compatibility reasons.
*/

void
So@Gui@ColorEditor::attach(SoMFColor * color, int idx, SoBase * node)
{
  if ( PRIVATE(this)->attachment != DETACHED )
    this->detach();
  if ( color != NULL ) {
    if ( SGI_ATTACHMENT_REF_COMPATIBILITY ) {
      SoFieldContainer * container = color->getContainer();
      if ( container != NULL ) container->ref();
    }
    PRIVATE(this)->attachment = MFCOLOR;
    PRIVATE(this)->mfcolor = color;
    PRIVATE(this)->mfindex = idx;
    assert(PRIVATE(this)->sensor == NULL);
    PRIVATE(this)->sensor = new SoFieldSensor(ColorEditor::update_cb, PRIVATE(this));
    PRIVATE(this)->sensor->setDeleteCallback(ColorEditor::delete_cb, PRIVATE(this));
    // FIXME: sensor priority?
    PRIVATE(this)->sensor->attach(color);
    PRIVATE(this)->attachedToColor(color->operator[](idx));
  }
}

/*!
  Attach the editor to an element in an uint32 multi field.  The field
  is assumed to be of the RGBA packed color format.  Any existing attachments are
  detached.
  
  The node argument defaults to NULL and is ignored.  It is part of the
  argument list for compatibility reasons.
*/

void
So@Gui@ColorEditor::attach(SoMFUInt32 * color, int idx, SoBase * node)
{
  if ( PRIVATE(this)->attachment != DETACHED )
    this->detach();
  if ( color != NULL ) {
    if ( SGI_ATTACHMENT_REF_COMPATIBILITY ) {
      SoFieldContainer * container = color->getContainer();
      if ( container != NULL ) container->ref();
    }
    PRIVATE(this)->attachment = MFUINT32;
    PRIVATE(this)->mfuint32 = color;
    PRIVATE(this)->mfindex = idx;
    assert(PRIVATE(this)->sensor == NULL);
    PRIVATE(this)->sensor = new SoFieldSensor(ColorEditor::update_cb, PRIVATE(this));
    PRIVATE(this)->sensor->setDeleteCallback(ColorEditor::delete_cb, PRIVATE(this));
    // FIXME: sensor priority?
    PRIVATE(this)->sensor->attach(color);
    SbColor col;
    float transparency;
    col.setPackedValue(color->operator[](idx), transparency);
    PRIVATE(this)->attachedToColor(col);
  }
}

/*!
  Detach the editor from the field it is attached to.
*/

void
So@Gui@ColorEditor::detach(void)
{
  if ( PRIVATE(this)->attachment != DETACHED ) {
    SoField * field = NULL;
    switch ( PRIVATE(this)->attachment ) {
    case SFCOLOR:
      field = PRIVATE(this)->sfcolor;
      break;
    case MFCOLOR:
      field = PRIVATE(this)->mfcolor;
      break;
    case MFUINT32:
      field = PRIVATE(this)->mfuint32;
      break;
    case DETACHED:
      assert(0 && "DETACHED impossible");
      break;
    }
    assert(field != NULL);
    if ( field != NULL ) {
      assert(PRIVATE(this)->sensor != NULL);
      PRIVATE(this)->sensor->detach();
      delete PRIVATE(this)->sensor;
      PRIVATE(this)->sensor = NULL;
      if ( SGI_ATTACHMENT_REF_COMPATIBILITY ) {
        SoFieldContainer * container = field->getContainer();
        if ( container != NULL ) container->ref();
      }
    }
    PRIVATE(this)->attachment = DETACHED;
  }
}

/*!
  This method returns whether or not the editor is currently attached to a field.
*/

SbBool
So@Gui@ColorEditor::isAttached(void) const
{
  return (PRIVATE(this)->attachment != DETACHED) ? TRUE : FALSE;
}

/*
  Add a callback to be triggered when the color value is changed.

  \sa So@Gui@ColorEditor::setUpdateFrequency
*/

void
So@Gui@ColorEditor::addColorChangedCallback(So@Gui@ColorEditorCB * callback, void * closure)
{
  PRIVATE(this)->callbacks.append((void *) callback);
  PRIVATE(this)->callbacks.append(closure);
}

/*!
  Remove all color change callbacks matching the given arguments.
*/

void
So@Gui@ColorEditor::removeColorChangedCallback(So@Gui@ColorEditorCB * callback, void * closure)
{
  const int len = PRIVATE(this)->callbacks.getLength();
  int i;
  for ( i = 0; i < len; i += 2 ) {
    So@Gui@ColorEditorCB * cb =
      (So@Gui@ColorEditorCB *) PRIVATE(this)->callbacks[i];
    if ( (callback == cb) && (closure == PRIVATE(this)->callbacks[i+1]) ) {
      PRIVATE(this)->callbacks.remove(i+1);
      PRIVATE(this)->callbacks.remove(i);
      i -= 2;
    }
  }
}

/*!
  Set a new color value.

  If the field value gets updated, the color change callbacks will be triggered.
*/

void
So@Gui@ColorEditor::setColor(const SbColor & color)
{
  // callbacks are triggered on the sensor rebound...
  switch ( PRIVATE(this)->attachment ) {
  case DETACHED:
    break;
  case SFCOLOR:
    assert(PRIVATE(this)->sfcolor != NULL);
    if ( PRIVATE(this)->sfcolor->getValue() != color ) {
      PRIVATE(this)->sfcolor->setValue(color);
      PRIVATE(this)->color = color;
    }
    break;
  case MFCOLOR:
    assert(PRIVATE(this)->mfcolor != NULL);
    if ( PRIVATE(this)->mfcolor->operator[](PRIVATE(this)->mfindex) != color ) {
      PRIVATE(this)->mfcolor->set1Value(PRIVATE(this)->mfindex, color);
      PRIVATE(this)->color = color;
    }
    break;
  case MFUINT32:
    assert(PRIVATE(this)->mfuint32 != NULL);
    if ( PRIVATE(this)->mfuint32->operator[](PRIVATE(this)->mfindex) != color.getPackedValue() ) {
      PRIVATE(this)->mfuint32->set1Value(PRIVATE(this)->mfindex, color.getPackedValue());
      PRIVATE(this)->color = color;
    }
    break;
  }
}

/*!
  Get the current color value.
*/

const SbColor &
So@Gui@ColorEditor::getColor(void) const
{
  // FIXME: update color object?
  return PRIVATE(this)->color;
}

/*!
  Not implemented yet.

  Sets whether or not the color sliders should be in WYSIWYG mode.
  When enabled, the color backgrounds in the sliders will be updated to
  reflect what the color will be, taken all color components into account.
  When disabled, the color backgrounds only reflect the component the slider
  controls.
*/

void
So@Gui@ColorEditor::setWYSIWYG(SbBool enable)
{
  PRIVATE(this)->wysiwyg = enable;
}

/*!
  Returns whether or not the editor sliders are in WYSIWYG mode.
*/

SbBool
So@Gui@ColorEditor::isWYSIWYG(void) const
{
  return PRIVATE(this)->wysiwyg;
}

/*!
  Sets which if the slider sets is to be used.

  \sa So@Gui@ColorEditor::Sliders
*/

void
So@Gui@ColorEditor::setCurrentSliders(So@Gui@ColorEditor::Sliders which)
{
  PRIVATE(this)->sliders = which;
  assert(PRIVATE(this)->switcher != NULL);
  switch ( which ) {
  case NONE:
    PRIVATE(this)->switcher->value.setValue(1); // -1 works too
    break;
  case INTENSITY:
    PRIVATE(this)->switcher->value.setValue(2);
    break;
  case RGB:
    PRIVATE(this)->switcher->value.setValue(3);
    break;
  case HSV:
    PRIVATE(this)->switcher->value.setValue(4);
    break;
  case RGB_V:
    PRIVATE(this)->switcher->value.setValue(5);
    break;
  case RGB_HSV:
    PRIVATE(this)->switcher->value.setValue(6);
    break;
  default:
    if ( SO@GUI@_DEBUG )
      SoDebugError::postWarning("So@Gui@ColorEditor::setCurrentSliders", "unknown slider set");
    PRIVATE(this)->switcher->value.setValue(-1);
    break;
  }
}

/*!
  Returns which slider sets is being used.

  \sa So@Gui@ColorEditor::Sliders
*/

So@Gui@ColorEditor::Sliders
So@Gui@ColorEditor::getCurrentSliders(void) const
{
  return PRIVATE(this)->sliders;
}

/*!
  Sets the update-frequency setting, which affects when color change callbacks
  will be triggered.

  \sa So@Gui@ColorEditor::UpdateFrequency
*/

void
So@Gui@ColorEditor::setUpdateFrequency(So@Gui@ColorEditor::UpdateFrequency freq)
{
  PRIVATE(this)->update = freq;
}

/*!
  Returns the update-frequency setting.

  \sa So@Gui@ColorEditor::UpdateFrequency
*/

So@Gui@ColorEditor::UpdateFrequency
So@Gui@ColorEditor::getUpdateFrequency(void) const
{
  return PRIVATE(this)->update;
}

// *************************************************************************

void
So@Gui@ColorEditor::setSceneGraph(SoNode * scene)
{
  // blank existing scene graph
  inherited::setSceneGraph(NULL);
  if ( PRIVATE(this)->editor ) {
    PRIVATE(this)->editor->unref();
    PRIVATE(this)->editor = NULL;
  }
  if ( scene == NULL ) return;

  if ( !scene->isOfType(SoGuiPane::getClassTypeId()) ) {
    SoDebugError::postInfo("So@Gui@ColorEditor::setSceneGraph", "scene must be of type SoGuiPane");
    return;
  }

  SoNode * root = SoAny::loadSceneGraph(ColorEditor::superscene);
  assert(root != NULL);
  assert(root->isOfType(SoSeparator::getClassTypeId()));
  SoSeparator * superscene = (SoSeparator *) root;

  PRIVATE(this)->editor = (SoGuiPane *) scene;
  PRIVATE(this)->editor->ref();
  superscene->addChild(PRIVATE(this)->editor);

  inherited::setSceneGraph(superscene);
}

SoNode *
So@Gui@ColorEditor::getSceneGraph(void)
{
  SoNode * node = inherited::getSceneGraph();
  if ( node == NULL ) return NULL;
  assert(node->isOfType(SoSeparator::getClassTypeId()));
  SoSeparator * root = (SoSeparator *) node;
  int num = root->getNumChildren();
  if ( num == 0 ) return NULL;
  SoNode * child = root->getChild(num - 1);
  if ( !child->isOfType(SoGuiPane::getClassTypeId()) ) return NULL;
  return child;
}

// *************************************************************************

void
ColorEditor::attachedToColor(const SbColor & color)
{
  float r, g, b, h, s, v;
  this->color = color;
  color.getValue(r, g, b);
  color.getHSVValue(h, s, v);
  this->updating = TRUE;
  this->slider_r->value.setValue(r);
  this->slider_g->value.setValue(g);
  this->slider_b->value.setValue(b);
  this->slider_h->value.setValue(h);
  this->slider_s->value.setValue(s);
  this->slider_v->value.setValue(v);
  // FIXME: update textures, at least if wysiwyg mode is enabled
  this->updating = FALSE;
}

// *************************************************************************

void
ColorEditor::colorChange(void)
{
  this->attachedToColor(PUBLIC(this)->getColor());
  if ( this->update == So@Gui@ColorEditor::CONTINUOUS ) {
    int i;
    for ( i = 0; i < this->callbacks.getLength(); i += 2 ) {
      So@Gui@ColorEditorCB * callback = (So@Gui@ColorEditorCB *) this->callbacks[i];
      void * closure = this->callbacks[i+1];
      callback(closure, &(this->color));
    }
  }
}

void
ColorEditor::update_cb(void * closure, SoSensor * sensor)
{
  assert(closure != NULL);
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  me->colorChange();
}

void
ColorEditor::delete_cb(void * closure, SoSensor * sensor)
{
  assert(closure != NULL);
  PUBLIC(closure)->detach();
}

// *************************************************************************

void
ColorEditor::update_r_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float r, g, b;
  SbColor color = PUBLIC(me)->getColor();
  color.getValue(r, g, b);
  r = me->slider_r->value.getValue();
  color.setValue(r, g, b);
  PUBLIC(me)->setColor(color);
}

void
ColorEditor::update_g_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float r, g, b;
  SbColor color = PUBLIC(me)->getColor();
  color.getValue(r, g, b);
  g = me->slider_g->value.getValue();
  color.setValue(r, g, b);
  PUBLIC(me)->setColor(color);
}

void
ColorEditor::update_b_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float r, g, b;
  SbColor color = PUBLIC(me)->getColor();
  color.getValue(r, g, b);
  b = me->slider_b->value.getValue();
  color.setValue(r, g, b);
  PUBLIC(me)->setColor(color);
}

void
ColorEditor::update_h_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float h, s, v;
  SbColor color = PUBLIC(me)->getColor();
  color.getHSVValue(h, s, v);
  h = me->slider_h->value.getValue();
  color.setHSVValue(h, s, v);
  PUBLIC(me)->setColor(color);
}

void
ColorEditor::update_s_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float h, s, v;
  SbColor color = PUBLIC(me)->getColor();
  color.getHSVValue(h, s, v);
  s = me->slider_s->value.getValue();
  color.setHSVValue(h, s, v);
  PUBLIC(me)->setColor(color);
}

void
ColorEditor::update_v_cb(void * closure, SoSensor * sensor)
{
  ColorEditor * me = (ColorEditor *) closure;
  if ( me->updating ) return;
  float h, s, v;
  SbColor color = PUBLIC(me)->getColor();
  color.getHSVValue(h, s, v);
  v = me->slider_v->value.getValue();
  color.setHSVValue(h, s, v);
  PUBLIC(me)->setColor(color);
}

// *************************************************************************
