/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SO@GUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@GUI@_DEBUG

/**************************************************************************\
 *
 *  A WORD OF ADVICE
 *
 *  It is fruitless to modify the contents of the So@Gui@RenderArea.cpp file
 *  because it is autogenerated by configure from the SoGuiRenderArea.cpp.in
 *  file which you will find in the src/Inventor/@Gui@/common/ directory.
 *  Do your modifications to that file instead.
 *
\**************************************************************************/

// *************************************************************************

/*!
  \class So@Gui@RenderArea Inventor/@Gui@/So@Gui@RenderArea.h
  \brief The So@Gui@RenderArea class adds scenegraph and event management.
  \ingroup components common

  The So@Gui@RenderArea class is a component that adds scenegraph
  management and input device event handling to the So@Gui@GLWidget
  component.
*/

// *************************************************************************

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#include <Inventor/@Gui@/common/gl.h> // glDrawBuffer()

#include <Inventor/SoSceneManager.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/misc/SoBasic.h>
#include <Inventor/nodes/SoSelection.h>

#include <so@gui@defs.h>
#include <Inventor/@Gui@/So@Gui@Basic.h>
#include <Inventor/@Gui@/So@Gui@.h>
#include <Inventor/@Gui@/devices/So@Gui@Keyboard.h>
#include <Inventor/@Gui@/devices/So@Gui@Mouse.h>
#include <Inventor/@Gui@/devices/So@Gui@Spaceball.h>
#ifdef HAVE_JOYSTICK_LINUX
#include <Inventor/@Gui@/devices/So@Gui@LinuxJoystick.h>
#endif // HAVE_JOYSTICK_LINUX

#include <Inventor/@Gui@/So@Gui@RenderArea.h>
#include <Inventor/@Gui@/SoAny.h>

#include <string.h> // strchr()

#define RENDERAREA_DEBUG_REDRAWS 0

// *************************************************************************

SO@GUI@_OBJECT_SOURCE(So@Gui@RenderArea);

// *************************************************************************

/*!
  \var SbPList * So@Gui@RenderArea::deviceList
  FIXME: write doc
*/

// *************************************************************************

class So@Gui@RenderAreaP {
public:

  So@Gui@RenderAreaP(class So@Gui@RenderArea * pub);
  ~So@Gui@RenderAreaP(void);

  SbBool clear;
  SbBool clearZBuffer;
  SbBool clearOverlay;

  SoSceneManager * normalManager;
  SoSceneManager * overlayManager;

  SbColor * normalColormap;
  int normalColormapSize;
  int normalColormapStart;
  SbColor * overlayColormap;
  int overlayColormapSize;
  int overlayColormapStart;

  struct {
    So@Gui@Keyboard * keyboard;
    So@Gui@Mouse * mouse;
  } devices;

  SbBool autoRedraw;

  SoSelection * normalSelection;
  SoSelection * overlaySelection;

  static const int GL_DEFAULT_MODE;

  // OpenGL info-window hack.
  enum { NONE, OPENGL, INVENTOR, TOOLKIT };
  int checkMagicSequences(const char c);
  void showOpenGLDriverInformation(void);
  void showInventorInformation(void);
  void showToolkitInformation(void);

private:
  So@Gui@RenderArea * pub; // public interface class
  SbString currentinput; // For the OpenGL info-window hack.
}; // class So@Gui@RenderAreaP

const int So@Gui@RenderAreaP::GL_DEFAULT_MODE = (SO_GL_RGB |
                                                 SO_GL_ZBUFFER |
                                                 SO_GL_DOUBLE);

// Note: assumes a valid current OpenGL context.
void
So@Gui@RenderAreaP::showOpenGLDriverInformation(void)
{
#if SO@GUI@_DEBUG
  const GLubyte * vendor = glGetString(GL_VENDOR);
  const GLubyte * renderer = glGetString(GL_RENDERER);
  const GLubyte * version = glGetString(GL_VERSION);
  const GLubyte * extensions = glGetString(GL_EXTENSIONS);

  SbString info = "GL_VENDOR: \""; info += (const char *)vendor; info += "\"\n";
  info += "GL_RENDERER: \""; info += (const char *)renderer; info += "\"\n";
  info += "GL_VERSION: \""; info += (const char *)version; info += "\"\n";
  info += "GL_EXTENSIONS: \"\n   ";
    
  SbString exts = (const char *)extensions;
  const char * p;
  int count = 0;
  // (the extra parentheses in the while-expression kills a gcc warning)
  while ((p = strchr(exts.getString(), ' '))) {
    const char * start = exts.getString();
    info += exts.getSubString(0, p - start);
    exts.deleteSubString(0, p - start);
    count++;
    if (count == 4) { // number of extensions listed on each line
      info += "\n   ";
      count = 0;
    }
  }
  if (exts.getLength() > 0) { info += "\n   "; info += exts; }
  info += "\"\n";

  // Limits.
  {
    // glPointSize()

    GLfloat bounds[2];
    glGetFloatv(GL_POINT_SIZE_RANGE, bounds);
    GLfloat granularity[1];
    glGetFloatv(GL_POINT_SIZE_GRANULARITY, granularity);
    SbString limits;
    limits.sprintf("glPointSize(): range=[%f, %f], granularity=%f\n",
                   bounds[0], bounds[1], granularity[0]);
    info += limits;


    // glLineWidth()

    glGetFloatv(GL_LINE_WIDTH_RANGE, bounds);
    glGetFloatv(GL_LINE_WIDTH_GRANULARITY, granularity);
    limits.sprintf("glLineWidth(): range=[%f, %f], granularity=%f\n",
                   bounds[0], bounds[1], granularity[0]);
    info += limits;
  }

  So@Gui@::createSimpleErrorDialog(NULL, "OpenGL driver information",
                                    info.getString());
#endif // SO@GUI@_DEBUG
}

void
So@Gui@RenderAreaP::showInventorInformation(void)
{
#if SO@GUI@_DEBUG
  SbString info = SoDB::getVersion();
  // FIXME: dump list of available node classes? 20010927 mortene.
  So@Gui@::createSimpleErrorDialog(NULL, "Inventor implementation info",
                                    info.getString());
#endif // SO@GUI@_DEBUG
}

void
So@Gui@RenderAreaP::showToolkitInformation(void)
{
#if SO@GUI@_DEBUG
  SbString info = "So@Gui@ version "; info += SO@GUI@_VERSION; info += "\n";
#if SO@GUI@_MAKE_DLL
  info += "Built as MSWindows DLL.\n";
#endif // !SO@GUI@_MAKE_DLL

  // FIXME: include information about the underlying toolkit library,
  // if possible (ie Qt version, Gtk version, Motif implementation,
  // MSWindows version, ...).  20010927 mortene.

  // FIXME: information about DLL path(s) (both for the So@Gui@ and
  // Coin/Inventor library) would be _extremely_ useful for debugging
  // "remote" applications, as application programmers (including
  // ourselves) tend to spread those files around misc diskdrive
  // directories -- especially on MSWindows platforms.  Mismatches for
  // run-time binding and link-time binding then causes bugs which are
  // hard to understand.
  //
  // I don't know if any platforms have enough introspection
  // functionality to enable us to do this, though. Should
  // investigate. (update: GetModuleHandle() looks like the place to
  // start looking in the Win32 API.)
  //
  // 20010927 mortene.

  // FIXME: dump rcsid strings for all components. 20010927 mortene.

  // FIXME: information about the native OpenGL widget format, along
  // with the generic format flags (SO_GL_DOUBLE etc), could be
  // useful.  20010927 mortene.

  info += "\n";
  info += "Inventor implementation: "; info += SoDB::getVersion();
  So@Gui@::createSimpleErrorDialog(NULL, "So@Gui@ implementation info",
                                    info.getString());
#endif // SO@GUI@_DEBUG
}

int
So@Gui@RenderAreaP::checkMagicSequences(const char c)
{
#if SO@GUI@_DEBUG
  this->currentinput += c;
  int cl = this->currentinput.getLength();

  static const char glinfoseq[] = "glinfo";
  static const char ivinfoseq[] = "ivinfo";
  static const char soinfoseq[] = "soinfo";

  int ml = strlen(glinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == glinfoseq) {
    return So@Gui@RenderAreaP::OPENGL;
  }
  ml = strlen(ivinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == ivinfoseq) {
    return So@Gui@RenderAreaP::INVENTOR;
  }
  ml = strlen(soinfoseq);
  if (cl >= ml && this->currentinput.getSubString(cl - ml) == soinfoseq) {
    return So@Gui@RenderAreaP::TOOLKIT;
  }

  // Limit memory usage.
  if (cl > 1024) { this->currentinput = ""; }
#endif // SO@GUI@_DEBUG
  return So@Gui@RenderAreaP::NONE;
}

#define PRIVATE(ptr) (ptr->priv)
#define PUBLIC(ptr) (ptr->pub)

// *************************************************************************

/*!
  \var So@Gui@RenderAreaEventCB * So@Gui@RenderArea::appEventHandler

  This is an application-settable event callback that will be called with
  X events destined for the renderarea.

  Set this member through the access methods, not directly.
*/

/*!
  \var void * So@Gui@RenderArea::appEventHandlerData

  This member is the closure given to the application event handler.

  Set this member through the access methods, not directly.
*/

// *************************************************************************

// *************************************************************************

/*!
  Public constructor.
*/
So@Gui@RenderArea::So@Gui@RenderArea(
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput)
: inherited(parent, name, embed, So@Gui@RenderAreaP::GL_DEFAULT_MODE, FALSE)
{
  this->constructor(mouseInput, keyboardInput, TRUE);
} // So@Gui@RenderArea()

/*!
  Protected constructor used by derived classes.
*/
So@Gui@RenderArea::So@Gui@RenderArea(// protected
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build)
: inherited(parent, name, embed, So@Gui@RenderAreaP::GL_DEFAULT_MODE, FALSE)
{
  this->constructor(mouseInput, keyboardInput, build);
} // So@Gui@RenderArea()

/*!
  Common code for all constructors.
*/
void
So@Gui@RenderArea::constructor(// private
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build)
{
  PRIVATE(this) = new So@Gui@RenderAreaP(this);

  PRIVATE(this)->normalManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
  PRIVATE(this)->normalManager->activate();
  PRIVATE(this)->overlayManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
  PRIVATE(this)->overlayManager->activate();
  // FIXME: what is this magic number doing here - shouldn't we use
  // SoGLCacheContextElement::getUniqueCacheContext() for Coin, and
  // magic numbers just for SGI / TGS Inventor?
  //
  // On a side note: won't this code fail if we construct several
  // So@Gui@RenderArea instances with overlays? They will all use
  // cachecontext==1 for their SoGLRenderAction instances -- is that
  // kosher?
  //
  // 20010831 mortene.
  PRIVATE(this)->overlayManager->getGLRenderAction()->setCacheContext(1);

  this->deviceList = new SbPList ;
  this->appEventHandler = NULL;
  this->appEventHandlerData = NULL;

  if (mouseInput) {
    PRIVATE(this)->devices.mouse = new So@Gui@Mouse;

    // FIXME: somebody debug larsa's head so he learns to write proper
    // FIXME comments (see below), which _at least_ actually contains
    // a useful description of what doesn't work / is to be fixed. And
    // why not throw in the ability to tag the FIXME with a datestamp
    // and username aswell. Sheesh... 20010831 mortene.

    // FIXME: this does not work
    // this->registerDevice(PRIVATE(this)->devices.mouse);
    this->deviceList->append(PRIVATE(this)->devices.mouse);
  }

  if (keyboardInput) {
    PRIVATE(this)->devices.keyboard = new So@Gui@Keyboard;
    // FIXME: this does not work
    // this->registerDevice(PRIVATE(this)->devices.keyboard);
    this->deviceList->append(PRIVATE(this)->devices.keyboard);
  }

  if (! build) return;
  this->setClassName("So@Gui@RenderArea");
  @WIDGET@ glarea = this->buildWidget(this->getParentWidget());
  this->setBaseWidget(glarea);
  this->setSize(SbVec2s(400, 400));
} // constructor()

/*!
  Destructor.
*/
So@Gui@RenderArea::~So@Gui@RenderArea(
  void)
{
  for (int i = this->deviceList->getLength() - 1; i >= 0; i--) {
    So@Gui@Device * device = (So@Gui@Device *) ((*this->deviceList)[i]);
    this->unregisterDevice(device);
    delete device;
  }
  delete this->deviceList;
  delete PRIVATE(this);
} // ~So@Gui@RenderArea()

// *************************************************************************

/*!
  A hook invoked after window has been realized.
*/
void
So@Gui@RenderArea::afterRealizeHook(void)
{
  inherited::afterRealizeHook();

#ifdef HAVE_JOYSTICK_LINUX
  if (So@Gui@LinuxJoystick::exists())
    this->registerDevice(new So@Gui@LinuxJoystick);
#endif // HAVE_JOYSTICK_LINUX

  if (So@Gui@Spaceball::exists())
    this->registerDevice(new So@Gui@Spaceball);
} // afterRealizeHook()

/*!
  This method sets the scene graph to be rendered in the normal bitmap
  planes.

  \sa getSceneGraph(), setOverlaySceneGraph()
*/
void
So@Gui@RenderArea::setSceneGraph(// virtual
  SoNode * scene)
{
  PRIVATE(this)->normalManager->setSceneGraph(scene);
} // setSceneGraph()

/*!
  This method returns a reference to the scene graph root node as set
  by the user.

  \sa So@Gui@RenderArea::getSceneManager()
*/
SoNode *
So@Gui@RenderArea::getSceneGraph(// virtual
  void)
{
  return PRIVATE(this)->normalManager->getSceneGraph();
} // getSceneGraph()

/*!
  This method sets the scene graph to render for the overlay bitmap
  planes.

  Important note: not all graphics hardware and / or drivers for
  graphics hardware support overlay planes, so application programmers
  are adviced to find some other way of accomplishing what they want
  to do before resorting to using overlay planes.  Using overlay
  planes will in practice severely limit the portability of
  applications which depend on them being available.

  \sa setSceneGraph(), getOverlaySceneGraph()
*/
void
So@Gui@RenderArea::setOverlaySceneGraph(
  SoNode * scene)
{
  // FIXME: when an overlay scenegraph is attempted registered with
  // the SoQtRenderArea -- try to make a QGLWidget with overlay
  // planes, and if that's not possible, display a warning.
  // 20010805 mortene.

  PRIVATE(this)->overlayManager->setSceneGraph(scene);
} // setOverlaySceneGraph()

/*!
  This method returns the scene graph for the overlay scene.
*/
SoNode *
So@Gui@RenderArea::getOverlaySceneGraph(
  void)
{
  return PRIVATE(this)->overlayManager->getSceneGraph();
} // getOverlaySceneGraph()

// *************************************************************************

/*!
  This method add \a device to the list of devices handling events for
  this component.
*/
void
So@Gui@RenderArea::registerDevice(
  So@Gui@Device * device)
{
  int idx = deviceList->find(device);
  if (idx == -1)
    deviceList->append(device);

  device->setWindowSize(this->getGLSize());
  if (idx == -1)
    device->enable(this->getGLWidget(), 
      &So@Gui@GLWidget::eventHandler, (void*) this);
} // registerDevice()

/*!
  This method removes \a device from the list of devices handling
  events for this component.
*/
void
So@Gui@RenderArea::unregisterDevice(
  So@Gui@Device * device)
{
  assert(this->deviceList != NULL);
  const int idx = this->deviceList->find(device);
  if (idx == -1) {
#if SO@GUI@_DEBUG
    SoDebugError::post("So@Gui@RenderArea::unregisterDevice",
        "tried to remove nonexisting device");
#endif // SO@GUI@_DEBUG
    return;
  }
  this->deviceList->remove(idx);
  device->disable(this->getGLWidget(), NULL, NULL);
} // unregisterDevice()

// *************************************************************************

/*!
  This method sets the background color of the scene.
*/
void
So@Gui@RenderArea::setBackgroundColor(
  const SbColor & color)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setBackgroundColor(color);
} // setBackgroundColor()

/*!
  This method returns the background color for the scene.
*/
const SbColor &
So@Gui@RenderArea::getBackgroundColor(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getBackgroundColor();
} // getBackgroundColor()

// *************************************************************************

/*!
  This method sets the index of the background color for the scene.
*/
void
So@Gui@RenderArea::setBackgroundIndex(
  int idx)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setBackgroundIndex(idx);
} // setBackgroundIndex()

/*!
  This method returns the index of the background color for the scene.
*/
int
So@Gui@RenderArea::getBackgroundIndex(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getBackgroundIndex();
} // getBackgroundIndex()

// *************************************************************************

/*!
  This method sets the index of the background for the overlay scene.
*/
void
So@Gui@RenderArea::setOverlayBackgroundIndex(
  int idx)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  PRIVATE(this)->overlayManager->setBackgroundIndex(idx);
} // setOverlayBackgroundIndex()

/*!
  This method returns the index of the background for the overlay scene.
*/
int
So@Gui@RenderArea::getOverlayBackgroundIndex(
  void) const
{
  assert(PRIVATE(this)->overlayManager != NULL);
  return PRIVATE(this)->overlayManager->getBackgroundIndex();
} // getOverlayBackgroundIndex()

// *************************************************************************

/*!
  This method sets the colormap for the scene.
*/
void
So@Gui@RenderArea::setColorMap(
  int start,
  int num,
  const SbColor * colors)
{
  delete [] PRIVATE(this)->normalColormap;
  PRIVATE(this)->normalColormapStart = start;
  PRIVATE(this)->normalColormapSize = num;
  PRIVATE(this)->normalColormap = new SbColor [ num ];
  for (int i = 0; i < num; i++)
    PRIVATE(this)->normalColormap[i] = colors[i];
} // setColorMap()

/*!
  This method sets the colormap for the overlay scene.
*/
void
So@Gui@RenderArea::setOverlayColorMap(
  int start,
  int num,
  const SbColor * colors)
{
  delete [] PRIVATE(this)->overlayColormap;
  PRIVATE(this)->overlayColormapStart = start;
  PRIVATE(this)->overlayColormapSize = num;
  PRIVATE(this)->overlayColormap = new SbColor [ num ];
  for (int i = 0; i < num; i++)
    PRIVATE(this)->overlayColormap[i] = colors[i];
} // setOverlayColorMap()

// *************************************************************************

/*!
  This method sets the viewport region.
*/
void
So@Gui@RenderArea::setViewportRegion(
  const SbViewportRegion & region)
{
  if (region.getWindowSize()[0] == -1) return;

#if SO@GUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@Gui@RenderArea::setViewportRegion",
                         "size=<%d, %d>",
                         region.getWindowSize()[0],
                         region.getWindowSize()[1]);
#endif // debug

  PRIVATE(this)->normalManager->setViewportRegion(region);
  PRIVATE(this)->overlayManager->setViewportRegion(region);
} // setViewportRegion()

/*!
  This method returns the viewport region.
*/
const SbViewportRegion &
So@Gui@RenderArea::getViewportRegion(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction()->getViewportRegion();
} // getViewportRegion()

// *************************************************************************

/*!
  This method sets the transparency type to be used for the scene.
*/
void
So@Gui@RenderArea::setTransparencyType(
  SoGLRenderAction::TransparencyType type)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->getGLRenderAction()->setTransparencyType(type);
//  PRIVATE(this)->overlayManager->getGLRenderAction()->setTransparencyType(type);
} // setTransparencyType()

/*!
  This method returns the transparency type used for the scene.
*/
SoGLRenderAction::TransparencyType
So@Gui@RenderArea::getTransparencyType(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction()->getTransparencyType();
} // getTransparencyType()

// *************************************************************************

/*!
  This method sets the antialiasing used for the scene.
*/
void
So@Gui@RenderArea::setAntialiasing(
  SbBool smoothing,
  int numPasses)
{
  // FIXME: is this really necessary? I think we should either ignore
  // the call or store values for later migration if the scenemanager
  // instance(s) haven't been made yet. 20010331 mortene.
  assert(PRIVATE(this)->normalManager != NULL);

  // Instead of piping the call further to
  // SoSceneManager::setAntialiasing(), we duplicate the code found in
  // that function. The reason for this is that we want to work around
  // a bug found in SGI Inventor, where they define the
  // setAntialiasing() method, but doesn't actually implement it.  So
  // we don't use it to avoid a linker error for those compiling So*
  // libraries on top of the older SGI Inventor versions with this
  // bug.
  //
  // We should perhaps throw in a configure check for the
  // SoSceneManager::setAntialiasing() method and only activate this
  // code when actually needed?
  //                                                   mortene@sim.no
  enum { MGRS = 2 };
  SoSceneManager * mgrs[MGRS] = { PRIVATE(this)->normalManager,
                                  PRIVATE(this)->overlayManager };
  for (int i=0; i < MGRS; i++) {
    SoGLRenderAction * glra = mgrs[i]->getGLRenderAction();
    if (glra) {
      glra->setSmoothing(smoothing);
      glra->setNumPasses(numPasses);
    }
  }
} // setAntialiasing()

/*!
  This method returns the antialiasing used for the scene.
*/
void
So@Gui@RenderArea::getAntialiasing(
  SbBool & smoothing,
  int & numPasses) const
{
  // FIXME: there's an API design flaw here, as it is assumed that the
  // antialiasing setting for the renderaction in the "normal"
  // rendering context always matches what is the case for the
  // renderaction in the overlay manager. This is not necessarily
  // true. Could be solved by an additional argument to
  // getAntialiasing(): a boolean indicator on whether or not we want
  // the overlay context with a default value (false) to keep API
  // compatibility. 20010331 mortene.

  assert(PRIVATE(this)->normalManager != NULL);

  // About why we don't use SoSceneManager::getAntialiasing()
  // directly, see comment in SoGuiRenderArea::setAntiAliasing().
  SoGLRenderAction * glra = PRIVATE(this)->normalManager->getGLRenderAction();
  smoothing = glra->isSmoothing();
  numPasses = glra->getNumPasses();
} // getAntialiasing()

/*!
  This method sets whether the render buffer should be cleared before
  rendering.
*/
void
So@Gui@RenderArea::setClearBeforeRender(
  SbBool enable,
  SbBool zbEnable)
{
  PRIVATE(this)->clear = enable;
  PRIVATE(this)->clearZBuffer = zbEnable;
} // setClearBeforeRender()

/*!
  This method returns whether the render buffer is cleared before each
  render.
*/
SbBool
So@Gui@RenderArea::isClearBeforeRender(
  void) const
{
  return PRIVATE(this)->clear;
} // isClearBeforeRender()

/*!
  This method returns whether the render buffer's Z buffer is cleared
  before each render.
*/
SbBool
So@Gui@RenderArea::isClearZBufferBeforeRender(
  void) const
{
  return PRIVATE(this)->clearZBuffer;
} // isClearZBufferBeforeRender()

/*!
  This method sets whether the overlay render buffer should be cleared
  before each render or not.
*/
void
So@Gui@RenderArea::setClearBeforeOverlayRender(
  SbBool enable)
{
  PRIVATE(this)->clearOverlay = enable;
} // setClearBeforeOverlayRender()

/*!
  This method returns whether the overlay render buffer is cleared
  before each redraw or not.
*/
SbBool
So@Gui@RenderArea::isClearBeforeOverlayRender(
  void) const
{
  return PRIVATE(this)->clearOverlay;
} // isClearBeforeOverlayRender()

/*!
  This method sets whether redrawing should be handled automatically
  or not when data in the scenegraph changes.

  The default setting causes the renderarea to automatically trigger a
  redraw of the scenegraph contents.
*/
void
So@Gui@RenderArea::setAutoRedraw(
  SbBool enable)
{
  if (enable) {
    PRIVATE(this)->normalManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
    PRIVATE(this)->overlayManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
  }
  else {
    PRIVATE(this)->normalManager->setRenderCallback(NULL, NULL);
    PRIVATE(this)->overlayManager->setRenderCallback(NULL, NULL);
  }

  // We can not use the render callback ptr as a flag, as the render
  // callback pointer will be set upon expose events and forced
  // redraws -- and autoRedraw is then used to remember that the
  // pointer should be set back to NULL again after redraw.
  PRIVATE(this)->autoRedraw = enable;
} // setAutoRedraw()

/*!
  This method returns whether redrawing is handled automatically 
  not.
*/
SbBool
So@Gui@RenderArea::isAutoRedraw(
  void) const
{
  return PRIVATE(this)->autoRedraw;
} // isAutoRedraw()

/*!
  This method sets the redraw priority.
*/

void
So@Gui@RenderArea::setRedrawPriority(
  uint32_t priority)
{
  PRIVATE(this)->normalManager->setRedrawPriority(priority);
  PRIVATE(this)->overlayManager->setRedrawPriority(priority);
} // setRedrawPriority()

/*!
  This method returns the redraw priority.
*/

uint32_t
So@Gui@RenderArea::getRedrawPriority(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getRedrawPriority();
} // getRedrawPriority()

/*!
  This function returns the default redraw priority.
*/

uint32_t
So@Gui@RenderArea::getDefaultRedrawPriority(// static
  void)
{
  return SoSceneManager::getDefaultRedrawPriority();
} // getDefaultRedrawPriority()

/*!
  This method renders the scene.
*/

void
So@Gui@RenderArea::render(
  void)
{
  this->redraw();
} // render()

/*!
  This method renders the overlay scene.
*/

void
So@Gui@RenderArea::renderOverlay(
  void)
{
  this->redrawOverlay();
} // renderOverlay()

/*!
  This method schedules a redraw to happen at a later time (when the
  application has processed it's other events first).
*/

void
So@Gui@RenderArea::scheduleRedraw(
  void)
{
#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::scheduleRedraw",
                         "invoked");
#endif // debug

  assert(PRIVATE(this)->normalManager != NULL);
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->normalManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
  PRIVATE(this)->normalManager->scheduleRedraw(); // Redraw when idle.
} // scheduleRedraw()

/*!
  This method schedules a redraw of the overlay scene.
*/

void
So@Gui@RenderArea::scheduleOverlayRedraw(
  void)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->overlayManager->setRenderCallback(So@Gui@RenderArea::renderCB, this);
  PRIVATE(this)->overlayManager->scheduleRedraw(); // Redraw when idle.
} // scheduleOverlayRedraw()

/*!
  Do automatic redraw of the scenegraph when a selection under the
  SoSelection node is changed.

  Pass \c NULL to deactivate.

  (Only one SoSelection node can be monitored at any given time. This
  is obviously a rather silly design flaw. We choose to match the
  original Inventor API here, but this will probably change in the
  next major revision of the library.)
*/

void
So@Gui@RenderArea::redrawOnSelectionChange(
  SoSelection * selection)
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation. 20001002 mortene.

  if (PRIVATE(this)->normalSelection) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->normalSelection->removeChangeCallback(So@Gui@RenderArea::selection_redraw_cb, this);
  }

  PRIVATE(this)->normalSelection = selection;

  if (selection)
    selection->addChangeCallback(So@Gui@RenderArea::selection_redraw_cb, this);

} // redrawOnSelectionChange()

/*!
  Do automatic redraw of the scenegraph in the overlay planes when a
  selection under the SoSelection node is changed.

  Pass \c NULL to deactivate.

  \sa So@Gui@RenderArea::redrawOnSelectionChange()
*/

void
So@Gui@RenderArea::redrawOverlayOnSelectionChange(
  SoSelection * selection)
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation on redrawOnSelectionChange(). 20001002 mortene.

  if (PRIVATE(this)->overlaySelection) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->overlaySelection->removeChangeCallback(So@Gui@RenderArea::selection_redraw_cb, this);
  }

  PRIVATE(this)->overlaySelection = selection;

  if (selection)
    selection->addChangeCallback(So@Gui@RenderArea::selection_redraw_cb, this);

} // redrawOverlayOnSelectionChange()

/*!
  This method sets the render area event callback.
*/

void
So@Gui@RenderArea::setEventCallback(
  So@Gui@RenderAreaEventCB * func,
  void * user)
{
  this->appEventHandler = func;
  this->appEventHandlerData = user;
} // setEventCallback()

/*!
  This method sets the normal scene SoSceneManager object.
*/

void
So@Gui@RenderArea::setSceneManager(
  SoSceneManager * manager)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager = manager;
} // setSceneManager()

/*!
  This method returns the normal scene SoSceneManager object.

  Having a reference to the SoSceneManager instance is useful for
  getting at the \e real root node of the rendering scenegraph,
  including camera, headlight and miscellaneous drawstyle nodes.  The
  getSceneGraph() method will only return the \e user scenegrah for
  So@Gui@RenderArea subclass So@Gui@Viewer and further subclasses. The
  reason this is not always what you want is because certain actions
  (like the SoRayPickAction) needs to traverse a valid camera if it
  should work as expected.

  If you need to get a pointer to the \e real root node use this
  method to get the SoSceneManager instance reference used by the
  So@Gui@RenderArea, then use SoSceneManager::getSceneGraph() to get
  the root node Coin uses for rendering.
*/
SoSceneManager *
So@Gui@RenderArea::getSceneManager(
  void) const
{
  return PRIVATE(this)->normalManager;
} // getSceneManager()

/*!
  This method sets the overlay scene SoSceneManager object.
*/

void
So@Gui@RenderArea::setOverlaySceneManager(
  SoSceneManager * manager)
{
  PRIVATE(this)->overlayManager = manager;
} // setOverlaySceneManager()

/*!
  This method returns the overlay scene SoSceneManager object.
*/

SoSceneManager *
So@Gui@RenderArea::getOverlaySceneManager(
  void) const
{
  return PRIVATE(this)->overlayManager;
} // getOverlaySceneManager()

/*!
  This method sets the SoGLRenderAction object for the normal scene.
*/

void
So@Gui@RenderArea::setGLRenderAction(
  SoGLRenderAction * action)
{
  assert(PRIVATE(this)->normalManager != NULL);
  PRIVATE(this)->normalManager->setGLRenderAction(action);
  // Force an update of the SoGLRenderAction to the correct
  // updatearea, aspectratio, etc.
  this->sizeChanged(this->getSize());
} // setGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the normal scene.
*/

SoGLRenderAction *
So@Gui@RenderArea::getGLRenderAction(
  void) const
{
  assert(PRIVATE(this)->normalManager != NULL);
  return PRIVATE(this)->normalManager->getGLRenderAction();
} // getGLRenderAction()

/*!
  This method sets the SoGLRenderAction object for rendering the overlay
  scen graph.
*/

void
So@Gui@RenderArea::setOverlayGLRenderAction(
  SoGLRenderAction * action)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  PRIVATE(this)->overlayManager->setGLRenderAction(action);
} // setOverlayGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the overlay scene
  graph.
*/

SoGLRenderAction *
So@Gui@RenderArea::getOverlayGLRenderAction(
  void) const
{
  assert(PRIVATE(this)->overlayManager != NULL);
  return PRIVATE(this)->overlayManager->getGLRenderAction();
} // getOverlayGLRenderAction()

/*!
  This method redraws the normal scene graph.
*/

void
So@Gui@RenderArea::redraw(// virtual, protected
  void)
{
#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::render",
                         "start (isVisible=%s waitForExpose=%s)",
                         this->isVisible() ? "TRUE" : "FALSE",
                         this->waitForExpose ? "TRUE" : "FALSE");
#endif // debug

  if (! this->isVisible() || !this->hasNormalGLArea() || this->waitForExpose)
    return;
  this->glLockNormal(); // this makes the GL context "current"

  SbBool drawfront =
    ! this->isDoubleBuffer() ||
    this->isDrawToFrontBufferEnable();

  glDrawBuffer(drawfront ? GL_FRONT : GL_BACK);

  this->actualRedraw();

  if (!drawfront) { this->glSwapBuffers(); }
  else { this->glFlushBuffer(); }
  this->glUnlockNormal();

#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::render", "done");
#endif // debug
} // redraw()

/*!
  This method redraws the normal scene graph.
*/

void
So@Gui@RenderArea::actualRedraw(// virtual, protected
  void)
{
  assert(PRIVATE(this)->normalManager != NULL);
  if (! this->isVisible()) return;
  PRIVATE(this)->normalManager->render(PRIVATE(this)->clear, PRIVATE(this)->clearZBuffer);
} // actualRedraw()

/*!
  This method redraws the overlay scene.
*/

void
So@Gui@RenderArea::redrawOverlay(// virtual, protected
  void)
{
  if (!this->isVisible() || this->waitForExpose || !this->hasOverlayGLArea()) return;
  
  glLockOverlay();
  this->actualOverlayRedraw();
  this->glFlushBuffer();
  glUnlockOverlay();
} // redrawOverlay()

/*!
  This method renders the overlay scene.
*/

void
So@Gui@RenderArea::actualOverlayRedraw(// virtual, protected
  void)
{
  assert(PRIVATE(this)->overlayManager != NULL);
  if (! this->isVisible()) return;
  PRIVATE(this)->overlayManager->render(PRIVATE(this)->clearOverlay, PRIVATE(this)->clearZBuffer);
} // actualOverlayRedraw()

/*!
  This method is invoked to initialize the normal graphics.
*/

void
So@Gui@RenderArea::initGraphic(// virtual, protected
  void)
{
  SoSceneManager * mgr = this->getSceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(this->isRGBMode());
    mgr->getGLRenderAction()->setCacheContext(SoAny::si()->getSharedCacheContextId((void*) this));  
  }
  // FIXME: should init cache context stuff,
  // FIXME: if not RGB mode, load colormap

  inherited::initGraphic();
} // initGraphic()

/*!
  This method is invoked to initialize the overlay graphics.
*/

void
So@Gui@RenderArea::initOverlayGraphic(// virtual, protected
  void)
{
  SoSceneManager * mgr = this->getOverlaySceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(FALSE);
  }
  // FIXME: load colormap

  // FIXME: shouldn't we do inherited::initOverlayGraphic() ? 20010831 mortene.

} // initOverlayGraphic()

// doc in super
void             // virtual, protected
So@Gui@RenderArea::sizeChanged(const SbVec2s & size)
{
#if SO@GUI@_DEBUG && 0
  SoDebugError::postInfo("So@Gui@RenderArea::sizeChanged",
                          "invoked, <%d, %d>", size[0], size[1]);
#endif // SO@GUI@_DEBUG

  if (size[0] == -1)
    return;

  assert(PRIVATE(this)->normalManager != NULL);
  assert(PRIVATE(this)->overlayManager != NULL);

  this->setGLSize(size);
  const SbVec2s glsize = this->getGLSize();

#if SO@GUI@_DEBUG && 0
  SoDebugError::postInfo("So@Gui@RenderArea::sizeChanged",
                          "glsize==<%d, %d>", glsize[0], glsize[1]);
#endif // SO@GUI@_DEBUG

  if (glsize[0] <= 0 || glsize[1] <= 0)
    return;

  this->setViewportRegion(SbViewportRegion(glsize));
  this->setDevicesWindowSize(glsize);

  PRIVATE(this)->normalManager->setWindowSize(glsize);
  PRIVATE(this)->normalManager->setSize(glsize);

  PRIVATE(this)->overlayManager->setWindowSize(glsize);
  PRIVATE(this)->overlayManager->setSize(glsize);

  this->scheduleRedraw();
} // sizeChanged()

// Documented in superclass.
void
So@Gui@RenderArea::widgetChanged(// virtual, protected
  @WIDGET@ widget)
{
  PRIVATE(this)->normalManager->reinitialize();
  PRIVATE(this)->overlayManager->reinitialize();
  // FIXME: colorindex mode not supported yet, so this has no
  // effect. 20001121 mortene.
#if 0
  PRIVATE(this)->normalManager->setRGBMode(this->isRGBMode());
  PRIVATE(this)->overlayManager->setRGBMode(this->isRGBMode());
#endif

  // FIXME: this code needs to be enabled (and rewritten to work) to
  // handle display list caching. 20001121 mortene.
  // UPDATE: check with pederb if any of this is really needed, or if
  // it should just be removed. 20010802 mortene.
#if 0
  SoGLRenderAction * ra = PRIVATE(this)->normalManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
  ra = PRIVATE(this)->overlayManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
#endif

  // FIXME: should also walk through all registered devices and do a
  // disable() on the old widget and enable() on the new one.
  // 20001121 mortene.

} // widgetChanged()

/*!
  This method builds the So@Gui@RenderArea contents in the \a parent
  widget.
*/

@WIDGET@
So@Gui@RenderArea::buildWidget(// protected
  @WIDGET@ parent)
{
  @WIDGET@ widget = inherited::buildWidget(parent);
  if (this->deviceList != NULL) {
    const int num = this->deviceList->getLength();
    for (int i = 0; i < num; i++) {
      So@Gui@Device * device = (So@Gui@Device *) (*this->deviceList)[i];
      device->enable(this->getGLWidget(),
        &inherited::eventHandler, (void *) this);
    }
  }
  const SbVec2s glsize = this->getGLSize();
  if (glsize[0] <= 0 || glsize[1] <= 0)
    return widget;

/*
  this->setDevicesWindowSize(glsize);

  this->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
  PRIVATE(this)->normalManager->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
  PRIVATE(this)->overlayManager->setViewportRegion(SbViewportRegion(glsize[0], glsize[1]));
*/
  return widget;
} // buildWidget()

/*!
  This method returns a default widget name for the base widget.
*/

const char *
So@Gui@RenderArea::getDefaultWidgetName(// virtual, protected
  void) const
{
  static const char defaultWidgetName[] = "So@Gui@WidgetName";
  return defaultWidgetName;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window.
*/

const char *
So@Gui@RenderArea::getDefaultTitle(// virtual, protected
  void) const
{
  static const char defaultTitle[] = "@Gui@ RenderArea";
  return defaultTitle;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window icon.
*/

const char *
So@Gui@RenderArea::getDefaultIconTitle(// virtual, protected
  void) const
{
  static const char defaultIconTitle[] = "@Gui@ RenderArea";
  return defaultIconTitle;
} // getDefaultIconTitle()

/*!
  This method invokes the application event handler, if one is set.
*/

SbBool
So@Gui@RenderArea::invokeAppCB(// protected
  @EVENT@ event)
{
  if (this->appEventHandler != NULL)
    return this->appEventHandler(this->appEventHandlerData, event);
  return FALSE;
} // invokeAppCB()

// *************************************************************************

/*!
  Toolkit-native events are attempted converted to Coin-generic events
  in the So@Gui@RenderArea::processEvent() method.  If this succeeds,
  they are forwarded to this method, which again will forward them to
  the scenegraph.

  This is a virtual method, and is overloaded in it's subclasses to
  catch events of particular interest to the viewer classes, for
  instance.

  \c TRUE is returned if the event was handled, otherwise \c FALSE.
*/
SbBool
So@Gui@RenderArea::processSoEvent(// virtual
  const SoEvent * const event)
{
  if (PRIVATE(this)->overlayManager->processEvent(event))
    return TRUE;
  if (PRIVATE(this)->normalManager->processEvent(event))
    return TRUE;
  return FALSE;
} // processSoEvent()

// *************************************************************************

/*!
  Overrides So@Gui@GLWidget::processEvent() to attempt to convert
  toolkit-native events to Coin-generic events.  If this succeeds, the
  generic SoEvent is forwarded to So@Gui@RenderArea::processSoEvent().
 */
void
So@Gui@RenderArea::processEvent(// virtual, protected
  @EVENT@ event)
{
  if (this->invokeAppCB(event))
    return;

  const SoEvent * soevent = this->getSoEvent(event);

  if (soevent != NULL) {
#if SO@GUI@_DEBUG
    // Undocumented feature: there are several "magic" sequences of
    // keys when tapped into the rendering canvas which'll pop up a
    // dialog box with information about that particular feature.
    //
    // See code comments behind "case" statements below for which
    // sequences are available so far.

    if (soevent->isOfType(SoKeyboardEvent::getClassTypeId())) {
      SoKeyboardEvent * ke = (SoKeyboardEvent *)soevent;
      if (ke->getState() == SoButtonEvent::UP) {
        char c = ke->getPrintableCharacter();
        switch (PRIVATE(this)->checkMagicSequences(c)) {
        case So@Gui@RenderAreaP::NONE:
          break;
        case So@Gui@RenderAreaP::OPENGL:  // "glinfo"
          this->glLockNormal();
          PRIVATE(this)->showOpenGLDriverInformation();
          this->glUnlockNormal();
          break;
        case So@Gui@RenderAreaP::INVENTOR:  // "ivinfo"
          PRIVATE(this)->showInventorInformation();
          break;
        case So@Gui@RenderAreaP::TOOLKIT:  // "soinfo"
          PRIVATE(this)->showToolkitInformation();
          break;
        default:
          assert(FALSE && "unknown debug key sequence");
          break;
        }
      }
    }
#endif // SO@GUI@_DEBUG

    SbBool processed = this->processSoEvent(soevent);
    if (processed) return;
  }

  inherited::processEvent(event);
} // processEvent()

// *************************************************************************

// doc from parent
SbBool 
So@Gui@RenderArea::glScheduleRedraw(void)
{
  this->scheduleRedraw();
  if (this->hasOverlayGLArea() && this->getOverlaySceneGraph()) {
    this->scheduleOverlayRedraw();
  }
  return TRUE;
}


/*!
  This method returns an SoEvent * corresponding to the given \a
  event, or \c NULL if there are none.
*/
const SoEvent *
So@Gui@RenderArea::getSoEvent(
  @EVENT@ event)
{
  if (! this->deviceList)
    return (SoEvent *) NULL;

  const SoEvent * soevent = NULL;
  const int num = this->deviceList->getLength();
  for (int i = 0; (i < num) && (soevent == NULL); i++)
    soevent = ((So@Gui@Device *)(*this->deviceList)[i])->translateEvent(event);

  return soevent;
} // getSoEvent()

// *************************************************************************

/*!
  This method sets the window size data in all the connected device
  classes.
*/
void
So@Gui@RenderArea::setDevicesWindowSize(
  const SbVec2s size)
{
  if (! this->deviceList) return;
  const int num = this->deviceList->getLength();
  for (int i = 0; i < num; i++)
    ((So@Gui@Device *)(*this->deviceList)[i])->setWindowSize(size);
} // setDevicesWindowSize()

// *************************************************************************

void
So@Gui@RenderArea::renderCB(// static
  void * closure,
  SoSceneManager * manager)
{
  So@Gui@RenderArea * thisptr = (So@Gui@RenderArea *) closure;
  if (manager == PRIVATE(thisptr)->normalManager)
    thisptr->render();
  else if (manager == PRIVATE(thisptr)->overlayManager)
    thisptr->renderOverlay();
  else assert(0);

  if (!thisptr->isAutoRedraw())
    manager->setRenderCallback(NULL, NULL);
} // renderCB()

/*!
  Callback for automatic redraw on SoSelection changes.
*/
void
So@Gui@RenderArea::selection_redraw_cb(// static
  void * closure,
  SoSelection * sel)
{
  So@Gui@RenderArea * ra = (So@Gui@RenderArea *) closure;
  if (sel == PRIVATE(ra)->normalSelection)
    ra->scheduleRedraw();
  else if (sel == PRIVATE(ra)->overlaySelection)
    ra->scheduleOverlayRedraw();
  else
    assert(0 && "callback on unknown SoSelection node");
} // selection_redraw_cb

// *************************************************************************

/*!
  Private class constructor.
*/
So@Gui@RenderAreaP::So@Gui@RenderAreaP(
  So@Gui@RenderArea * pub)
{
  PUBLIC(this) = pub;

  this->normalManager = new SoSceneManager;
  this->overlayManager = new SoSceneManager;

  this->normalColormap = NULL;
  this->normalColormapSize = 0;
  this->overlayColormap = NULL;
  this->overlayColormapSize = 0;

  this->clear = TRUE;
  this->clearZBuffer = TRUE;
  this->clearOverlay = TRUE;
  this->autoRedraw = TRUE;

  this->normalSelection = NULL;
  this->overlaySelection = NULL;

  this->devices.mouse = NULL;
  this->devices.keyboard = NULL;

} // So@Gui@RenderAreaP()

/*!
  Private class destructor.
*/
So@Gui@RenderAreaP::~So@Gui@RenderAreaP(
  void)
{
  delete this->normalManager;
  delete this->overlayManager;
  delete [] this->normalColormap;
  delete [] this->overlayColormap;
} // ~So@Gui@RenderAreaP()

// *************************************************************************

#if SO@GUI@_DEBUG
static const char * getSo@Gui@RenderAreaRCSId(void) { return rcsid; }
#endif // SO@GUI@_DEBUG
