/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SO@GUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@GUI@_DEBUG

/**************************************************************************\
 *
 *  A WORD OF ADVICE
 *
 *  It is fruitless to modify the contents of the So@Gui@RenderArea.cpp file
 *  because it is autogenerated by configure from the SoGuiRenderArea.cpp.in
 *  file which you will find in the src/Inventor/@Gui@/common/ directory.
 *  Do your modifications to that file instead.
 *
\**************************************************************************/

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#if HAVE_WINDOWS_H
#include <windows.h> // To resolve some definitions in gl.h.
#endif // HAVE_WINDOWS_H
#include <GL/gl.h> // glDrawBuffer()

#include <Inventor/misc/SoBasic.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/nodes/SoSelection.h>
#include <Inventor/SoSceneManager.h>

#include <so@gui@defs.h>
#include <Inventor/@Gui@/So@Gui@Basic.h>
#include <Inventor/@Gui@/devices/So@Gui@Mouse.h>
#include <Inventor/@Gui@/devices/So@Gui@Keyboard.h>
#include <Inventor/@Gui@/devices/So@Gui@Spaceball.h>
#ifdef HAVE_JOYSTICK_LINUX
#include <Inventor/@Gui@/devices/So@Gui@LinuxJoystick.h>
#endif // HAVE_JOYSTICK_LINUX

#include <Inventor/@Gui@/So@Gui@RenderArea.h>
#include <Inventor/@Gui@/SoAny.h>

#define RENDERAREA_DEBUG_REDRAWS 0

// *************************************************************************

/*!
  \class So@Gui@RenderArea Inventor/@Gui@/So@Gui@RenderArea.h
  \brief The So@Gui@RenderArea class is a component that adds scene graph
  management and input device handling to the So@Gui@GLWidget component.
  \ingroup components common

  The So@Gui@RenderArea class is completely autogenerated from generic
  source code.
*/

// *************************************************************************

SO@GUI@_OBJECT_SOURCE(So@Gui@RenderArea);

// *************************************************************************

/*!
  \var SbPList * So@Gui@RenderArea::deviceList
  FIXME: write doc
*/

// *************************************************************************

class So@Gui@RenderAreaP {
  friend class So@Gui@RenderArea;

  So@Gui@RenderAreaP( class So@Gui@RenderArea * pub );
  ~So@Gui@RenderAreaP(void);

  SbBool clear;
  SbBool clearZBuffer;
  SbBool clearOverlay;

  SoSceneManager * normalManager;
  SoSceneManager * overlayManager;

  SbColor * normalColormap;
  int normalColormapSize;
  int normalColormapStart;
  SbColor * overlayColormap;
  int overlayColormapSize;
  int overlayColormapStart;

  struct {
    So@Gui@Keyboard * keyboard;
    So@Gui@Mouse * mouse;
  } devices;

  SbBool autoRedraw;

  SoSelection * normalSelection;
  SoSelection * overlaySelection;

  static const int GL_DEFAULT_MODE;


  So@Gui@RenderArea * pub; // public interface class
}; // class So@Gui@RenderAreaP

const int So@Gui@RenderAreaP::GL_DEFAULT_MODE = (SO_GL_RGB |
                                                 SO_GL_ZBUFFER |
                                                 SO_GL_DOUBLE );

#define PRIVATE(ptr) (ptr->priv)
#define PUBLIC(ptr) (ptr->pub)

// *************************************************************************

/*!
  \var So@Gui@RenderAreaEventCB * So@Gui@RenderArea::appEventHandler

  This is an application-settable event callback that will be called with
  X events destined for the renderarea.

  Set this member through the access methods, not directly.
*/

/*!
  \var void * So@Gui@RenderArea::appEventHandlerData

  This member is the closure given to the application event handler.

  Set this member through the access methods, not directly.
*/

// *************************************************************************

// *************************************************************************

/*!
  Public constructor.
*/

So@Gui@RenderArea::So@Gui@RenderArea(
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput )
: inherited( parent, name, embed, So@Gui@RenderAreaP::GL_DEFAULT_MODE, FALSE )
{
  this->constructor( mouseInput, keyboardInput, TRUE );
} // So@Gui@RenderArea()

/*!
  Protected constructor used by derived classes.
*/

So@Gui@RenderArea::So@Gui@RenderArea( // protected
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build )
: inherited( parent, name, embed, So@Gui@RenderAreaP::GL_DEFAULT_MODE, FALSE )
{
  this->constructor( mouseInput, keyboardInput, build );
} // So@Gui@RenderArea()

/*!
  Common code for all constructors.
*/

void
So@Gui@RenderArea::constructor( // private
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build )
{
  PRIVATE(this) = new So@Gui@RenderAreaP( this );

  PRIVATE(this)->normalManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
  PRIVATE(this)->normalManager->activate();
  PRIVATE(this)->overlayManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
  PRIVATE(this)->overlayManager->activate();
  // FIXME: what is this magic number doing here - shouldn't we use
  // SoGLCacheContextElement::getUniqueCacheContext() for Coin, and
  // magic numbers just for SGI / TGS Inventor?
  //
  // On a side note: won't this code fail if we construct several
  // So@Gui@RenderArea instances with overlays? They will all use
  // cachecontext==1 for their SoGLRenderAction instances -- is that
  // kosher?
  //
  // 20010831 mortene.
  PRIVATE(this)->overlayManager->getGLRenderAction()->setCacheContext(1);

  this->deviceList = new SbPList ;
  this->appEventHandler = NULL;
  this->appEventHandlerData = NULL;

  if ( mouseInput ) {
    PRIVATE(this)->devices.mouse = new So@Gui@Mouse;

    // FIXME: somebody debug larsa's head so he learns to write proper
    // FIXME comments (see below), which _at least_ actually contains
    // a useful description of what doesn't work / is to be fixed. And
    // why not throw in the ability to tag the FIXME with a datestamp
    // and username aswell. Sheesh... 20010831 mortene.

    // FIXME: this does not work
    // this->registerDevice( PRIVATE(this)->devices.mouse );
    this->deviceList->append( PRIVATE(this)->devices.mouse );
  }

  if ( keyboardInput ) {
    PRIVATE(this)->devices.keyboard = new So@Gui@Keyboard;
    // FIXME: this does not work
    // this->registerDevice( PRIVATE(this)->devices.keyboard );
    this->deviceList->append( PRIVATE(this)->devices.keyboard );
  }

  if ( ! build ) return;
  this->setClassName( "So@Gui@RenderArea" );
  @WIDGET@ glarea = this->buildWidget( this->getParentWidget() );
  this->setBaseWidget( glarea );
  this->setSize( SbVec2s( 400, 400 ) );
} // constructor()

/*!
  Destructor.
*/

So@Gui@RenderArea::~So@Gui@RenderArea(
  void )
{
  for ( int i = this->deviceList->getLength() - 1; i >= 0; i-- ) {
    So@Gui@Device * device = (So@Gui@Device *) ((*this->deviceList)[i]);
    this->unregisterDevice( device );
    delete device;
  }
  delete this->deviceList;
  delete PRIVATE(this);
} // ~So@Gui@RenderArea()

// *************************************************************************

/*!
  A hook invoked after window has been realized.
*/

void
So@Gui@RenderArea::afterRealizeHook(void)
{
  inherited::afterRealizeHook();

#ifdef HAVE_JOYSTICK_LINUX
  if ( So@Gui@LinuxJoystick::exists() )
    this->registerDevice( new So@Gui@LinuxJoystick );
#endif // HAVE_JOYSTICK_LINUX

  if ( So@Gui@Spaceball::exists() )
    this->registerDevice( new So@Gui@Spaceball );
} // afterRealizeHook()

/*!
  This method sets the scene graph for the normal scene.
*/

void
So@Gui@RenderArea::setSceneGraph( // virtual
  SoNode * scene )
{
  PRIVATE(this)->normalManager->setSceneGraph( scene );
} // setSceneGraph()

/*!
  This method returns the scene graph for the normal scene.
*/

SoNode *
So@Gui@RenderArea::getSceneGraph( // virtual
  void )
{
  return PRIVATE(this)->normalManager->getSceneGraph();
} // getSceneGraph()

/*!
  This method sets the scene graph for the overlay scene.
*/

void
So@Gui@RenderArea::setOverlaySceneGraph(
  SoNode * scene )
{
  // FIXME: when an overlay scenegraph is attempted registered with
  // the SoQtRenderArea -- try to make a QGLWidget with overlay
  // planes, and if that's not possible, display a warning.
  // 20010805 mortene.

  PRIVATE(this)->overlayManager->setSceneGraph( scene );
} // setOverlaySceneGraph()

/*!
  This method returns the scene graph for the overlay scene.
*/

SoNode *
So@Gui@RenderArea::getOverlaySceneGraph(
  void )
{
  return PRIVATE(this)->overlayManager->getSceneGraph();
} // getOverlaySceneGraph()

// *************************************************************************

/*!
  This method add \a device to the list of devices handling events for this
  component.
*/

void
So@Gui@RenderArea::registerDevice(
  So@Gui@Device * device )
{
  int idx = deviceList->find(device);
  if (idx == -1)
    deviceList->append(device);

  device->setWindowSize( this->getGLSize() );
  if (idx == -1)
    device->enable( this->getGLWidget(), 
      &So@Gui@GLWidget::eventHandler, (void*) this );
} // registerDevice()

/*!
  This method removes \a device from the list of devices handling events for
  this component.
*/

void
So@Gui@RenderArea::unregisterDevice(
  So@Gui@Device * device )
{
  assert( this->deviceList != NULL );
  const int idx = this->deviceList->find( device );
  if ( idx == -1 ) {
#if SO@GUI@_DEBUG
    SoDebugError::post( "So@Gui@RenderArea::unregisterDevice",
        "tried to remove nonexisting device" );
#endif // SO@GUI@_DEBUG
    return;
  }
  this->deviceList->remove( idx );
  device->disable( this->getGLWidget(), NULL, NULL );
} // unregisterDevice()

// *************************************************************************

/*!
  This method sets the background color of the scene.
*/

void
So@Gui@RenderArea::setBackgroundColor(
  const SbColor & color )
{
  assert( PRIVATE(this)->normalManager != NULL );
  PRIVATE(this)->normalManager->setBackgroundColor( color );
} // setBackgroundColor()

/*!
  This method returns the background color for the scene.
*/

const SbColor &
So@Gui@RenderArea::getBackgroundColor(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getBackgroundColor();
} // getBackgroundColor()

// *************************************************************************

/*!
  This method sets the index of the background color for the scene.
*/

void
So@Gui@RenderArea::setBackgroundIndex(
  int idx )
{
  assert( PRIVATE(this)->normalManager != NULL );
  PRIVATE(this)->normalManager->setBackgroundIndex( idx );
} // setBackgroundIndex()

/*!
  This method returns the index of the background color for the scene.
*/

int
So@Gui@RenderArea::getBackgroundIndex(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getBackgroundIndex();
} // getBackgroundIndex()

// *************************************************************************

/*!
  This method sets the index of the background for the overlay scene.
*/

void
So@Gui@RenderArea::setOverlayBackgroundIndex(
  int idx )
{
  assert( PRIVATE(this)->overlayManager != NULL );
  PRIVATE(this)->overlayManager->setBackgroundIndex( idx );
} // setOverlayBackgroundIndex()

/*!
  This method returns the index of the background for the overlay scene.
*/

int
So@Gui@RenderArea::getOverlayBackgroundIndex(
  void ) const
{
  assert( PRIVATE(this)->overlayManager != NULL );
  return PRIVATE(this)->overlayManager->getBackgroundIndex();
} // getOverlayBackgroundIndex()

// *************************************************************************

/*!
  This method sets the colormap for the scene.
*/

void
So@Gui@RenderArea::setColorMap(
  int start,
  int num,
  const SbColor * colors )
{
  delete [] PRIVATE(this)->normalColormap;
  PRIVATE(this)->normalColormapStart = start;
  PRIVATE(this)->normalColormapSize = num;
  PRIVATE(this)->normalColormap = new SbColor [ num ];
  for ( int i = 0; i < num; i++ )
    PRIVATE(this)->normalColormap[i] = colors[i];
} // setColorMap()

/*!
  This method sets the colormap for the overlay scene.
*/

void
So@Gui@RenderArea::setOverlayColorMap(
  int start,
  int num,
  const SbColor * colors )
{
  delete [] PRIVATE(this)->overlayColormap;
  PRIVATE(this)->overlayColormapStart = start;
  PRIVATE(this)->overlayColormapSize = num;
  PRIVATE(this)->overlayColormap = new SbColor [ num ];
  for ( int i = 0; i < num; i++ )
    PRIVATE(this)->overlayColormap[i] = colors[i];
} // setOverlayColorMap()

// *************************************************************************

/*!
  This method sets the viewport region.
*/

void
So@Gui@RenderArea::setViewportRegion(
  const SbViewportRegion & region )
{
  if ( region.getWindowSize()[0] == -1 ) return;

#if SO@GUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@Gui@RenderArea::setViewportRegion",
                         "size=<%d, %d>",
                         region.getWindowSize()[0],
                         region.getWindowSize()[1]);
#endif // debug

  PRIVATE(this)->normalManager->setViewportRegion( region );
  PRIVATE(this)->overlayManager->setViewportRegion( region );
} // setViewportRegion()

/*!
  This method returns the viewport region.
*/

const SbViewportRegion &
So@Gui@RenderArea::getViewportRegion(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getGLRenderAction()->getViewportRegion();
} // getViewportRegion()

// *************************************************************************

/*!
  This method sets the transparency type to be used for the scene.
*/

void
So@Gui@RenderArea::setTransparencyType(
  SoGLRenderAction::TransparencyType type )
{
  assert( PRIVATE(this)->normalManager != NULL );
  PRIVATE(this)->normalManager->getGLRenderAction()->setTransparencyType( type );
//  PRIVATE(this)->overlayManager->getGLRenderAction()->setTransparencyType( type );
} // setTransparencyType()

/*!
  This method returns the transparency type used for the scene.
*/

SoGLRenderAction::TransparencyType
So@Gui@RenderArea::getTransparencyType(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getGLRenderAction()->getTransparencyType();
} // getTransparencyType()

// *************************************************************************

/*!
  This method sets the antialiasing used for the scene.
*/

void
So@Gui@RenderArea::setAntialiasing(
  SbBool smoothing,
  int numPasses )
{
  // FIXME: is this really necessary? I think we should either ignore
  // the call or store values for later migration if the scenemanager
  // instance(s) haven't been made yet. 20010331 mortene.
  assert( PRIVATE(this)->normalManager != NULL );

  // Instead of piping the call further to
  // SoSceneManager::setAntialiasing(), we duplicate the code found in
  // that function. The reason for this is that we want to work around
  // a bug found in SGI Inventor, where they define the
  // setAntialiasing() method, but doesn't actually implement it.  So
  // we don't use it to avoid a linker error for those compiling So*
  // libraries on top of the older SGI Inventor versions with this
  // bug.
  //
  // We should perhaps throw in a configure check for the
  // SoSceneManager::setAntialiasing() method and only activate this
  // code when actually needed?
  //                                                   mortene@sim.no
  enum { MGRS = 2 };
  SoSceneManager * mgrs[MGRS] = { PRIVATE(this)->normalManager,
                                  PRIVATE(this)->overlayManager };
  for (int i=0; i < MGRS; i++) {
    SoGLRenderAction * glra = mgrs[i]->getGLRenderAction();
    if (glra) {
      glra->setSmoothing(smoothing);
      glra->setNumPasses(numPasses);
    }
  }
} // setAntialiasing()

/*!
  This method returns the antialiasing used for the scene.
*/

void
So@Gui@RenderArea::getAntialiasing(
  SbBool & smoothing,
  int & numPasses) const
{
  // FIXME: there's an API design flaw here, as it is assumed that the
  // antialiasing setting for the renderaction in the "normal"
  // rendering context always matches what is the case for the
  // renderaction in the overlay manager. This is not necessarily
  // true. Could be solved by an additional argument to
  // getAntialiasing(): a boolean indicator on whether or not we want
  // the overlay context with a default value (false) to keep API
  // compatibility. 20010331 mortene.

  assert( PRIVATE(this)->normalManager != NULL );

  // About why we don't use SoSceneManager::getAntialiasing()
  // directly, see comment in SoGuiRenderArea::setAntiAliasing().
  SoGLRenderAction * glra = PRIVATE(this)->normalManager->getGLRenderAction();
  smoothing = glra->isSmoothing();
  numPasses = glra->getNumPasses();
} // getAntialiasing()

/*!
  This method sets whether the render buffer should be cleared before
  rendering.
*/

void
So@Gui@RenderArea::setClearBeforeRender(
  SbBool enable,
  SbBool zbEnable )
{
  PRIVATE(this)->clear = enable;
  PRIVATE(this)->clearZBuffer = zbEnable;
} // setClearBeforeRender()

/*!
  This method returns whether the render buffer is cleared before each
  render.
*/

SbBool
So@Gui@RenderArea::isClearBeforeRender(
  void ) const
{
  return PRIVATE(this)->clear;
} // isClearBeforeRender()

/*!
  This method returns whether the render buffer's Z buffer is cleared before
  each render.
*/

SbBool
So@Gui@RenderArea::isClearZBufferBeforeRender(
  void ) const
{
  return PRIVATE(this)->clearZBuffer;
} // isClearZBufferBeforeRender()

/*!
  This method sets whether the overlay render buffer should be cleared before
  each render or not.
*/

void
So@Gui@RenderArea::setClearBeforeOverlayRender(
  SbBool enable )
{
  PRIVATE(this)->clearOverlay = enable;
} // setClearBeforeOverlayRender()

/*!
  This method returns whether the overlay render buffer is cleared before
  each redraw or not.
*/

SbBool
So@Gui@RenderArea::isClearBeforeOverlayRender(
  void ) const
{
  return PRIVATE(this)->clearOverlay;
} // isClearBeforeOverlayRender()

/*!
  This methor sets whether redrawing should be handled automatically or not.
*/

void
So@Gui@RenderArea::setAutoRedraw(
  SbBool enable )
{
  if ( enable ) {
    PRIVATE(this)->normalManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
    PRIVATE(this)->overlayManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
  }
  else {
    PRIVATE(this)->normalManager->setRenderCallback( NULL, NULL );
    PRIVATE(this)->overlayManager->setRenderCallback( NULL, NULL );
  }

  // We can not use the render callback ptr as a flag, as the render
  // callback pointer will be set upon expose events and forced
  // redraws -- and autoRedraw is then used to remember that the
  // pointer should be set back to NULL again after redraw.
  PRIVATE(this)->autoRedraw = enable;
} // setAutoRedraw()

/*!
  Thie method returns whether redrawing is handled automatically or not.
*/

SbBool
So@Gui@RenderArea::isAutoRedraw(
  void ) const
{
  return PRIVATE(this)->autoRedraw;
} // isAutoRedraw()

/*!
  This method sets the redraw priority.
*/

void
So@Gui@RenderArea::setRedrawPriority(
  uint32_t priority )
{
  PRIVATE(this)->normalManager->setRedrawPriority( priority );
  PRIVATE(this)->overlayManager->setRedrawPriority( priority );
} // setRedrawPriority()

/*!
  This method returns the redraw priority.
*/

uint32_t
So@Gui@RenderArea::getRedrawPriority(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getRedrawPriority();
} // getRedrawPriority()

/*!
  This function returns the default redraw priority.
*/

uint32_t
So@Gui@RenderArea::getDefaultRedrawPriority( // static
  void )
{
  return SoSceneManager::getDefaultRedrawPriority();
} // getDefaultRedrawPriority()

/*!
  This method renders the scene.
*/

void
So@Gui@RenderArea::render(
  void )
{
  this->redraw();
} // render()

/*!
  This method renders the overlay scene.
*/

void
So@Gui@RenderArea::renderOverlay(
  void )
{
  this->redrawOverlay();
} // renderOverlay()

/*!
  This method schedules a redraw to happen at a later time (when the
  application has processed it's other events first).
*/

void
So@Gui@RenderArea::scheduleRedraw(
  void )
{
#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::scheduleRedraw",
                         "invoked");
#endif // debug

  assert( PRIVATE(this)->normalManager != NULL );
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->normalManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
  PRIVATE(this)->normalManager->scheduleRedraw(); // Redraw when idle.
} // scheduleRedraw()

/*!
  This method schedules a redraw of the overlay scene.
*/

void
So@Gui@RenderArea::scheduleOverlayRedraw(
  void )
{
  assert( PRIVATE(this)->overlayManager != NULL );
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  PRIVATE(this)->overlayManager->setRenderCallback( So@Gui@RenderArea::renderCB, this );
  PRIVATE(this)->overlayManager->scheduleRedraw(); // Redraw when idle.
} // scheduleOverlayRedraw()

/*!
  Do automatic redraw of the scenegraph when a selection under the
  SoSelection node is changed.

  Pass \c NULL to deactivate.

  (Only one SoSelection node can be monitored at any given time. This
  is obviously a rather silly design flaw. We choose to match the
  original Inventor API here, but this will probably change in the
  next major revision of the library.)
*/

void
So@Gui@RenderArea::redrawOnSelectionChange(
  SoSelection * selection )
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation. 20001002 mortene.

  if ( PRIVATE(this)->normalSelection ) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->normalSelection->removeChangeCallback( So@Gui@RenderArea::selection_redraw_cb, this );
  }

  PRIVATE(this)->normalSelection = selection;

  if ( selection )
    selection->addChangeCallback( So@Gui@RenderArea::selection_redraw_cb, this );

} // redrawOnSelectionChange()

/*!
  Do automatic redraw of the scenegraph in the overlay planes when a
  selection under the SoSelection node is changed.

  Pass \c NULL to deactivate.

  \sa So@Gui@RenderArea::redrawOnSelectionChange()
*/

void
So@Gui@RenderArea::redrawOverlayOnSelectionChange(
  SoSelection * selection )
{
  // FIXME: this interface is badly designed, see the comment above in
  // the function documentation on redrawOnSelectionChange(). 20001002 mortene.

  if ( PRIVATE(this)->overlaySelection ) {
    // FIXME: should we ref() and unref() to make sure we can't get a
    // crash here? 20001002 mortene.
    PRIVATE(this)->overlaySelection->removeChangeCallback( So@Gui@RenderArea::selection_redraw_cb, this );
  }

  PRIVATE(this)->overlaySelection = selection;

  if ( selection )
    selection->addChangeCallback( So@Gui@RenderArea::selection_redraw_cb, this );

} // redrawOverlayOnSelectionChange()

/*!
  This method sets the render area event callback.
*/

void
So@Gui@RenderArea::setEventCallback(
  So@Gui@RenderAreaEventCB * func,
  void * user )
{
  this->appEventHandler = func;
  this->appEventHandlerData = user;
} // setEventCallback()

/*!
  This method sets the normal scene SoSceneManager object.
*/

void
So@Gui@RenderArea::setSceneManager(
  SoSceneManager * manager )
{
  assert( PRIVATE(this)->normalManager != NULL );
  PRIVATE(this)->normalManager = manager;
} // setSceneManager()

/*!
  This method returns the normal scene SoSceneManager object.
*/

SoSceneManager *
So@Gui@RenderArea::getSceneManager(
  void ) const
{
  return PRIVATE(this)->normalManager;
} // getSceneManager()

/*!
  This method sets the overlay scene SoSceneManager object.
*/

void
So@Gui@RenderArea::setOverlaySceneManager(
  SoSceneManager * manager )
{
  PRIVATE(this)->overlayManager = manager;
} // setOverlaySceneManager()

/*!
  This method returns the overlay scene SoSceneManager object.
*/

SoSceneManager *
So@Gui@RenderArea::getOverlaySceneManager(
  void ) const
{
  return PRIVATE(this)->overlayManager;
} // getOverlaySceneManager()

/*!
  This method sets the SoGLRenderAction object for the normal scene.
*/

void
So@Gui@RenderArea::setGLRenderAction(
  SoGLRenderAction * action )
{
  assert( PRIVATE(this)->normalManager != NULL );
  PRIVATE(this)->normalManager->setGLRenderAction( action );
  // Force an update of the SoGLRenderAction to the correct
  // updatearea, aspectratio, etc.
  this->sizeChanged( this->getSize() );
} // setGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the normal scene.
*/

SoGLRenderAction *
So@Gui@RenderArea::getGLRenderAction(
  void ) const
{
  assert( PRIVATE(this)->normalManager != NULL );
  return PRIVATE(this)->normalManager->getGLRenderAction();
} // getGLRenderAction()

/*!
  This method sets the SoGLRenderAction object for rendering the overlay
  scen graph.
*/

void
So@Gui@RenderArea::setOverlayGLRenderAction(
  SoGLRenderAction * action )
{
  assert( PRIVATE(this)->overlayManager != NULL );
  PRIVATE(this)->overlayManager->setGLRenderAction( action );
} // setOverlayGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the overlay scene
  graph.
*/

SoGLRenderAction *
So@Gui@RenderArea::getOverlayGLRenderAction(
  void ) const
{
  assert( PRIVATE(this)->overlayManager != NULL );
  return PRIVATE(this)->overlayManager->getGLRenderAction();
} // getOverlayGLRenderAction()

/*!
  This method redraws the normal scene graph.
*/

void
So@Gui@RenderArea::redraw( // virtual, protected
  void )
{
#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::render",
                         "start (isVisible=%s waitForExpose=%s)",
                         this->isVisible() ? "TRUE" : "FALSE",
                         this->waitForExpose ? "TRUE" : "FALSE");
#endif // debug

  if ( ! this->isVisible() || !this->hasNormalGLArea() || this->waitForExpose )
    return;
  this->glLockNormal(); // this makes the GL context "current"

  SbBool drawfront =
    ! this->isDoubleBuffer() ||
    this->isDrawToFrontBufferEnable();

  glDrawBuffer( drawfront ? GL_FRONT : GL_BACK);

  this->actualRedraw();

  if ( !drawfront ) { this->glSwapBuffers(); }
  else { this->glFlushBuffer(); }
  this->glUnlockNormal();

#if SO@GUI@_DEBUG && RENDERAREA_DEBUG_REDRAWS // debug
  SoDebugError::postInfo("So@Gui@RenderArea::render", "done");
#endif // debug
} // redraw()

/*!
  This method redraws the normal scene graph.
*/

void
So@Gui@RenderArea::actualRedraw( // virtual, protected
  void )
{
  assert( PRIVATE(this)->normalManager != NULL );
  if ( ! this->isVisible() ) return;
  PRIVATE(this)->normalManager->render( PRIVATE(this)->clear, PRIVATE(this)->clearZBuffer );
} // actualRedraw()

/*!
  This method redraws the overlay scene.
*/

void
So@Gui@RenderArea::redrawOverlay( // virtual, protected
  void )
{
  if (!this->isVisible() || this->waitForExpose || !this->hasOverlayGLArea()) return;
  
  glLockOverlay();
  this->actualOverlayRedraw();
  this->glFlushBuffer();
  glUnlockOverlay();
} // redrawOverlay()

/*!
  This method renders the overlay scene.
*/

void
So@Gui@RenderArea::actualOverlayRedraw( // virtual, protected
  void )
{
  assert( PRIVATE(this)->overlayManager != NULL );
  if ( ! this->isVisible() ) return;
  PRIVATE(this)->overlayManager->render( PRIVATE(this)->clearOverlay, PRIVATE(this)->clearZBuffer );
} // actualOverlayRedraw()

/*!
  This method is invoked to initialize the normal graphics.
*/

void
So@Gui@RenderArea::initGraphic( // virtual, protected
  void )
{
  SoSceneManager * mgr = this->getSceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(this->isRGBMode());
    mgr->getGLRenderAction()->setCacheContext(SoAny::si()->getSharedCacheContextId((void*) this));  
  }
  // FIXME: should init cache context stuff,
  // FIXME: if not RGB mode, load colormap

  inherited::initGraphic();
} // initGraphic()

/*!
  This method is invoked to initialize the overlay graphics.
*/

void
So@Gui@RenderArea::initOverlayGraphic( // virtual, protected
  void )
{
  SoSceneManager * mgr = this->getOverlaySceneManager();
  if (mgr) {
    mgr->reinitialize();
    mgr->setRGBMode(FALSE);
  }
  // FIXME: load colormap
} // initOverlayGraphic()

/*!
  This method is
*/

void
So@Gui@RenderArea::sizeChanged( // virtual, protected
  const SbVec2s size )
{
#if SO@GUI@_DEBUG && 0
  SoDebugError::postInfo( "So@Gui@RenderArea::sizeChanged",
                          "invoked, <%d, %d>", size[0], size[1] );
#endif // SO@GUI@_DEBUG

  if ( size[0] == -1 )
    return;

  assert( PRIVATE(this)->normalManager != NULL );
  assert( PRIVATE(this)->overlayManager != NULL );

  this->setGLSize(size);
  const SbVec2s glsize = this->getGLSize();

#if SO@GUI@_DEBUG && 0
  SoDebugError::postInfo( "So@Gui@RenderArea::sizeChanged",
                          "glsize==<%d, %d>", glsize[0], glsize[1] );
#endif // SO@GUI@_DEBUG

  if ( glsize[0] <= 0 || glsize[1] <= 0 )
    return;

  this->setViewportRegion( SbViewportRegion( glsize ) );
  this->setDevicesWindowSize( glsize );

  PRIVATE(this)->normalManager->setWindowSize( glsize );
  PRIVATE(this)->normalManager->setSize( glsize );

  PRIVATE(this)->overlayManager->setWindowSize( glsize );
  PRIVATE(this)->overlayManager->setSize( glsize );

  this->scheduleRedraw();
} // sizeChanged()

// Documented in superclass.
void
So@Gui@RenderArea::widgetChanged( // virtual, protected
  @WIDGET@ widget )
{
  PRIVATE(this)->normalManager->reinitialize();
  PRIVATE(this)->overlayManager->reinitialize();
  // FIXME: colorindex mode not supported yet, so this has no
  // effect. 20001121 mortene.
#if 0
  PRIVATE(this)->normalManager->setRGBMode(this->isRGBMode());
  PRIVATE(this)->overlayManager->setRGBMode(this->isRGBMode());
#endif

  // FIXME: this code needs to be enabled (and rewritten to work) to
  // handle display list caching. 20001121 mortene.
  // UPDATE: check with pederb if any of this is really needed, or if
  // it should just be removed. 20010802 mortene.
#if 0
  SoGLRenderAction * ra = PRIVATE(this)->normalManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
  ra = PRIVATE(this)->overlayManager->getGLRenderAction();
  ra->setCacheContext(XXX);
  ra->setRenderingIsRemote(XXX);
#endif

  // FIXME: should also walk through all registered devices and do a
  // disable() on the old widget and enable() on the new one.
  // 20001121 mortene.

} // widgetChanged()

/*!
  This method builds the So@Gui@RenderArea contents in the \a parent
  widget.
*/

@WIDGET@
So@Gui@RenderArea::buildWidget( // protected
  @WIDGET@ parent )
{
  @WIDGET@ widget = inherited::buildWidget( parent );
  if ( this->deviceList != NULL ) {
    const int num = this->deviceList->getLength();
    for ( int i = 0; i < num; i++ ) {
      So@Gui@Device * device = (So@Gui@Device *) (*this->deviceList)[i];
      device->enable( this->getGLWidget(),
        &inherited::eventHandler, (void *) this );
    }
  }
  const SbVec2s glsize = this->getGLSize();
  if ( glsize[0] <= 0 || glsize[1] <= 0 )
    return widget;

/*
  this->setDevicesWindowSize( glsize );

  this->setViewportRegion( SbViewportRegion( glsize[0], glsize[1] ) );
  PRIVATE(this)->normalManager->setViewportRegion( SbViewportRegion( glsize[0], glsize[1] ) );
  PRIVATE(this)->overlayManager->setViewportRegion( SbViewportRegion( glsize[0], glsize[1] ) );
*/
  return widget;
} // buildWidget()

/*!
  This method returns a default widget name for the base widget.
*/

const char *
So@Gui@RenderArea::getDefaultWidgetName( // virtual, protected
  void ) const
{
  static const char defaultWidgetName[] = "So@Gui@WidgetName";
  return defaultWidgetName;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window.
*/

const char *
So@Gui@RenderArea::getDefaultTitle( // virtual, protected
  void ) const
{
  static const char defaultTitle[] = "@Gui@ RenderArea";
  return defaultTitle;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window icon.
*/

const char *
So@Gui@RenderArea::getDefaultIconTitle( // virtual, protected
  void ) const
{
  static const char defaultIconTitle[] = "@Gui@ RenderArea";
  return defaultIconTitle;
} // getDefaultIconTitle()

/*!
  This method invokes the application event handler, if one is set.
*/

SbBool
So@Gui@RenderArea::invokeAppCB( // protected
  @EVENT@ event )
{
  if ( this->appEventHandler != NULL )
    return this->appEventHandler( this->appEventHandlerData, event );
  return FALSE;
} // invokeAppCB()

// *************************************************************************

/*!
  FIXME: write doc
*/

SbBool
So@Gui@RenderArea::processSoEvent( // virtual
  const SoEvent * const event )
{
  if ( PRIVATE(this)->overlayManager->processEvent( event ) )
    return TRUE;
  if ( PRIVATE(this)->normalManager->processEvent( event ) )
    return TRUE;
  return FALSE;
} // processSoEvent()

// *************************************************************************

/*!
  FIXME: write doc
*/

void
So@Gui@RenderArea::processEvent( // virtual, protected
  @EVENT@ event )
{
  if ( this->invokeAppCB( event ) )
    return;

  const SoEvent * soevent = this->getSoEvent( event );

  if ( soevent != NULL ) {
    SbBool processed = this->processSoEvent(soevent);
    if ( processed ) return;
  }

  inherited::processEvent( event );
} // processEvent()

// *************************************************************************

// doc from parent
SbBool 
So@Gui@RenderArea::glScheduleRedraw(void)
{
  this->scheduleRedraw();
  if (this->hasOverlayGLArea() && this->getOverlaySceneGraph()) {
    this->scheduleOverlayRedraw();
  }
  return TRUE;
}


/*!
  This method returns an SoEvent * corresponding to the given \a
  event, or \c NULL if there are none.
*/

const SoEvent *
So@Gui@RenderArea::getSoEvent(
  @EVENT@ event )
{
  if ( ! this->deviceList )
    return (SoEvent *) NULL;

  const SoEvent * soevent = NULL;
  const int num = this->deviceList->getLength();
  for ( int i = 0; (i < num) && (soevent == NULL); i++ )
    soevent = ((So@Gui@Device *)(*this->deviceList)[i])->translateEvent( event );

  return soevent;
} // getSoEvent()

// *************************************************************************

/*!
  This method sets the window size data in all the connected device classes.
*/

void
So@Gui@RenderArea::setDevicesWindowSize(
  const SbVec2s size )
{
  if ( ! this->deviceList ) return;
  const int num = this->deviceList->getLength();
  for ( int i = 0; i < num; i++ )
    ((So@Gui@Device *)(*this->deviceList)[i])->setWindowSize( size );
} // setDevicesWindowSize()

// *************************************************************************

/*!
  FIXME: write doc
*/

void
So@Gui@RenderArea::renderCB( // static
  void * closure,
  SoSceneManager * manager )
{
  So@Gui@RenderArea * thisptr = (So@Gui@RenderArea *) closure;
  if ( manager == PRIVATE(thisptr)->normalManager )
    thisptr->render();
  else if ( manager == PRIVATE(thisptr)->overlayManager )
    thisptr->renderOverlay();
  else assert(0);

  if ( !thisptr->isAutoRedraw() )
    manager->setRenderCallback( NULL, NULL );
} // renderCB()

/*!
  Callback for automatic redraw on SoSelection changes.
*/

void
So@Gui@RenderArea::selection_redraw_cb( // static
  void * closure,
  SoSelection * sel )
{
  So@Gui@RenderArea * ra = (So@Gui@RenderArea *) closure;
  if ( sel == PRIVATE(ra)->normalSelection )
    ra->scheduleRedraw();
  else if ( sel == PRIVATE(ra)->overlaySelection )
    ra->scheduleOverlayRedraw();
  else
    assert( 0 && "callback on unknown SoSelection node" );
} // selection_redraw_cb

// *************************************************************************

/*!
  Private class constructor.
*/

So@Gui@RenderAreaP::So@Gui@RenderAreaP(
  So@Gui@RenderArea * pub )
{
  PUBLIC(this) = pub;

  this->normalManager = new SoSceneManager;
  this->overlayManager = new SoSceneManager;

  this->normalColormap = NULL;
  this->normalColormapSize = 0;
  this->overlayColormap = NULL;
  this->overlayColormapSize = 0;

  this->clear = TRUE;
  this->clearZBuffer = TRUE;
  this->clearOverlay = TRUE;
  this->autoRedraw = TRUE;

  this->normalSelection = NULL;
  this->overlaySelection = NULL;

  this->devices.mouse = NULL;
  this->devices.keyboard = NULL;

} // So@Gui@RenderAreaP()

/*!
  Private class destructor.
*/

So@Gui@RenderAreaP::~So@Gui@RenderAreaP(
  void )
{
  delete this->normalManager;
  delete this->overlayManager;
  delete [] this->normalColormap;
  delete [] this->overlayColormap;
} // ~So@Gui@RenderAreaP()

// *************************************************************************

#if SO@GUI@_DEBUG
static const char * getSo@Gui@RenderAreaRCSId(void) { return rcsid; }
#endif // SO@GUI@_DEBUG
