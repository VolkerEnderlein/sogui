/**************************************************************************
 *
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  This file is part of the Coin library.
 *
 *  This file may be distributed under the terms of the Q Public License
 *  as defined by Troll Tech AS of Norway and appearing in the file
 *  LICENSE.QPL included in the packaging of this file.
 *
 *  If you want to use Coin in applications not covered by licenses
 *  compatible with the QPL, you can contact SIM to aquire a
 *  Professional Edition license for Coin.
 *
 *  Systems in Motion AS, Prof. Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ sales@sim.no Voice: +47 22114160 Fax: +47 67172912
 *
 **************************************************************************/

// @configure_input@

#if SO@uGUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@uGUI@_DEBUG

/**************************************************************************\
 *
 *  A WORD OF ADVICE
 *
 *  It is fruitless to modify the contents of the So@GUI@RenderArea.cpp file
 *  because it is autogenerated by configure from the SoGuiRenderArea.cpp.in
 *  file which you will find in the src/Inventor/@GUI@/common/ directory.
 *  Do your modifications to that file instead.
 *
\**************************************************************************/

/*!
  \class So@Gui@RenderArea Inventor/@Gui@/So@Gui@RenderArea.h
  \brief The So@Gui@RenderArea class is a component that adds scene graph
  management and input device handling to the So@Gui@GLWidget component.
  \ingroup components

  The So@Gui@RenderArea class is almost completely autogenerated from
  generic source code.
*/

// *************************************************************************

#include <assert.h>

#include <Inventor/errors/SoDebugError.h>
#include <Inventor/misc/SoBasic.h>
#include <Inventor/SoSceneManager.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

#include <so@lGUI@defs.h>
#include <Inventor/@GUI@/So@GUI@Basic.h>
#include <Inventor/@GUI@/devices/So@GUI@Mouse.h>
#include <Inventor/@GUI@/devices/So@GUI@Keyboard.h>
#include <Inventor/@GUI@/devices/So@GUI@Spaceball.h>
#ifdef HAVE_JOYSTICK_LINUX
#include <Inventor/@GUI@/devices/So@GUI@LinuxJoystick.h>
#endif // HAVE_JOYSTICK_LINUX

#include <Inventor/@GUI@/So@GUI@RenderArea.h>

#include <GL/gl.h> // glDrawBuffer()

// *************************************************************************

// Metadon doc:
/*¡
  FIXME: the overlay support is not in place yet. 20000319 mortene.
*/

// *************************************************************************

/*!
  \var So@Gui@RenderAreaEventCB * So@Gui@RenderArea::appEventHandler;

  This is an application-settable event callback that will be called with
  X events destined for the renderarea.

  Set this member through the access methods, not directly.
*/

/*!
  \var void * So@Gui@RenderArea::appEventHandlerData;

  This member is the closure given to the application event handler.

  Set this member through the access methods, not directly.
*/

// *************************************************************************

/*!
  Public constructor.
*/

So@GUI@RenderArea::So@GUI@RenderArea(
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput )
: inherited( parent, name, embed, SO_GL_DEFAULT_MODE, FALSE )
{
  this->constructor( mouseInput, keyboardInput, TRUE );
} // So@GUI@RenderArea()

/*!
  Protected constructor used by derived classes.
*/

So@GUI@RenderArea::So@GUI@RenderArea( // protected
  @WIDGET@ parent,
  const char * name,
  SbBool embed,
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build )
: inherited( parent, name, embed, SO_GL_DEFAULT_MODE, FALSE )
{
  this->constructor( mouseInput, keyboardInput, build );
} // So@GUI@RenderArea()

/*!
  Common code for all constructors.
*/

void
So@GUI@RenderArea::constructor( // private
  SbBool mouseInput,
  SbBool keyboardInput,
  SbBool build )
{
  this->normalManager = new SoSceneManager;
  this->normalManager->setRenderCallback( So@GUI@RenderArea::renderCB, this );
  this->normalManager->activate();

  this->overlayManager = new SoSceneManager;
  this->overlayManager->activate();

  this->normalColormap = NULL;
  this->normalColormapSize = 0;
  this->overlayColormap = NULL;
  this->overlayColormapSize = 0;

  this->clear = TRUE;
  this->clearZBuffer = TRUE;
  this->clearOverlay = TRUE;
  this->autoRedraw = TRUE;

  this->normalSelection = NULL;
  this->overlaySelection = NULL;

  this->devices.mouse = mouseInput ? new So@GUI@Mouse : NULL;
  this->devices.keyboard = keyboardInput ? new So@GUI@Keyboard : NULL;
  this->devices.extra = NULL;

  if ( So@GUI@Spaceball::exists() )
    this->registerDevice( new So@GUI@Spaceball );
#ifdef HAVE_JOYSTICK_LINUX
  if ( So@GUI@LinuxJoystick::exists() )
    this->registerDevice( new So@GUI@LinuxJoystick );
#endif // HAVE_JOYSTICK_LINUX

  this->appEventHandler = NULL;

  if ( build ) {
    this->setClassName( "So@GUI@RenderArea" );
    @WIDGET@ glarea = this->buildWidget( this->getParentWidget() );
    this->setBaseWidget( glarea );
    this->setSize( SbVec2s( 400, 400 ) );
  }
} // constructor()

/*!
  Destructor.
*/

So@GUI@RenderArea::~So@GUI@RenderArea(
  void )
{
  delete this->normalManager;
  delete this->overlayManager;
  delete [] this->normalColormap;
  delete [] this->overlayColormap;
  delete this->devices.mouse;
  delete this->devices.keyboard;
  delete this->devices.extra;
} // ~So@GUI@RenderArea()

// *************************************************************************

/*!
  This method sets the scene graph for the normal scene.
*/

void
So@GUI@RenderArea::setSceneGraph( // virtual
  SoNode * scene )
{
  this->normalManager->setSceneGraph( scene );
} // setSceneGraph()

/*!
  This method returns the scene graph for the normal scene.
*/

SoNode *
So@GUI@RenderArea::getSceneGraph( // virtual
  void )
{
  return this->normalManager->getSceneGraph();
} // getSceneGraph()

/*!
  This method sets the scene graph for the overlay scene.
*/

void
So@GUI@RenderArea::setOverlaySceneGraph(
  SoNode * scene )
{
  this->overlayManager->setSceneGraph( scene );
} // setOverlaySceneGraph()

/*!
  This method returns the scene graph for the overlay scene.
*/

SoNode *
So@GUI@RenderArea::getOverlaySceneGraph(
  void )
{
  return this->overlayManager->getSceneGraph();
} // getOverlaySceneGraph()

// *************************************************************************

/*!
  This method add \a device to the list of devices handling events for this
  component.
*/

void
So@GUI@RenderArea::registerDevice(
  So@GUI@Device * device )
{
  if ( ! this->devices.extra )
    this->devices.extra = new SbPList;
  this->devices.extra->append( device );
  device->setWindowSize( this->getGLSize() );
} // registerDevice()

/*!
  This method removes \a device from the list of devices handling events for
  this component.
*/

void
So@GUI@RenderArea::unregisterDevice(
  So@GUI@Device * device )
{
  assert( this->devices.extra != NULL );
  int idx = this->devices.extra->find( device );
  if ( idx != -1 ) {
    this->devices.extra->remove( idx );
#if SO@uGUI@_DEBUG
  } else {
    SoDebugError::post( "So@GUI@RenderArea::unregisterDevice",
        "tried to remove nonexisting device" );
#endif // SO@uGUI@_DEBUG
  }
} // unregisterDevice()

// *************************************************************************

/*!
  This method sets the background color of the scene.
*/

void
So@GUI@RenderArea::setBackgroundColor(
  const SbColor & color )
{
  assert( this->normalManager != NULL );
  this->normalManager->setBackgroundColor( color );
} // setBackgroundColor()

/*!
  This method returns the background color for the scene.
*/

const SbColor &
So@GUI@RenderArea::getBackgroundColor(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getBackgroundColor();
} // getBackgroundColor()

// *************************************************************************

/*!
  This method sets the index of the background color for the scene.
*/

void
So@GUI@RenderArea::setBackgroundIndex(
  int idx )
{
  assert( this->normalManager != NULL );
  this->normalManager->setBackgroundIndex( idx );
} // setBackgroundIndex()

/*!
  This method returns the index of the background color for the scene.
*/

int
So@GUI@RenderArea::getBackgroundIndex(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getBackgroundIndex();
} // getBackgroundIndex()

// *************************************************************************

/*!
  This method sets the index of the background for the overlay scene.
*/

void
So@GUI@RenderArea::setOverlayBackgroundIndex(
  int idx )
{
  assert( this->overlayManager != NULL );
  this->overlayManager->setBackgroundIndex( idx );
} // setOverlayBackgroundIndex()

/*!
  This method returns the index of the background for the overlay scene.
*/

int
So@GUI@RenderArea::getOverlayBackgroundIndex(
  void ) const
{
  assert( this->overlayManager != NULL );
  return this->overlayManager->getBackgroundIndex();
} // getOverlayBackgroundIndex()

// *************************************************************************

/*!
  This method sets the colormap for the scene.
*/

void
So@GUI@RenderArea::setColorMap(
  int start,
  int num,
  const SbColor * colors )
{
  delete [] this->normalColormap;
  this->normalColormapStart = start;
  this->normalColormapSize = num;
  this->normalColormap = new SbColor [ num ];
  for ( int i = 0; i < num; i++ )
    this->normalColormap[i] = colors[i];
} // setColorMap()

/*!
  This method sets the colormap for the overlay scene.
*/

void
So@GUI@RenderArea::setOverlayColorMap(
  int start,
  int num,
  const SbColor * colors )
{
  delete [] this->overlayColormap;
  this->overlayColormapStart = start;
  this->overlayColormapSize = num;
  this->overlayColormap = new SbColor [ num ];
  for ( int i = 0; i < num; i++ )
    this->overlayColormap[i] = colors[i];
} // setOverlayColorMap()

// *************************************************************************

/*!
  This method sets the viewport region.
*/

void
So@GUI@RenderArea::setViewportRegion(
  const SbViewportRegion & region )
{
  assert( this->normalManager != NULL );
  this->normalManager->getGLRenderAction()->setViewportRegion( region );
/*
  assert( this->overlayManager != NULL );
  this->overlayManager->getGLRenderAction()->setViewportRegion( region );
*/
} // setViewportRegion()

/*!
  This method returns the viewport region.
*/

const SbViewportRegion &
So@GUI@RenderArea::getViewportRegion(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getGLRenderAction()->getViewportRegion();
} // getViewportRegion()

// *************************************************************************

/*!
  This method sets the transparency type to be used for the scene.
*/

void
So@GUI@RenderArea::setTransparencyType(
  SoGLRenderAction::TransparencyType type )
{
  assert( this->normalManager != NULL );
  this->normalManager->getGLRenderAction()->setTransparencyType( type );
} // setTransparencyType()

/*!
  This method returns the transparency type used for the scene.
*/

SoGLRenderAction::TransparencyType
So@GUI@RenderArea::getTransparencyType(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getGLRenderAction()->getTransparencyType();
} // getTransparencyType()

// *************************************************************************

/*!
  This method sets the antialiasing used for the scene.
*/

void
So@GUI@RenderArea::setAntialiasing(
  SbBool smoothing,
  int numPasses )
{
  assert( this->normalManager != NULL );
  this->normalManager->setAntialiasing( smoothing, numPasses );
} // setAntialiasing()

/*!
  This method returns the antialiasing used for the scene.
*/

void
So@GUI@RenderArea::getAntialiasing(
  SbBool & smoothing,
  int & numPasses) const
{
  assert( this->normalManager != NULL );
  this->normalManager->getAntialiasing(smoothing, numPasses);
} // getAntialiasing()

/*!
  This method sets whether the render buffer should be cleared before
  rendering.
*/

void
So@GUI@RenderArea::setClearBeforeRender(
  SbBool enable,
  SbBool zbEnable )
{
  this->clear = enable;
  this->clearZBuffer = zbEnable;
} // setClearBeforeRender()

/*!
  This method returns whether the render buffer is cleared before each
  render.
*/

SbBool
So@GUI@RenderArea::isClearBeforeRender(
  void ) const
{
  return this->clear;
} // isClearBeforeRender()

/*!
  This method returns whether the render buffer's Z buffer is cleared before
  each render.
*/

SbBool
So@GUI@RenderArea::isClearZBufferBeforeRender(
  void ) const
{
  return this->clearZBuffer;
} // isClearZBufferBeforeRender()

/*!
  This method sets whether the overlay render buffer should be cleared before
  each render or not.
*/

void
So@GUI@RenderArea::setClearBeforeOverlayRender(
  SbBool enable )
{
  this->clearOverlay = enable;
} // setClearBeforeOverlayRender()

/*!
  This method returns whether the overlay render buffer is cleared before
  each redraw or not.
*/

SbBool
So@GUI@RenderArea::isClearBeforeOverlayRender(
  void ) const
{
  return this->clearOverlay;
} // isClearBeforeOverlayRender()

/*!
  This methor sets whether redrawing should be handled automatically or not.
*/

void
So@GUI@RenderArea::setAutoRedraw(
  SbBool enable )
{
  if ( enable )
    this->normalManager->setRenderCallback( So@GUI@RenderArea::renderCB, this );
  else
    this->normalManager->setRenderCallback( NULL, NULL );

  // We can not use the render callback ptr as a flag, as the render
  // callback pointer will be set upon expose events and forced
  // redraws -- and autoRedraw is then used to remember that the
  // pointer should be set back to NULL again after redraw.
  this->autoRedraw = enable;
} // setAutoRedraw()

/*!
  Thie method returns whether redrawing is handled automatically or not.
*/

SbBool
So@GUI@RenderArea::isAutoRedraw(
  void ) const
{
  return this->autoRedraw;
} // isAutoRedraw()

/*!
  This method sets the redraw priority.
*/

void
So@GUI@RenderArea::setRedrawPriority(
  uint32_t priority )
{
  this->normalManager->setRedrawPriority( priority );
  this->overlayManager->setRedrawPriority( priority );
} // setRedrawPriority()

/*!
  This method returns the redraw priority.
*/

uint32_t
So@GUI@RenderArea::getRedrawPriority(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getRedrawPriority();
} // getRedrawPriority()

/*!
  This function returns the default redraw priority.
*/

uint32_t
So@GUI@RenderArea::getDefaultRedrawPriority( // static
  void )
{
  return SoSceneManager::getDefaultRedrawPriority();
} // getDefaultRedrawPriority()

/*!
  This method renders the scene.
*/

void
So@GUI@RenderArea::render(
  void )
{
#if SO@uGUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@GUI@RenderArea::render",
                         "start (waitForExpose: %s)",
                         this->waitForExpose ? "TRUE" : "FALSE");
#endif // debug

  if (!this->waitForExpose) {
    this->glLock(); // this makes the GL context "current"

    SbBool drawfront =
      !this->isDoubleBuffer() ||
      this->isDrawToFrontBufferEnable();

    glDrawBuffer( drawfront ? GL_FRONT_LEFT : GL_BACK_LEFT );

    this->redraw();

    if ( !drawfront ) this->glSwapBuffers();
    else this->glFlushBuffer();

    this->glUnlock();
  }

#if SO@uGUI@_DEBUG && 0 // debug
  SoDebugError::postInfo("So@GUI@RenderArea::render", "done");
#endif // debug
} // render()

/*!
  This method renders the overlay scene.
*/

void
So@GUI@RenderArea::renderOverlay(
  void )
{
  assert( this->overlayManager != NULL );
  this->overlayManager->render( this->clearOverlay, this->clearZBuffer );
} // renderOverlay()

/*!
  This method schedules a redraw to happen at a later time (then the
  application has processed it's other events first).
*/

void
So@GUI@RenderArea::scheduleRedraw(
  void )
{
  assert( this->normalManager != NULL );
  // In case autoRedraw is OFF. The callback pointer will be reset to
  // NULL in renderCB() if autoRedraw is OFF.
  this->normalManager->setRenderCallback( So@GUI@RenderArea::renderCB, this );
  // Redraw when idle.
  this->normalManager->scheduleRedraw();
} // scheduleRedraw()

/*!
  This method schedules a redraw of the overlay scene.
*/

void
So@GUI@RenderArea::scheduleOverlayRedraw(
  void )
{
  assert( this->normalManager != NULL );
  assert( this->overlayManager != NULL );
  this->normalManager->scheduleRedraw(); // FIXME - from old code
  this->overlayManager->scheduleRedraw();
} // scheduleOverlayRedraw()

/*!
  This method sets which selection a selection change on should schedule
  a redraw.
*/

void
So@GUI@RenderArea::redrawOnSelectionChange(
  SoSelection * selection )
{
  this->normalSelection = selection;
} // redrawOnSelectionChange()

/*!
  This method sets which selection a selection change on should schedule
  a redraw of the overlay scene.
*/

void
So@GUI@RenderArea::redrawOverlayOnSelectionChange(
  SoSelection * selection )
{
  this->overlaySelection = selection;
} // redrawOverlayOnSelectionChange()

/*!
  This method sets the render area event callback.
*/

void
So@GUI@RenderArea::setEventCallback(
  So@GUI@RenderAreaEventCB * func,
  void * user )
{
  this->appEventHandler = func;
  this->appEventHandlerData = user;
} // setEventCallback()

/*!
  This method sets the normal scene SoSceneManager object.
*/

void
So@GUI@RenderArea::setSceneManager(
  SoSceneManager * manager )
{
  assert( this->normalManager != NULL );
  this->normalManager = manager;
} // setSceneManager()

/*!
  This method returns the normal scene SoSceneManager object.
*/

SoSceneManager *
So@GUI@RenderArea::getSceneManager(
  void ) const
{
  return this->normalManager;
} // getSceneManager()

/*!
  This method sets the overlay scene SoSceneManager object.
*/

void
So@GUI@RenderArea::setOverlaySceneManager(
  SoSceneManager * manager )
{
  this->overlayManager = manager;
} // setOverlaySceneManager()

/*!
  This method returns the overlay scene SoSceneManager object.
*/

SoSceneManager *
So@GUI@RenderArea::getOverlaySceneManager(
  void ) const
{
  return this->overlayManager;
} // getOverlaySceneManager()

/*!
  This method sets the SoGLRenderAction object for the normal scene.
*/

void
So@GUI@RenderArea::setGLRenderAction(
  SoGLRenderAction * action )
{
  assert( this->normalManager != NULL );
  this->normalManager->setGLRenderAction( action );
} // setGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the normal scene.
*/

SoGLRenderAction *
So@GUI@RenderArea::getGLRenderAction(
  void ) const
{
  assert( this->normalManager != NULL );
  return this->normalManager->getGLRenderAction();
} // getGLRenderAction()

/*!
  This method sets the SoGLRenderAction object for rendering the overlay
  scen graph.
*/

void
So@GUI@RenderArea::setOverlayGLRenderAction(
  SoGLRenderAction * action )
{
  assert( this->overlayManager != NULL );
  this->overlayManager->setGLRenderAction( action );
} // setOverlayGLRenderAction()

/*!
  This method returns the SoGLRenderAction object for the overlay scene
  graph.
*/

SoGLRenderAction *
So@GUI@RenderArea::getOverlayGLRenderAction(
  void ) const
{
  assert( this->overlayManager != NULL );
  return this->overlayManager->getGLRenderAction();
} // getOverlayGLRenderAction()

/*!
  This method redraws the normal scene graph.
*/

void
So@GUI@RenderArea::redraw( // virtual, protected
  void )
{
  this->actualRedraw();
} // redraw()

/*!
  This method redraws the normal scene graph.
*/

void
So@GUI@RenderArea::actualRedraw( // virtual, protected
  void )
{
  assert( this->normalManager != NULL );
  this->normalManager->render( this->clear, this->clearZBuffer );
} // actualRedraw()

/*!
  This method redraws the overlay scene.
*/

void
So@GUI@RenderArea::redrawOverlay( // virtual, protected
  void )
{
  this->actualOverlayRedraw();
} // redrawOverlay()

/*!
  This method renders the overlay scene.
*/

void
So@GUI@RenderArea::actualOverlayRedraw( // virtual, protected
  void )
{
  assert( this->overlayManager != NULL );
  this->overlayManager->render( this->clearOverlay, this->clearZBuffer );
} // actualOverlayRedraw()

/*!
  This method is invoked to initialize the normal graphics.
*/

void
So@GUI@RenderArea::initGraphic( // virtual, protected
  void )
{
  SO@uGUI@_STUB();
} // initGraphic()

/*!
  This method is invoked to initialize the overlay graphics.
*/

void
So@GUI@RenderArea::initOverlayGraphic( // virtual, protected
  void )
{
  SO@uGUI@_STUB();
} // initOverlayGraphic()

/*!
  This method is 
*/

void
So@GUI@RenderArea::sizeChanged( // virtual, protected
  const SbVec2s size )
{
  inherited::sizeChanged( size );

  assert( this->normalManager != NULL );
  assert( this->overlayManager != NULL );

  const SbVec2s glsize = this->getGLSize();

  this->normalManager->setWindowSize( glsize );
  this->normalManager->setSize( glsize );
//  this->normalManager->setViewportRegion( SbViewportRegion( glsize ) );
//  this->normalManager->scheduleRedraw();

  this->overlayManager->setWindowSize( glsize );
  this->overlayManager->setSize( glsize );
//  this->overlayManager->setViewportRegion( SbViewportRegion( glsize ) );
//  this->overlayManager->scheduleRedraw();

  if ( this->devices.mouse != NULL )
    this->devices.mouse->setWindowSize( glsize );
  if ( this->devices.keyboard != NULL )
    this->devices.keyboard->setWindowSize( glsize );
  if ( this->devices.extra != NULL ) {
    for ( int i = 0; i < this->devices.extra->getLength(); i++ )
      ((So@GUI@Device *)((*(this->devices.extra))[i]))->setWindowSize( glsize );
  }
} // sizeChanged()

/*!
  This method is invoked when a widget is changed in the component.
*/

void
So@GUI@RenderArea::widgetChanged( // virtual, protected
  @WIDGET@ widget )
{
  SO@uGUI@_STUB();
} // widgetChanged()

/*!
  This method builds the So@Gui@RenderArea contents in the \a parent
  widget.
*/

@WIDGET@
So@GUI@RenderArea::buildWidget( // protected
  @WIDGET@ parent )
{
  @WIDGET@ widget = inherited::buildWidget( parent );
  if ( this->devices.extra != NULL ) {
    for ( int i = 0; i < this->devices.extra->getLength(); i++ ) {
      So@GUI@Device * device = (So@GUI@Device *) (*this->devices.extra)[i];
      device->enable( this->getGLWidget(),
        (So@GUI@EventHandlerPtr) inherited::eventHandler, (void *) this );
    }
  }
  const SbVec2s glsize = this->getGLSize();
  this->setViewportRegion( SbViewportRegion( glsize[0], glsize[1] ) );
  return widget;
} // buildWidget()

/*!
  This method returns a default widget name for the base widget.
*/

const char *
So@GUI@RenderArea::getDefaultWidgetName( // virtual, protected
  void ) const
{
  static const char defaultWidgetName[] = "So@GUI@WidgetName";
  return defaultWidgetName;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window.
*/

const char *
So@GUI@RenderArea::getDefaultTitle( // virtual, protected
  void ) const
{
  static const char defaultTitle[] = "@GUI@ RenderArea";
  return defaultTitle;
} // getDefaultTitle()

/*!
  This method returns a default title for the component window icon.
*/

const char *
So@GUI@RenderArea::getDefaultIconTitle( // virtual, protected
  void ) const
{
  static const char defaultIconTitle[] = "@GUI@ RenderArea";
  return defaultIconTitle;
} // getDefaultIconTitle()

/*!
  This method invokes the application event handler, if one is set.
*/

SbBool
So@GUI@RenderArea::invokeAppCB( // protected
  @EVENT@ event )
{
  if ( this->appEventHandler != NULL )
    return this->appEventHandler( this->appEventHandlerData, event );
  return FALSE;
} // invokeAppCB()

// *************************************************************************

/*!
*/

void
So@GUI@RenderArea::renderCB( // static
  void * user,
  SoSceneManager * manager )
{
  So@GUI@RenderArea * thisptr = (So@GUI@RenderArea *) user;
  thisptr->render();

  if ( !thisptr->isAutoRedraw() )
    thisptr->normalManager->setRenderCallback( NULL, NULL );
} // renderCB()

// *************************************************************************

/*!
  This method is invoked when the GL area is resized.
*/

void
So@GUI@RenderArea::glReshape( // virtual, derived
  int width,
  int height )
{
  inherited::glReshape( width, height );

  this->glLock();
  this->setViewportRegion( SbViewportRegion( width, height ) );
  this->glUnlock();
  // call widgetChanged() or something?
  this->actualRedraw();
} // glReshape()

/*!
  This method is invoked to redraw the GL area.
*/

void
So@GUI@RenderArea::glRender( // virtual, derived
  void )
{
  // Do not do immediate redraw on expose events, as there might be a
  // series of them coming along and it would be wasteful and stupid
  // to re-render on all of them.
  this->scheduleRedraw();
} // glRender()

/*!
  This method is invoked on initialization of the GL area.
*/

void
So@GUI@RenderArea::glInit( // virtual, derived
  void )
{
  inherited::glInit();

} // glInit()

// *************************************************************************

#if SO@uGUI@_DEBUG
static const char * getSo@GUI@RenderAreaRCSId(void) { return rcsid; }
#endif // SO@uGUI@_DEBUG

