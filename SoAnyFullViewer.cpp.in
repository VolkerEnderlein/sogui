/**************************************************************************
 *
 *  This file is part of the Coin GUI binding libraries.
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  The libraries this file is part of is free software; you can
 *  redistribute them and/or modify them under the terms of the GNU
 *  Lesser General Public License version 2.1 as published by the
 *  Free Software Foundation.  See the file LICENSE.LGPL at the root
 *  directory of the distribution for all the details.
 *
 *  If you want to use the Coin GUI binding libraries for applications
 *  not compatible with the LGPL, contact SIM about acquiring a
 *  Professional Edition License.
 *
 *  Systems in Motion, Prof Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ support@sim.no Voice: +47 22114160 Fax: +47 22207097
 *
 **************************************************************************/

// @configure_input@

#if SO@GUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@GUI@_DEBUG

/*!
  \class SoAnyFullViewer SoAnyFullViewer.h
  \brief The SoAnyFullViewer class is a collection of common functions for
  all the FullViewer components for Coin.
*/

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include <Inventor/errors/SoDebugError.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoKeyboardEvent.h>

#include <so@gui@defs.h>
#include <Inventor/@Gui@/So@Gui@Component.h>
#include <Inventor/@Gui@/widgets/So@Gui@PopupMenu.h>
#include <Inventor/@Gui@/viewers/SoAnyFullViewer.h>
#include <Inventor/@Gui@/viewers/So@Gui@FullViewer.h>

#include <assert.h>

#define MOUSEBUTTON_EVENT  SoMouseButtonEvent::getClassTypeId()
#define KEYBOARD_EVENT     SoKeyboardEvent::getClassTypeId()

// ************************************************************************

/*!
  Constructor.
*/

SoAnyFullViewer::SoAnyFullViewer(
  So@Gui@FullViewer * const _viewer )
  : viewer( _viewer ),
    prefmenu( NULL ),
    popupmenutitle( _( "Viewer settings" ) )
{
  assert( _viewer != NULL );
} // SoAnyFullViewer()

/*!
  Destructor.
*/

SoAnyFullViewer::~SoAnyFullViewer(
  void )
{
} // ~SoAnyFullViewer()

// ************************************************************************

void
SoAnyFullViewer::setPopupMenuString( const char * name )
{
  this->popupmenutitle = name;
  if (this->prefmenu) { this->prefmenu->setMenuTitle( ROOT_MENU, name ); }
}

// ************************************************************************

SoAnyPopupMenu *
SoAnyFullViewer::setupStandardPopupMenu(
  void )
{
  SoAnyPopupMenu * menu = new So@Gui@PopupMenu;

  menu->newMenu( "rootmenu", ROOT_MENU );
  // FIXME: none of the So*-toolkits so far uses the rootmenu title to
  // set up a title string at the top of the root popupmenu. 20010810 mortene.
  menu->setMenuTitle( ROOT_MENU, this->popupmenutitle.getString() );

#if 0 // OBSOLETED: this looks ugly and confusing for the user. 20010810 mortene.
  // Simple hack for a common / generic way of setting up a title for
  // the popupmenu.
  menu->newMenuItem( "rootmenutitle", ROOT_MENU_TITLE );
  menu->setMenuItemTitle( ROOT_MENU_TITLE, this->popupmenutitle.getString() );
  menu->addMenuItem( ROOT_MENU, ROOT_MENU_TITLE );
  menu->setMenuItemEnabled( ROOT_MENU_TITLE, FALSE );
  menu->addSeparator( ROOT_MENU );
#endif // OBSOLETED

  menu->newMenu( "functionsmenu", FUNCTIONS_MENU );
  menu->setMenuTitle( FUNCTIONS_MENU, _( "Functions" ) );
  menu->newMenu( "drawstylesmenu", DRAWSTYLES_MENU );
  menu->setMenuTitle( DRAWSTYLES_MENU, _( "Draw Styles" ) );
  menu->newMenu( "stereomenu", STEREO_MENU );
  menu->setMenuTitle( STEREO_MENU, _( "Stereo Viewing" ) );
  menu->newMenuItem( "examining", EXAMINING_ITEM );
  menu->setMenuItemTitle( EXAMINING_ITEM, _( "Viewing" ) );
  menu->newMenuItem( "decoration", DECORATION_ITEM );
  menu->setMenuItemTitle( DECORATION_ITEM, _( "Decorations" ) );
  menu->newMenuItem( "headlight", HEADLIGHT_ITEM );
  menu->setMenuItemTitle( HEADLIGHT_ITEM, _( "Headlight" ) );
#ifdef HAVE_SOGUI_GOFULLSCREEN
  menu->newMenuItem( "fullscreen", FULLSCREEN_ITEM );
  menu->setMenuItemTitle( FULLSCREEN_ITEM, _( "Fullscreen" ) );
#endif /* HAVE_SOGUI_GOFULLSCREEN */
  menu->newMenuItem( "preferences", PREFERENCES_ITEM );
  menu->setMenuItemTitle( PREFERENCES_ITEM, _( "Preferences..." ) );

  menu->addMenu( ROOT_MENU, FUNCTIONS_MENU );
  menu->addMenu( ROOT_MENU, DRAWSTYLES_MENU );
  menu->addMenu( ROOT_MENU, STEREO_MENU );
  menu->addMenuItem( ROOT_MENU, EXAMINING_ITEM );
  menu->addMenuItem( ROOT_MENU, DECORATION_ITEM );
  menu->addMenuItem( ROOT_MENU, HEADLIGHT_ITEM );
#ifdef HAVE_SOGUI_GOFULLSCREEN
  menu->addMenuItem( ROOT_MENU, FULLSCREEN_ITEM );
#endif /* HAVE_SOGUI_GOFULLSCREEN */
  menu->addSeparator( ROOT_MENU );
  menu->addMenuItem( ROOT_MENU, PREFERENCES_ITEM );

  menu->newMenuItem( "help", HELP_ITEM );
  menu->setMenuItemTitle( HELP_ITEM, _( "Help" ) );
  menu->newMenuItem( "home", HOME_ITEM );
  menu->setMenuItemTitle( HOME_ITEM, _( "Home" ) );
  menu->newMenuItem( "set_home", SET_HOME_ITEM );
  menu->setMenuItemTitle( SET_HOME_ITEM, _( "Set Home" ) );
  menu->newMenuItem( "view_all", VIEW_ALL_ITEM );
  menu->setMenuItemTitle( VIEW_ALL_ITEM, _( "View All" ) );
  menu->newMenuItem( "seek", SEEK_ITEM );
  menu->setMenuItemTitle( SEEK_ITEM, _( "Seek" ) );
  menu->newMenuItem( "copy_view", COPY_VIEW_ITEM );
  menu->setMenuItemTitle( COPY_VIEW_ITEM, _( "Copy View" ) );
  menu->newMenuItem( "paste_view", PASTE_VIEW_ITEM );
  menu->setMenuItemTitle( PASTE_VIEW_ITEM, _( "Paste View" ) );

  menu->addMenuItem( FUNCTIONS_MENU, HELP_ITEM );
  menu->addMenuItem( FUNCTIONS_MENU, HOME_ITEM );
  menu->addMenuItem( FUNCTIONS_MENU, SET_HOME_ITEM );
  menu->addMenuItem( FUNCTIONS_MENU, VIEW_ALL_ITEM );
  menu->addMenuItem( FUNCTIONS_MENU, SEEK_ITEM );
  menu->addSeparator( FUNCTIONS_MENU );
  menu->addMenuItem( FUNCTIONS_MENU, COPY_VIEW_ITEM );
  menu->addMenuItem( FUNCTIONS_MENU, PASTE_VIEW_ITEM );

  menu->newMenu( "drawstylesstill", DRAWSTYLES_STILL_MENU );
  menu->setMenuTitle( DRAWSTYLES_STILL_MENU, _( "Still Drawstyle" ) );

  menu->newMenuItem( "as_is", AS_IS_ITEM );
  menu->setMenuItemTitle( AS_IS_ITEM, _( "as is" ) );
  menu->newMenuItem( "hidden_line", HIDDEN_LINE_ITEM );
  menu->setMenuItemTitle( HIDDEN_LINE_ITEM, _( "hidden line" ) );
  menu->newMenuItem( "wireframe_overlay", WIREFRAME_OVERLAY_ITEM );
  menu->setMenuItemTitle( WIREFRAME_OVERLAY_ITEM, _( "wireframe overlay" ) );
  menu->newMenuItem( "no_textures", NO_TEXTURE_ITEM );
  menu->setMenuItemTitle( NO_TEXTURE_ITEM, _( "no texture" ) );
  menu->newMenuItem( "low_resolution", LOW_RESOLUTION_ITEM );
  menu->setMenuItemTitle( LOW_RESOLUTION_ITEM, _( "low resolution" ) );
  menu->newMenuItem( "wireframe", WIREFRAME_ITEM );
  menu->setMenuItemTitle( WIREFRAME_ITEM, _( "wireframe" ) );
  menu->newMenuItem( "points", POINTS_ITEM );
  menu->setMenuItemTitle( POINTS_ITEM, _( "points" ) );
  menu->newMenuItem( "bounding_box", BOUNDING_BOX_ITEM );
  menu->setMenuItemTitle( BOUNDING_BOX_ITEM, _( "bounding box (no depth)" ) );

  menu->newRadioGroup( STILL_GROUP );
  menu->addRadioGroupItem( STILL_GROUP, AS_IS_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, HIDDEN_LINE_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, WIREFRAME_OVERLAY_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, NO_TEXTURE_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, LOW_RESOLUTION_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, WIREFRAME_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, POINTS_ITEM );
  menu->addRadioGroupItem( STILL_GROUP, BOUNDING_BOX_ITEM );

  menu->addMenuItem( DRAWSTYLES_STILL_MENU, AS_IS_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, HIDDEN_LINE_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, WIREFRAME_OVERLAY_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, NO_TEXTURE_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, LOW_RESOLUTION_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, WIREFRAME_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, POINTS_ITEM );
  menu->addMenuItem( DRAWSTYLES_STILL_MENU, BOUNDING_BOX_ITEM );

  menu->newMenu( "drawstylesanimation", DRAWSTYLES_ANIMATING_MENU );
  menu->setMenuTitle( DRAWSTYLES_ANIMATING_MENU, _( "Animating Drawstyle" ) );

  menu->newMenuItem( "move_same_as_still", MOVE_SAME_AS_STILL_ITEM );
  menu->setMenuItemTitle( MOVE_SAME_AS_STILL_ITEM, _( "same as still" ) );
  menu->newMenuItem( "move_no_texture", MOVE_NO_TEXTURE_ITEM );
  menu->setMenuItemTitle( MOVE_NO_TEXTURE_ITEM, _( "no texture" ) );
  menu->newMenuItem( "move_low_res", MOVE_LOW_RES_ITEM );
  menu->setMenuItemTitle( MOVE_LOW_RES_ITEM, _( "low resolution" ) );
  menu->newMenuItem( "move_wireframe", MOVE_WIREFRAME_ITEM );
  menu->setMenuItemTitle( MOVE_WIREFRAME_ITEM, _( "wireframe" ) );
  menu->newMenuItem( "move_low_res_wireframe", MOVE_LOW_RES_WIREFRAME_ITEM );
  menu->setMenuItemTitle( MOVE_LOW_RES_WIREFRAME_ITEM,
    _( "low res wireframe (no depth)" ) );
  menu->newMenuItem( "move_points", MOVE_POINTS_ITEM );
  menu->setMenuItemTitle( MOVE_POINTS_ITEM, _( "points" ) );
  menu->newMenuItem( "move_low_res_points", MOVE_LOW_RES_POINTS_ITEM );
  menu->setMenuItemTitle( MOVE_LOW_RES_POINTS_ITEM,
    _( "low res points (no depth)" ) );
  menu->newMenuItem( "move_bounding_box", MOVE_BOUNDING_BOX_ITEM );
  menu->setMenuItemTitle( MOVE_BOUNDING_BOX_ITEM, _( "bounding box (no depth)" ) );

  menu->newRadioGroup( MOVE_GROUP );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_SAME_AS_STILL_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_NO_TEXTURE_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_LOW_RES_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_WIREFRAME_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_LOW_RES_WIREFRAME_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_POINTS_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_LOW_RES_POINTS_ITEM );
  menu->addRadioGroupItem( MOVE_GROUP, MOVE_BOUNDING_BOX_ITEM );

  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_SAME_AS_STILL_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_NO_TEXTURE_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_WIREFRAME_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_WIREFRAME_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_POINTS_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_LOW_RES_POINTS_ITEM );
  menu->addMenuItem( DRAWSTYLES_ANIMATING_MENU, MOVE_BOUNDING_BOX_ITEM );

  menu->newMenu( "transparencytype", TRANSPARENCY_TYPE_MENU );
  menu->setMenuTitle( TRANSPARENCY_TYPE_MENU, _( "Transparency Type" ) );

  menu->newMenuItem( "screen_door", SCREEN_DOOR_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( SCREEN_DOOR_TRANSPARENCY_ITEM, _( "screen door" ) );
  menu->newMenuItem( "add", ADD_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( ADD_TRANSPARENCY_ITEM, _( "add" ) );
  menu->newMenuItem( "delayed_add", DELAYED_ADD_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( DELAYED_ADD_TRANSPARENCY_ITEM, _( "delayed add" ) );
  menu->newMenuItem( "sorted_object_add", SORTED_OBJECT_ADD_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( SORTED_OBJECT_ADD_TRANSPARENCY_ITEM,
                          _( "sorted object add" ) );
  menu->newMenuItem( "blend", BLEND_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( BLEND_TRANSPARENCY_ITEM, _( "blend" ) );
  menu->newMenuItem( "delayed_blend", DELAYED_BLEND_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( DELAYED_BLEND_TRANSPARENCY_ITEM, _( "delayed blend" ) );
  menu->newMenuItem( "sorted_object_blend",
                     SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM );
  menu->setMenuItemTitle( SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM,
                          _( 
"sorted object blend" ) );

  menu->newRadioGroup( TRANSPARENCY_GROUP );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP, SCREEN_DOOR_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP, ADD_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP, DELAYED_ADD_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP,
                           SORTED_OBJECT_ADD_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP, BLEND_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP,
                           DELAYED_BLEND_TRANSPARENCY_ITEM );
  menu->addRadioGroupItem( TRANSPARENCY_GROUP,
                           SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM );

  menu->addMenuItem( TRANSPARENCY_TYPE_MENU, SCREEN_DOOR_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU, ADD_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU, DELAYED_ADD_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU,
                     SORTED_OBJECT_ADD_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU, BLEND_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU, DELAYED_BLEND_TRANSPARENCY_ITEM );
  menu->addMenuItem( TRANSPARENCY_TYPE_MENU,
                     SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM );


  menu->newMenuItem( "stereooff", STEREO_OFF_ITEM );
  menu->newMenuItem( "stereoredcyan", STEREO_ANAGLYPH_ITEM );
  menu->newMenuItem( "stereoquadbuffer", STEREO_QUADBUFFER_ITEM );
  menu->setMenuItemTitle( STEREO_OFF_ITEM, _( "Off" ) );
  menu->setMenuItemTitle( STEREO_ANAGLYPH_ITEM, _( "Red/Cyan" ) );
  menu->setMenuItemTitle( STEREO_QUADBUFFER_ITEM, _( "Quad buffer" ) );

  menu->newRadioGroup( STEREO_GROUP );
  menu->addRadioGroupItem( STEREO_GROUP, STEREO_OFF_ITEM );
  menu->addRadioGroupItem( STEREO_GROUP, STEREO_ANAGLYPH_ITEM );
  menu->addRadioGroupItem( STEREO_GROUP, STEREO_QUADBUFFER_ITEM );

  menu->addMenuItem( STEREO_MENU, STEREO_OFF_ITEM );
  menu->addMenuItem( STEREO_MENU, STEREO_ANAGLYPH_ITEM );
  menu->addMenuItem( STEREO_MENU, STEREO_QUADBUFFER_ITEM );

  menu->newMenu( "renderbuffertype", RENDER_BUFFER_TYPE_MENU );
  menu->setMenuTitle( RENDER_BUFFER_TYPE_MENU, _( "Render Buffer Type" ) );

  menu->newMenuItem( "single_buffer", SINGLE_BUFFER_ITEM );
  menu->setMenuItemTitle( SINGLE_BUFFER_ITEM, _( "single" ) );
  menu->newMenuItem( "double_buffer", DOUBLE_BUFFER_ITEM );
  menu->setMenuItemTitle( DOUBLE_BUFFER_ITEM, _( "double" ) );
  menu->newMenuItem( "interactive_buffer", INTERACTIVE_BUFFER_ITEM );
  menu->setMenuItemTitle( INTERACTIVE_BUFFER_ITEM, _( "interactive" ) );

  menu->newRadioGroup( BUFFER_GROUP );
  menu->addRadioGroupItem( BUFFER_GROUP, SINGLE_BUFFER_ITEM );
  menu->addRadioGroupItem( BUFFER_GROUP, DOUBLE_BUFFER_ITEM );
  menu->addRadioGroupItem( BUFFER_GROUP, INTERACTIVE_BUFFER_ITEM );

  menu->addMenuItem( RENDER_BUFFER_TYPE_MENU, SINGLE_BUFFER_ITEM );
  menu->addMenuItem( RENDER_BUFFER_TYPE_MENU, DOUBLE_BUFFER_ITEM );
  menu->addMenuItem( RENDER_BUFFER_TYPE_MENU, INTERACTIVE_BUFFER_ITEM );

  menu->addMenu( DRAWSTYLES_MENU, DRAWSTYLES_STILL_MENU );
  menu->addMenu( DRAWSTYLES_MENU, DRAWSTYLES_ANIMATING_MENU );
  menu->addMenu( DRAWSTYLES_MENU, TRANSPARENCY_TYPE_MENU );
  menu->addMenu( DRAWSTYLES_MENU, RENDER_BUFFER_TYPE_MENU );

  int toggle;
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem( toggle, EXAMINING_ITEM );
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem( toggle, DECORATION_ITEM );
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem( toggle, HEADLIGHT_ITEM );
#ifdef HAVE_SOGUI_GOFULLSCREEN
  toggle = menu->newRadioGroup();
  menu->addRadioGroupItem( toggle, FULLSCREEN_ITEM );
#endif /* HAVE_SOGUI_GOFULLSCREEN */

  menu->addMenuSelectionCallback( SoAnyFullViewer::menuSelectionCallback,
    (void *) this );

  this->prefmenu = menu;
  return menu;
} // buildPopupMenu()

// ************************************************************************

void
SoAnyFullViewer::prepareMenu( SoAnyPopupMenu * menu )
{
  //// Misc. //////////////////////////////////////////////////////////
  menu->setMenuItemMarked( DECORATION_ITEM, this->viewer->isDecoration() );
  menu->setMenuItemMarked( EXAMINING_ITEM, this->viewer->isViewing() );
  menu->setMenuItemMarked( HEADLIGHT_ITEM, this->viewer->isHeadlight() );
#ifdef HAVE_SOGUI_GOFULLSCREEN
  menu->setMenuItemMarked( FULLSCREEN_ITEM, this->viewer->isFullScreen() );
#endif /* HAVE_SOGUI_GOFULLSCREEN */

  //// Basic drawstyles. //////////////////////////////////////////////
  this->setDrawStyleMenuActivation(So@Gui@FullViewer::STILL,
                                   this->viewer->getDrawStyle(So@Gui@FullViewer::STILL));
  this->setDrawStyleMenuActivation(So@Gui@FullViewer::INTERACTIVE,
                                   this->viewer->getDrawStyle(So@Gui@FullViewer::INTERACTIVE));

  //// Transparency setting. //////////////////////////////////////////
  switch ( this->viewer->getTransparencyType() ) {
  case SoGLRenderAction::SCREEN_DOOR:
    menu->setMenuItemMarked( SCREEN_DOOR_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::ADD:
    menu->setMenuItemMarked( ADD_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::DELAYED_ADD:
    menu->setMenuItemMarked( DELAYED_ADD_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::SORTED_OBJECT_ADD:
    menu->setMenuItemMarked( SORTED_OBJECT_ADD_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::BLEND:
    menu->setMenuItemMarked( BLEND_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::DELAYED_BLEND:
    menu->setMenuItemMarked( DELAYED_BLEND_TRANSPARENCY_ITEM, TRUE );
    break;
  case SoGLRenderAction::SORTED_OBJECT_BLEND:
    menu->setMenuItemMarked( SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM, TRUE );
    break;
  default: assert( FALSE && "unknown transparency type" );
  }

  //// Stereo viewing. ////////////////////////////////////////////////
  SbBool stereo = this->viewer->isStereoViewing();
  SbBool quadbuffer = this->viewer->isQuadBufferStereo();
 if ( !stereo )
  menu->setMenuItemMarked( STEREO_OFF_ITEM, TRUE );
 if ( stereo && !quadbuffer )
  menu->setMenuItemMarked( STEREO_ANAGLYPH_ITEM, TRUE );
 if ( stereo && quadbuffer )
  menu->setMenuItemMarked( STEREO_QUADBUFFER_ITEM, TRUE );

  //// GL canvas settings. ////////////////////////////////////////////
  switch ( this->viewer->getBufferingType() ) {
  case So@Gui@Viewer::BUFFER_SINGLE:
    menu->setMenuItemMarked( SINGLE_BUFFER_ITEM, TRUE );
    break;
  case So@Gui@Viewer::BUFFER_DOUBLE:
    menu->setMenuItemMarked( DOUBLE_BUFFER_ITEM, TRUE );
    break;
  case So@Gui@Viewer::BUFFER_INTERACTIVE:
    menu->setMenuItemMarked( INTERACTIVE_BUFFER_ITEM, TRUE );
    break;
  default:
    assert( 0 && "unsupported buffer type" );
    break;
  }
}

// ************************************************************************

void
SoAnyFullViewer::menuSelection( // virtual
  int menuitemid )
{
  switch ( menuitemid ) {
  case -1:
    // means no item was selected
#if SO@GUI@_DEBUG
    SoDebugError::postInfo( "So@Gui@FullViewer::menuSelection",
      "-1 not appropriate on callback usage" );
#endif // SO@GUI@_DEBUG
    break;

  case EXAMINING_ITEM:
    viewer->setViewing( viewer->isViewing() ? FALSE : TRUE );
    break;
  case DECORATION_ITEM:
    viewer->setDecoration( viewer->isDecoration() ? FALSE : TRUE );
    break;
  case HEADLIGHT_ITEM:
    viewer->setHeadlight( viewer->isHeadlight() ? FALSE : TRUE );
    break;
#ifdef HAVE_SOGUI_GOFULLSCREEN
  case FULLSCREEN_ITEM:
    viewer->goFullScreen( viewer->isFullScreen() ? FALSE : TRUE );
    break;
#endif /* HAVE_SOGUI_GOFULLSCREEN */
  case PREFERENCES_ITEM:
    viewer->selectedPrefs();
    break;

  case HELP_ITEM:
    viewer->openViewerHelpCard();
    break;
  case HOME_ITEM:
    viewer->resetToHomePosition();
    break;
  case SET_HOME_ITEM:
    viewer->saveHomePosition();
    break;
  case VIEW_ALL_ITEM:
    viewer->viewAll();
    break;
  case SEEK_ITEM:
    viewer->seekbuttonClicked();
    break;
  case COPY_VIEW_ITEM:
    viewer->copyView( SbTime::getTimeOfDay() );

    break;
  case PASTE_VIEW_ITEM:
    viewer->pasteView( SbTime::getTimeOfDay() );
    break;

  case AS_IS_ITEM:
  case HIDDEN_LINE_ITEM:
  case WIREFRAME_OVERLAY_ITEM:
  case NO_TEXTURE_ITEM:
  case LOW_RESOLUTION_ITEM:
  case WIREFRAME_ITEM:
  case POINTS_ITEM:
  case BOUNDING_BOX_ITEM:
    this->drawstyleActivated( menuitemid );
    break;

  case MOVE_SAME_AS_STILL_ITEM:
  case MOVE_NO_TEXTURE_ITEM:
  case MOVE_LOW_RES_ITEM:
  case MOVE_WIREFRAME_ITEM:
  case MOVE_LOW_RES_WIREFRAME_ITEM:
  case MOVE_POINTS_ITEM:
  case MOVE_LOW_RES_POINTS_ITEM:
  case MOVE_BOUNDING_BOX_ITEM:
    this->drawstyleActivated( menuitemid );
    break;

  case SCREEN_DOOR_TRANSPARENCY_ITEM:
  case ADD_TRANSPARENCY_ITEM:
  case DELAYED_ADD_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_ADD_TRANSPARENCY_ITEM:
  case BLEND_TRANSPARENCY_ITEM:
  case DELAYED_BLEND_TRANSPARENCY_ITEM:
  case SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM:
    this->drawstyleActivated( menuitemid );
    this->viewer->scheduleRedraw();
    break;

  case SINGLE_BUFFER_ITEM:
  case DOUBLE_BUFFER_ITEM:
  case INTERACTIVE_BUFFER_ITEM:
    this->drawstyleActivated( menuitemid );
    break;

  case STEREO_OFF_ITEM:    
    this->viewer->setStereoViewing(FALSE);
    this->viewer->setQuadBufferStereo(FALSE);
    break;
  case STEREO_ANAGLYPH_ITEM:
    this->viewer->setStereoViewing(TRUE);
    this->viewer->setQuadBufferStereo(FALSE);
    break;
  case STEREO_QUADBUFFER_ITEM:
    this->viewer->setStereoViewing(TRUE);
    this->viewer->setQuadBufferStereo(TRUE);
    if (!this->viewer->isQuadBufferStereo()) {
      this->viewer->setStereoViewing(FALSE);
      this->prefmenu->setMenuItemMarked( STEREO_OFF_ITEM, TRUE );
    }
    break;
    
  default:
    SoDebugError::postInfo( "So@Gui@FullViewer::menuSelection",
      "popup menu handling for item %d is not implemented", menuitemid );
    break;
  } // switch ( menuitemid )
} // menuSelection()


// ************************************************************************

void
SoAnyFullViewer::menuSelectionCallback( // static
  int menuitemid,
  void * userdata )
{
  SoAnyFullViewer * viewer = (SoAnyFullViewer *) userdata;
  viewer->menuSelection( menuitemid );
} // menuSelectionCallback()

// ************************************************************************

/*!
 \internal
*/

void
SoAnyFullViewer::setDrawStyleMenuActivation(
  So@Gui@Viewer::DrawType type,
  So@Gui@Viewer::DrawStyle value )
{
  assert( viewer->prefmenu != NULL );

  switch ( type ) {
  case So@Gui@Viewer::STILL:
    switch ( value ) {
    case So@Gui@Viewer::VIEW_AS_IS:
      viewer->prefmenu->setMenuItemMarked( AS_IS_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_HIDDEN_LINE:
      viewer->prefmenu->setMenuItemMarked( HIDDEN_LINE_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_WIREFRAME_OVERLAY:
      viewer->prefmenu->setMenuItemMarked( WIREFRAME_OVERLAY_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_NO_TEXTURE:
      viewer->prefmenu->setMenuItemMarked( NO_TEXTURE_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_COMPLEXITY:
      viewer->prefmenu->setMenuItemMarked( LOW_RESOLUTION_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_LINE:
#if SO@GUI@_DEBUG
      SoDebugError::postWarning("SoAnyFullViewer::setDrawStyleMenuActivation",
                                "Use VIEW_LINE, not VIEW_LOW_RES_LINE for the STILL drawstyle.");
#endif // debug
    case So@Gui@Viewer::VIEW_LINE:
      viewer->prefmenu->setMenuItemMarked( WIREFRAME_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_POINT:
#if SO@GUI@_DEBUG
      SoDebugError::postWarning("SoAnyFullViewer::setDrawStyleMenuActivation",
                                "Use VIEW_POINT, not VIEW_LOW_RES_POINT for the STILL drawstyle.");
#endif // debug
    case So@Gui@Viewer::VIEW_POINT:
      viewer->prefmenu->setMenuItemMarked( POINTS_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_BBOX:
      viewer->prefmenu->setMenuItemMarked( BOUNDING_BOX_ITEM, TRUE );
      break;
    default:
      assert( 0 && "unsupported default switch-case" );
      break;
    } // switch ( value )
    break;

  case So@Gui@Viewer::INTERACTIVE:
    switch ( value ) {
    case So@Gui@Viewer::VIEW_SAME_AS_STILL:
      viewer->prefmenu->setMenuItemMarked( MOVE_SAME_AS_STILL_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_NO_TEXTURE:
      viewer->prefmenu->setMenuItemMarked( MOVE_NO_TEXTURE_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_COMPLEXITY:
      viewer->prefmenu->setMenuItemMarked( MOVE_LOW_RES_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LINE:
      viewer->prefmenu->setMenuItemMarked( MOVE_WIREFRAME_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_LINE:
      viewer->prefmenu->setMenuItemMarked( MOVE_LOW_RES_WIREFRAME_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_POINT:
      viewer->prefmenu->setMenuItemMarked( MOVE_POINTS_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_LOW_RES_POINT:
      viewer->prefmenu->setMenuItemMarked( MOVE_LOW_RES_POINTS_ITEM, TRUE );
      break;
    case So@Gui@Viewer::VIEW_BBOX:
      viewer->prefmenu->setMenuItemMarked( MOVE_BOUNDING_BOX_ITEM, TRUE );
      break;
    default:
      assert( 0 && "unsupported default switch-case" );
      break;
    } // switch ( value )
    break;

  default:
    assert( 0 && "unsupported default switch-case" );
    break;
  } // switch ( type )
} // setDrawStyleMenuActivation()

// ************************************************************************

/*!
  \internal
*/

void
SoAnyFullViewer::drawstyleActivated(
  int menuitemid )
{
  switch ( menuitemid ) {
  case SINGLE_BUFFER_ITEM:
    viewer->setBufferingType( So@Gui@Viewer::BUFFER_SINGLE );
    return;
  case DOUBLE_BUFFER_ITEM:
    viewer->setBufferingType( So@Gui@Viewer::BUFFER_DOUBLE );
    return;
  case INTERACTIVE_BUFFER_ITEM:
    viewer->setBufferingType( So@Gui@Viewer::BUFFER_INTERACTIVE );
    return;
  default:
    break;
  } // switch ( menuitemid )

  switch ( menuitemid ) {
  case SCREEN_DOOR_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::SCREEN_DOOR );
    return;
  case ADD_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::ADD );
    return;
  case DELAYED_ADD_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::DELAYED_ADD );
    return;
  case SORTED_OBJECT_ADD_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::SORTED_OBJECT_ADD );
    return;
  case BLEND_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::BLEND );
    return;
  case DELAYED_BLEND_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::DELAYED_BLEND );
    return;
  case SORTED_OBJECT_BLEND_TRANSPARENCY_ITEM:
    this->viewer->setTransparencyType( SoGLRenderAction::SORTED_OBJECT_BLEND );
    return;
  default:
    break;
  } // switch ( menuitemid )

  So@Gui@Viewer::DrawStyle val = So@Gui@Viewer::VIEW_AS_IS;
  switch ( menuitemid ) {
  case AS_IS_ITEM:
    val = So@Gui@Viewer::VIEW_AS_IS;
    break;
  case HIDDEN_LINE_ITEM:
    val = So@Gui@Viewer::VIEW_HIDDEN_LINE;
    break;
  case WIREFRAME_OVERLAY_ITEM:
    val = So@Gui@Viewer::VIEW_WIREFRAME_OVERLAY;
    break;
  case NO_TEXTURE_ITEM:
    val = So@Gui@Viewer::VIEW_NO_TEXTURE;
    break;
  case LOW_RESOLUTION_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_COMPLEXITY;
    break;
  case WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LINE;
    break;
  case POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_POINT;
    break;
  case BOUNDING_BOX_ITEM:
    val = So@Gui@Viewer::VIEW_BBOX;
    break;

  case MOVE_SAME_AS_STILL_ITEM:
    val = So@Gui@Viewer::VIEW_SAME_AS_STILL;
    break;
  case MOVE_NO_TEXTURE_ITEM:
    val = So@Gui@Viewer::VIEW_NO_TEXTURE;
    break;
  case MOVE_LOW_RES_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_COMPLEXITY;
    break;
  case MOVE_WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LINE;
    break;
  case MOVE_LOW_RES_WIREFRAME_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_RES_LINE;
    break;
  case MOVE_POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_POINT;
    break;
  case MOVE_LOW_RES_POINTS_ITEM:
    val = So@Gui@Viewer::VIEW_LOW_RES_POINT;
    break;
  case MOVE_BOUNDING_BOX_ITEM:
    val = So@Gui@Viewer::VIEW_BBOX;
    break;

  default:
    assert( 0 );
    break;
  } // switch ( menuitemid )

  So@Gui@Viewer::DrawType type = So@Gui@Viewer::STILL;

  switch ( menuitemid ) {
  case AS_IS_ITEM:
  case HIDDEN_LINE_ITEM:
  case WIREFRAME_OVERLAY_ITEM:
  case NO_TEXTURE_ITEM:
  case LOW_RESOLUTION_ITEM:
  case WIREFRAME_ITEM:
  case POINTS_ITEM:
  case BOUNDING_BOX_ITEM:
    type = So@Gui@Viewer::STILL;
    break;

  case MOVE_SAME_AS_STILL_ITEM:
  case MOVE_NO_TEXTURE_ITEM:
  case MOVE_LOW_RES_ITEM:
  case MOVE_WIREFRAME_ITEM:
  case MOVE_LOW_RES_WIREFRAME_ITEM:
  case MOVE_POINTS_ITEM:
  case MOVE_LOW_RES_POINTS_ITEM:
  case MOVE_BOUNDING_BOX_ITEM:
    type = So@Gui@Viewer::INTERACTIVE;
    break;

  default:
    assert( 0 );
    break;
  } // switch ( menuitemid )

  viewer->setDrawStyle( type, val );
} // drawstyleActivated()

// ************************************************************************

SbBool
SoAnyFullViewer::processSoEvent(
  const SoEvent * const ev )
{
  if ( ! viewer->isViewing() ) // scene event
    return FALSE;

  const SoType type( ev->getTypeId() );

  if ( type.isDerivedFrom( MOUSEBUTTON_EVENT ) ) {
    SoMouseButtonEvent * const event = (SoMouseButtonEvent *) ev;
    const int button = event->getButton();
    if ( (button == SoMouseButtonEvent::BUTTON1) &&
         viewer->isSeekMode() ) {
      if ( event->getState() == SoButtonEvent::DOWN )
        viewer->seekToPoint( event->getPosition() );
      return TRUE;
    }
    if ( (button == SoMouseButtonEvent::BUTTON2) ) {
      if ( event->getState() == SoButtonEvent::DOWN && viewer->prefmenu )
        viewer->openPopupMenu( event->getPosition() );
      return TRUE;
    }
    return FALSE;
  }

  if ( type.isDerivedFrom( KEYBOARD_EVENT ) ) {
    SoKeyboardEvent * const event = (SoKeyboardEvent *) ev;
    if ( event->getState() == SoButtonEvent::DOWN ) {
      if ( event->getKey() == SoKeyboardEvent::S ) {
        viewer->setSeekMode( viewer->isSeekMode() ? FALSE : TRUE );
        return TRUE;
      }
      return FALSE;
    }
    if ( event->getState() == SoButtonEvent::UP ) {
      if ( event->getKey() == SoKeyboardEvent::S ) return TRUE;
      return FALSE;
    }
    return FALSE;
  }

  return FALSE;
} // processSoEvent()

// ************************************************************************

#if SO@GUI@_DEBUG
static const char * getSoAnyFullViewerRCSId(void) { return rcsid; }
#endif // SO@GUI@_DEBUG

